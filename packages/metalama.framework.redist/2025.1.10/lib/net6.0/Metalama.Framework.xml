<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Metalama.Framework</name>
  </assembly>
  <members>
    <member name="T:Metalama.Framework.Advising.AdviceKind">
      <summary>
            Enumerates the kinds of advice.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.AdviceOutcome">
      <summary>
            Status codes of the result of an advice. This enum is exposed on the <see cref="P:Metalama.Framework.Advising.IAdviceResult.Outcome" /> property
            of the <see cref="T:Metalama.Framework.Advising.IAdviceResult" /> interface, which is returned by all methods of the <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> interface.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.AdviceOutcome.Default">
      <summary>
            The advice was successfully applied and there was no conflict.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.AdviceOutcome.Override">
      <summary>
            There was a conflict and the advice was successfully applied and the new advice overrides the previous declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.AdviceOutcome.New">
      <summary>
            There was a conflict and the advice was successfully applied and the new advice hides the previous declaration with the <c>new</c> keyword.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.AdviceOutcome.Ignore">
      <summary>
            The advice was ignored, possibly because of a conflict.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.AdviceOutcome.Error">
      <summary>
            There was a conflict or another error. The advice was ignored and the whole aspect was disabled using <see cref="M:Metalama.Framework.Aspects.IAspectBuilder.SkipAspect" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.Override(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IMethod},Metalama.Framework.Advising.MethodTemplateSelector@,System.Object,System.Object)">
      <summary>
            Overrides the implementation of a method.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a method.</param>
      <param name="template">Name of a method in the aspect class whose implementation will be used as a template.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. To select a different templates according to the kind of target method
                (such as async or iterator methods), use the constructor of the <see cref="T:Metalama.Framework.Advising.MethodTemplateSelector" /> type. To specify a single
                template for all methods, pass a string.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template method.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-methods" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceMethod(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder},System.Object,System.Object)">
      <summary>
            Introduces a new method or overrides the implementation of the existing one.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="template">Name of the method of the aspect class that will be used as a template for the introduced method. This method must be
                annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. This method can have parameters and a return type. The actual parameters and return type
                of the introduced method can be modified using the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> returned by this method.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                method. The default scope depends on the scope of the template method.
                If the method is static, the introduced method is static. However, if the template method is non-static, then the introduced method
                copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a method of the same name and signature is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildMethod"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> that allows to modify the name or signature, or to add custom attributes.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceFinalizer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Aspects.OverrideStrategy,System.Object,System.Object)">
      <summary>
            Introduces a finalizer or overrides the implementation of the existing one.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="template">Name of the method of the aspect class that will be used as a template for the introduced finalizer. This method must be
                annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. This method can parameters and a return type.</param>
      <param name="whenExists">Determines the implementation strategy when a finalizer is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.Override(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IConstructor},System.String,System.Object,System.Object)">
      <summary>
            Overrides the implementation of a constructor.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a constructor.</param>
      <param name="template">Name of a method in the aspect class whose implementation will be used as a template.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template method.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.Override(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IFieldOrProperty},System.String,System.Object)">
      <summary>
            Overrides a field or property by specifying a property template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a property.</param>
      <param name="template">The name of a property of the aspect class, with a getter, a setter, or both, whose implementation will be used as a template.
                This property must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template property and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-fields-or-properties" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.OverrideAccessors(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IFieldOrPropertyOrIndexer},Metalama.Framework.Advising.GetterTemplateSelector@,System.String,System.Object,System.Object)">
      <summary>
            Overrides a field or property by specifying a method template for the getter, the setter, or both.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a field, or a property or an indexer.</param>
      <param name="getTemplate">The name of the method of the aspect class whose implementation will be used as a template for the getter, or <c>null</c>
                if the getter should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.
                To select a different templates for iterator getters, use the constructor of the <see cref="T:Metalama.Framework.Advising.GetterTemplateSelector" /> type. To specify a single
                template for all properties, pass a string.
            </param>
      <param name="setTemplate">The name of the method of the aspect class whose implementation will be used as a template for the getter, or <c>null</c>
                if the getter should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-fields-or-properties" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceField(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder},System.Object)">
      <summary>
            Introduces a field to the target type by specifying a template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="template">Name of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildField"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceField(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Code.IType,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder},System.Object)">
      <summary>
            Introduces a field to the target type by specifying a field name and <see cref="T:Metalama.Framework.Code.IType" />.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="fieldName">Name of the introduced field.</param>
      <param name="fieldType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildField"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceField(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,System.Type,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder},System.Object)">
      <summary>
            Introduces a field to the target type by specifying a field name and <see cref="T:System.Type" />.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="fieldName">Name of the introduced field.</param>
      <param name="fieldType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildField"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceAutomaticProperty(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,System.Type,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces an auto-implemented property to the target type by specifying a property name and <see cref="T:System.Type" />.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="propertyName">Name of the introduced field.</param>
      <param name="propertyType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceAutomaticProperty(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Code.IType,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces an auto-implemented property to the target type by specifying a property name and <see cref="T:Metalama.Framework.Code.IType" />.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="propertyName">Name of the introduced field.</param>
      <param name="propertyType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceProperty(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces a property to the target type, or overrides the implementation of an existing one, by specifying a property template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="template">The name of the property in the aspect class that will be used as a template for the new property.
                This property must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The type of this property can be either <c>dynamic</c> or any specific
                type. It is possible to dynamically change the type of the introduced property thanks to the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> returned by
                this method.
            </param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                property. The default scope depends on the scope of the template property. If the property is static, the introduced property is static. However, if the
                template property is non-static, then the introduced property copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags">An optional opaque object of anonymous type passed to the template property and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceProperty(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object,System.Object)">
      <summary>
            Introduces a property to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="name">Name of the introduced property.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced property should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced property should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                property. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced property is static. However, if the
                template accessors are non-static, then the introduced property copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},Metalama.Framework.Code.IType,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="indexType">The type of the initial index parameter.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.Type,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="indexType">The type of the initial index parameter.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.Collections.Generic.IReadOnlyList{System.ValueTuple{Metalama.Framework.Code.IType,System.String}},System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="indices">The types and names of the index parameters.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Type,System.String}},System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="indices">The types and names of the index parameters.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.OverrideAccessors(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IEvent},System.String,System.String,System.String,System.Object,System.Object)">
      <summary>
            Overrides an event by specifying a template for the adder, the remover, and/or the raiser.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for an event.</param>
      <param name="addTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the adder, or <c>null</c>
                the adder should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="removeTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the remover, or <c>null</c>
                the adder should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Remove(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="raiseTemplate">Not yet implemented.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-events" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceEvent(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IEventBuilder},System.Object)">
      <summary>
            Introduces a new event to the target type, or overrides the implementation of an existing one, by specifying an event template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="eventTemplate">The name of the event in the aspect class that must be used as a template for the introduced event. This event
                must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The type of the template event can be any delegate type. The type of the introduced event
                can be changed dynamically thanks to the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> returned by this method. 
            </param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                event. The default scope depends on the scope of the template event. If the event is static, the introduced event is static. However, if the
                template event is non-static, then the introduced event copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when an event of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildEvent"></param>
      <param name="tags">An optional opaque object of anonymous type passed to the template event and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> that allows to change the name and the type of the event.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceEvent(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,System.String,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IEventBuilder},System.Object,System.Object)">
      <summary>
            Introduces a new event to the target type, or overrides the implementation of an existing one, by specifying individual template methods
            for the adder, the remover, and the raiser.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="eventName">The name of the introduced event.</param>
      <param name="addTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the adder.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="removeTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the remover.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="raiseTemplate">Not implemented.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                event. The default scope depends on the scope of the template event. If the event is static, the introduced event is static. However, if the
                template event is non-static, then the introduced event copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when an event of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildEvent"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> that allows to change the name and the type of the event.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.ImplementInterface(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)">
      <summary>
            Makes a type implement a new interface specified as an <see cref="T:Metalama.Framework.Code.INamedType" />.
            Interface members can be introduced declaratively by marking an aspect member by <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" /> or 
            <see cref="T:Metalama.Framework.Aspects.IntroduceAttribute" />, or programmatically using <c>Introduce</c> methods for public implementations of <c>result.ExplicitImplementations.Introduce</c> for private implementations.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="interfaceType">The type of the implemented interface.</param>
      <param name="whenExists">Determines the implementation strategy when the interface is already implemented by the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="tags">An optional opaque object of anonymous type passed to <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" /> templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API. This parameter does not affect members introduced using <see cref="T:Metalama.Framework.Aspects.IntroduceAttribute" /> or programmatically.</param>
      <seealso href="@implementing-interfaces" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.ImplementInterface(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.Type,Metalama.Framework.Aspects.OverrideStrategy,System.Object)">
      <summary>
            Makes a type implement a new interface specified as a reflection <see cref="T:System.Type" />.
            Interface members can be introduced by marking an aspect member by <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" />, 
            <see cref="T:Metalama.Framework.Aspects.IntroduceAttribute" /> or programmatically using <c>Introduce</c> methods.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="interfaceType">The type of the implemented interface.</param>
      <param name="whenExists">Determines the implementation strategy when the interface is already implemented by the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="tags">An optional opaque object of anonymous type passed to <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" /> templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API. This parameter does not affect members introduced using <see cref="T:Metalama.Framework.Aspects.IntroduceAttribute" /> or programmatically.</param>
      <seealso href="@implementing-interfaces" />
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddInitializer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},System.String,Metalama.Framework.Advising.InitializerKind,System.Object,System.Object)">
      <summary>
            Adds a type or instance initializer by using a template. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="template">The name of the template. This method must have no run-time parameter, be of <c>void</c> return type, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="kind">The type of initializer to add.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
      <param name="tags">An optional opaque object of anonymous type passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddInitializer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.INamedType},Metalama.Framework.Code.SyntaxBuilders.IStatement,Metalama.Framework.Advising.InitializerKind)">
      <summary>
            Adds a type or instance initializer by specifying an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a named type.</param>
      <param name="statement">The statement to be inserted at the top of constructors.</param>
      <param name="kind">The type of initializer to add.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddInitializer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IConstructor},System.String,System.Object,System.Object)">
      <summary>
            Adds an initializer to a specific constructor by using a template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a constructor.</param>
      <param name="template">The name of the template. This method must have no run-time parameter, be of <c>void</c> return type, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
      <param name="tags">An optional opaque object of anonymous type  passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddInitializer(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IConstructor},Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Adds an initializer to a specific constructor by specifying an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a constructor.</param>
      <param name="statement">The statement to be inserted at the top of the constructor.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddContract(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IParameter},System.String,Metalama.Framework.Aspects.ContractDirection,System.Object,System.Object)">
      <summary>
            Adds a contract to a parameter. Contracts are usually used to validate parameters (pre- or post-conditions) or to normalize their value (null-to-empty, trimming, normalizing case, ...).
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a parameter.</param>
      <param name="template">The name of the template method. This method must have a single run-time parameter named <c>value</c>, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="direction">Direction of the data flow to which the contract should apply. See <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> for details.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
      <param name="tags">An optional opaque object of anonymous type passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddContract(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IFieldOrPropertyOrIndexer},System.String,Metalama.Framework.Aspects.ContractDirection,System.Object,System.Object)">
      <summary>
            Adds a contract to a field, property or indexer. Contracts are usually used to validate the value assigned to fields properties or indexers or to normalize their value (null-to-empty, trimming, normalizing case, ...)
            before assignment. Alternatively, a contract can be used to validate the value <i>returned</i> by a property or indexer, in which case the <paramref name="direction" /> parameter should be set to <see cref="F:Metalama.Framework.Aspects.ContractDirection.Output" />.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a field, or an property or an indexer.</param>
      <param name="template">The name of the template method. This method must have a single run-time parameter named <c>value</c>, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="direction">Direction of the data flow to which the contract should apply. See <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> for details.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
      <param name="tags">An optional opaque object of anonymous type passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.IntroduceAttribute(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IDeclaration},Metalama.Framework.Code.IAttributeData,Metalama.Framework.Aspects.OverrideStrategy)">
      <summary>
            Adds a custom attribute to a given declaration.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a declaration.</param>
      <param name="attribute">The custom attribute to be added. It can be an existing <see cref="T:Metalama.Framework.Code.IAttribute" />, or you can use <see cref="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction" />
                to specify a new attribute.</param>
      <param name="whenExists">Specifies the strategy to follow when an attribute of the same type already exists on the target declaration. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" /> will fail the
                compilation with an error and is the default strategy. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Ignore" /> will silently ignore the introduction. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Override" /> will remove
                all previous instances and replace them by the new one. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.New" /> will add the new instance regardless.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.RemoveAttributes(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IDeclaration},Metalama.Framework.Code.INamedType)">
      <summary>
            Removes all custom attributes of a given <see cref="T:Metalama.Framework.Code.INamedType" /> from a given declaration.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a declaration.</param>
      <param name="attributeType">The type of custom attributes to be removed.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.RemoveAttributes(Metalama.Framework.Advising.IAdviser{Metalama.Framework.Code.IDeclaration},System.Type)">
      <summary>
            Removes all custom attributes of a given <see cref="T:System.Type" /> from a given declaration.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a declaration.</param>
      <param name="attributeType">The type of custom attributes to be removed.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.AdviserExtensions.AddAnnotation``1(Metalama.Framework.Advising.IAdviser{``0},Metalama.Framework.Code.IAnnotation{``0},System.Boolean)">
      <summary>
            Adds a custom annotation to a declaration. An annotation is an arbitrary but serializable object that can then be retrieved
            using the <see cref="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetAnnotations``1" /> method of the <see cref="M:Metalama.Framework.Code.DeclarationExtensions.Enhancements``1(``0)" /> object.
            Annotations are a way of communication between aspects or classes of aspects.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An adviser for a declaration.</param>
      <param name="annotation">The annotation.</param>
      <param name="export">A value indicating whether the annotation should be exported and made visible to other projects.
            Unless this parameter is set to <c>true</c>, the annotation will only be visible to the current project.</param>
      <typeparam name="TDeclaration">The type of declaration.</typeparam>
    </member>
    <member name="T:Metalama.Framework.Advising.GetterTemplateSelector">
      <summary>
            Specifies the templates that must be used for the <c>get</c> accessor by the <c>IAdviceFactory.OverrideAccessors</c> advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.GetterTemplateSelector.DefaultTemplate">
      <summary>
            Gets the name of the template that must be applied if no other template is applicable. This property is required if you want to
            override the getter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumerableTemplate">
      <summary>
            Gets the name of the template that must be applied to iterator getters returning an <see cref="T:System.Collections.Generic.IEnumerable`1" /> or <see cref="T:System.Collections.IEnumerable" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumeratorTemplate">
      <summary>
            Gets the name of the template that must be applied to iterator getters returning an <see cref="T:System.Collections.Generic.IEnumerator`1" /> or <see cref="T:System.Collections.IEnumerator" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.GetterTemplateSelector.UseEnumerableTemplateForAnyEnumerable">
      <summary>
            Gets a value indicating whether the <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumerableTemplate" /> or <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumeratorTemplate" />
            must be applied to all methods returning compatible return type, instead of only to methods using the <c>yield</c> statement.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.GetterTemplateSelector.#ctor(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Advising.GetterTemplateSelector" /> struct by specifying the name of the template methods to be applied. The named passed to this
            constructor must be the name of methods of the current aspect class, and these methods must be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.
            You can define several templates by passing a value to optional parameters. The appropriate template will be automatically selected according to
            the method to which the advice is applied. If several templates are eligible for a method, the template that is the last in the list of parameters is selected.
            </summary>
      <param name="defaultTemplate">Name of the template that must be applied if no other template is applicable. This parameter is required.</param>
      <param name="enumerableTemplate">Name of the template that must be applied to iterator methods returning an <see cref="T:System.Collections.Generic.IEnumerable`1" /> or <see cref="T:System.Collections.IEnumerable" />.
            See <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumerableTemplate" /> for details.</param>
      <param name="enumeratorTemplate">Name of the template that must be applied to an iterator method returning an an <see cref="T:System.Collections.Generic.IEnumerator`1" /> or <see cref="T:System.Collections.IEnumerator" />.
            See <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumeratorTemplate" /> for details.</param>
      <param name="useEnumerableTemplateForAnyEnumerable">Indicates whether the <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumerableTemplate" /> or <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.EnumeratorTemplate" />
            must be applied to all methods returning compatible return type (if set to <c>true</c>), instead of only to methods using the <c>yield</c> statement.
            See <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.UseEnumerableTemplateForAnyEnumerable" /> for details.</param>
      <remarks>
            Note that this type has also an implicit conversion from <see cref="T:System.String" />.
            If you only want to specify a default template, you can pass a string, without calling the constructor.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Advising.GetterTemplateSelector.op_Implicit(System.String)~Metalama.Framework.Advising.GetterTemplateSelector">
      <summary>
            Converts a <see cref="T:System.String" /> to a new instance of the <see cref="T:Metalama.Framework.Advising.GetterTemplateSelector" /> where the <see cref="P:Metalama.Framework.Advising.GetterTemplateSelector.DefaultTemplate" /> property is
            set to this string.
            </summary>
      <param name="defaultTemplate">Name of the default template.</param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Advising.IAddContractAdviceResult`1">
      <summary>
            Represents the result of the <see cref="M:Metalama.Framework.Advising.IAdviceFactory.AddContract(Metalama.Framework.Code.IParameter,System.String,Metalama.Framework.Aspects.ContractDirection,System.Object,System.Object)" />
            method.
            </summary>
      <typeparam name="T">
        <see cref="T:Metalama.Framework.Code.IParameter" /> or <see cref="T:Metalama.Framework.Code.IPropertyOrIndexer" />.</typeparam>
    </member>
    <member name="P:Metalama.Framework.Advising.IAddContractAdviceResult`1.Declaration">
      <summary>
            Gets the declaration to which the contract was added. When the contracted is added to a field, returns the <see cref="T:Metalama.Framework.Code.IProperty" />
            that the field has been transformed into.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IAddInitializerAdviceResult">
      <summary>
            Represents the result of the <see cref="M:Metalama.Framework.Advising.IAdviceFactory.AddInitializer(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Advising.InitializerKind,System.Object,System.Object)" />
            method.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IAdviceFactory">
      <summary>
            Exposes all factory methods to create advice. Exposed on the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder.Advice" /> property
            of <see cref="T:Metalama.Framework.Aspects.IAspectBuilder`1" /> or <see cref="T:Metalama.Framework.Aspects.IAspectBuilder" />.
            </summary>
      <seealso href="@advising-code" />
    </member>
    <member name="P:Metalama.Framework.Advising.IAdviceFactory.MutableCompilation">
      <summary>
            Gets the mutable compilation that the current aspect builder is working on. It includes all modifications done by
            the current aspect in the current type using declarative advices and the <see cref="T:Metalama.Framework.Advising.IAdviceFactory" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.Override(Metalama.Framework.Code.IMethod,Metalama.Framework.Advising.MethodTemplateSelector@,System.Object,System.Object)">
      <summary>
            Overrides the implementation of a method.
            </summary>
      <param name="targetMethod">The method to override.</param>
      <param name="template">Name of a method in the aspect class whose implementation will be used as a template.
                This property must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. To select a different templates according to the kind of target method
                (such as async or iterator methods), use the constructor of the <see cref="T:Metalama.Framework.Advising.MethodTemplateSelector" /> type. To specify a single
                template for all methods, pass a string.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template method.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-methods" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceMethod(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder},System.Object,System.Object)">
      <summary>
            Introduces a new method or overrides the implementation of the existing one.
            </summary>
      <param name="targetType">The type into which the method must be introduced.</param>
      <param name="template">Name of the method of the aspect class that will be used as a template for the introduced method. This method must be
                annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. This method can have parameters and a return type. The actual parameters and return type
                of the introduced method can be modified using the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> returned by this method.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                method. The default scope depends on the scope of the template method.
                If the method is static, the introduced method is static. However, if the template method is non-static, then the introduced method
                copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a method of the same name and signature is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildMethod"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> that allows to modify the name or signature, or to add custom attributes.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceFinalizer(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Aspects.OverrideStrategy,System.Object,System.Object)">
      <summary>
            Introduces a finalizer or overrides the implementation of the existing one.
            </summary>
      <param name="targetType">The type into which the finalizer must be introduced.</param>
      <param name="template">Name of the method of the aspect class that will be used as a template for the introduced finalizer. This method must be
                annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. This method can parameters and a return type.</param>
      <param name="whenExists">Determines the implementation strategy when a finalizer is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.Override(Metalama.Framework.Code.IConstructor,System.String,System.Object,System.Object)">
      <summary>
            Overrides the implementation of a constructor.
            </summary>
      <param name="targetConstructor">The constructor to override.</param>
      <param name="template">Name of a method in the aspect class whose implementation will be used as a template.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template method.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.Override(Metalama.Framework.Code.IFieldOrProperty,System.String,System.Object)">
      <summary>
            Overrides a field or property by specifying a property template.
            </summary>
      <param name="targetFieldOrProperty">The field or property to override.</param>
      <param name="template">The name of a property of the aspect class, with a getter, a setter, or both, whose implementation will be used as a template.
                This property must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template property and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-fields-or-properties" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.OverrideAccessors(Metalama.Framework.Code.IFieldOrPropertyOrIndexer,Metalama.Framework.Advising.GetterTemplateSelector@,System.String,System.Object,System.Object)">
      <summary>
            Overrides a field or property by specifying a method template for the getter, the setter, or both.
            </summary>
      <param name="targetFieldOrPropertyOrIndexer">The field or property to override.</param>
      <param name="getTemplate">The name of the method of the aspect class whose implementation will be used as a template for the getter, or <c>null</c>
                if the getter should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.
                To select a different templates for iterator getters, use the constructor of the <see cref="T:Metalama.Framework.Advising.GetterTemplateSelector" /> type. To specify a single
                template for all properties, pass a string.
            </param>
      <param name="setTemplate">The name of the method of the aspect class whose implementation will be used as a template for the getter, or <c>null</c>
                if the getter should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-fields-or-properties" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceField(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder},System.Object)">
      <summary>
            Introduces a field to the target type by specifying a template.
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="template">Name of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildField"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceField(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Code.IType,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder},System.Object)">
      <summary>
            Introduces a field to the target type by specifying a field name and <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="fieldName">Name of the introduced field.</param>
      <param name="fieldType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildField"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceField(Metalama.Framework.Code.INamedType,System.String,System.Type,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder},System.Object)">
      <summary>
            Introduces a field to the target type by specifying a field name and <see cref="T:System.Type" />.
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="fieldName">Name of the introduced field.</param>
      <param name="fieldType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildField"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAutomaticProperty(Metalama.Framework.Code.INamedType,System.String,System.Type,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces an auto-implemented property to the target type by specifying a property name and <see cref="T:System.Type" />.
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="propertyName">Name of the introduced field.</param>
      <param name="propertyType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAutomaticProperty(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Code.IType,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces an auto-implemented property to the target type by specifying a property name and <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="propertyName">Name of the introduced field.</param>
      <param name="propertyType">Type of the introduced field.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                field. The default scope is <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" />.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceProperty(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces a property to the target type, or overrides the implementation of an existing one, by specifying a property template.
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="template">The name of the property in the aspect class that will be used as a template for the new property.
                This property must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The type of this property can be either <c>dynamic</c> or any specific
                type. It is possible to dynamically change the type of the introduced property thanks to the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> returned by
                this method.
            </param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                property. The default scope depends on the scope of the template property. If the property is static, the introduced property is static. However, if the
                template property is non-static, then the introduced property copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags">An optional opaque object of anonymous type passed to the template property and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceProperty(Metalama.Framework.Code.INamedType,System.String,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object,System.Object)">
      <summary>
            Introduces a property to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            </summary>
      <param name="targetType">The type into which the property must be introduced.</param>
      <param name="name">Name of the introduced property.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced property should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced property should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                property. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced property is static. However, if the
                template accessors are non-static, then the introduced property copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceIndexer(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.IType,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            </summary>
      <param name="targetType">The type into which the indexer must be introduced.</param>
      <param name="indexType">The type of the initial index parameter.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceIndexer(Metalama.Framework.Code.INamedType,System.Type,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            </summary>
      <param name="targetType">The type into which the indexer must be introduced.</param>
      <param name="indexType">The type of the initial index parameter.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceIndexer(Metalama.Framework.Code.INamedType,System.Collections.Generic.IReadOnlyList{System.ValueTuple{Metalama.Framework.Code.IType,System.String}},System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            </summary>
      <param name="targetType">The type into which the indexer must be introduced.</param>
      <param name="indices">The types and names of the index parameters.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceIndexer(Metalama.Framework.Code.INamedType,System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Type,System.String}},System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            </summary>
      <param name="targetType">The type into which the indexer must be introduced.</param>
      <param name="indices">The types and names of the index parameters.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.OverrideAccessors(Metalama.Framework.Code.IEvent,System.String,System.String,System.String,System.Object,System.Object)">
      <summary>
            Overrides an event by specifying a template for the adder, the remover, and/or the raiser.
            </summary>
      <param name="targetEvent">The event to be overridden.</param>
      <param name="addTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the adder, or <c>null</c>
                the adder should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="removeTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the remover, or <c>null</c>
                the adder should not be overridden. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Remove(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="raiseTemplate">Not yet implemented.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <seealso href="@overriding-events" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceEvent(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IEventBuilder},System.Object)">
      <summary>
            Introduces a new event to the target type, or overrides the implementation of an existing one, by specifying an event template.
            </summary>
      <param name="targetType">The type into which the event must be introduced.</param>
      <param name="eventTemplate">The name of the event in the aspect class that must be used as a template for the introduced event. This event
                must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The type of the template event can be any delegate type. The type of the introduced event
                can be changed dynamically thanks to the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> returned by this method. 
            </param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                event. The default scope depends on the scope of the template event. If the event is static, the introduced event is static. However, if the
                template event is non-static, then the introduced event copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when an event of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildEvent"></param>
      <param name="tags">An optional opaque object of anonymous type passed to the template event and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> that allows to change the name and the type of the event.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceEvent(Metalama.Framework.Code.INamedType,System.String,System.String,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IEventBuilder},System.Object,System.Object)">
      <summary>
            Introduces a new event to the target type, or overrides the implementation of an existing one, by specifying individual template methods
            for the adder, the remover, and the raiser.
            </summary>
      <param name="targetType">The type into which the event must be introduced.</param>
      <param name="eventName">The name of the introduced event.</param>
      <param name="addTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the adder.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="removeTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the remover.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="raiseTemplate">Not implemented.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                event. The default scope depends on the scope of the template event. If the event is static, the introduced event is static. However, if the
                template event is non-static, then the introduced event copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when an event of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildEvent"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> that allows to change the name and the type of the event.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)">
      <summary>
            Makes a type implement a new interface specified as an <see cref="T:Metalama.Framework.Code.INamedType" />.
            Interface members can be introduced by marking an aspect member by <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" />, 
            <see cref="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAttribute(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.IAttributeData,Metalama.Framework.Aspects.OverrideStrategy)" /> or programmatically using <c>Introduce</c> methods.
            </summary>
      <param name="targetType">The type that must implement the new interface.</param>
      <param name="interfaceType">The type of the implemented interface.</param>
      <param name="whenExists">Determines the implementation strategy when the interface is already implemented by the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="tags">An optional opaque object of anonymous type passed to <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" /> templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API. This parameter does not affect members introduced using <see cref="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAttribute(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.IAttributeData,Metalama.Framework.Aspects.OverrideStrategy)" /> or programmatically.</param>
      <seealso href="@implementing-interfaces" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,System.Type,Metalama.Framework.Aspects.OverrideStrategy,System.Object)">
      <summary>
            Makes a type implement a new interface specified as a reflection <see cref="T:System.Type" />.
            Interface members can be introduced by marking an aspect member by <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" />, 
            <see cref="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAttribute(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.IAttributeData,Metalama.Framework.Aspects.OverrideStrategy)" /> or programmatically using <c>Introduce</c> methods.
            </summary>
      <param name="targetType">The type that must implement the new interface.</param>
      <param name="interfaceType">The type of the implemented interface.</param>
      <param name="whenExists">Determines the implementation strategy when the interface is already implemented by the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="tags">An optional opaque object of anonymous type passed to <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" /> templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API. This parameter does not affect members introduced using <see cref="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAttribute(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.IAttributeData,Metalama.Framework.Aspects.OverrideStrategy)" /> or programmatically.</param>
      <seealso href="@implementing-interfaces" />
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddInitializer(Metalama.Framework.Code.INamedType,System.String,Metalama.Framework.Advising.InitializerKind,System.Object,System.Object)">
      <summary>
            Adds a type or instance initializer by using a template. 
            </summary>
      <param name="targetType">The type into which the initializer should be added.</param>
      <param name="template">The name of the template. This method must have no run-time parameter, be of <c>void</c> return type, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="kind">The type of initializer to add.</param>
      <param name="tags">An optional opaque object of anonymous type passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddInitializer(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.SyntaxBuilders.IStatement,Metalama.Framework.Advising.InitializerKind)">
      <summary>
            Adds a type or instance initializer by specifying an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />. 
            </summary>
      <param name="targetType">The type into which the initializer should be added.</param>
      <param name="statement">The statement to be inserted at the top of constructors.</param>
      <param name="kind">The type of initializer to add.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddInitializer(Metalama.Framework.Code.IConstructor,System.String,System.Object,System.Object)">
      <summary>
            Adds an initializer to a specific constructor by using a template.
            </summary>
      <param name="targetConstructor">The constructor into which the initializer should be added.</param>
      <param name="template">The name of the template. This method must have no run-time parameter, be of <c>void</c> return type, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="tags">An optional opaque object of anonymous type  passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddInitializer(Metalama.Framework.Code.IConstructor,Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Adds an initializer to a specific constructor by specifying an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
      <param name="targetConstructor">The constructor into which the initializer should be added.</param>
      <param name="statement">The statement to be inserted at the top of the constructor.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddContract(Metalama.Framework.Code.IParameter,System.String,Metalama.Framework.Aspects.ContractDirection,System.Object,System.Object)">
      <summary>
            Adds a contract to a parameter. Contracts are usually used to validate parameters (pre- or post-conditions) or to normalize their value (null-to-empty, trimming, normalizing case, ...).
            </summary>
      <param name="targetParameter">The parameter to which the contract should be added.</param>
      <param name="template">The name of the template method. This method must have a single run-time parameter named <c>value</c>, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="direction">Direction of the data flow to which the contract should apply. See <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> for details.</param>
      <param name="tags">An optional opaque object of anonymous type passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddContract(Metalama.Framework.Code.IFieldOrPropertyOrIndexer,System.String,Metalama.Framework.Aspects.ContractDirection,System.Object,System.Object)">
      <summary>
            Adds a contract to a field, property or indexer. Contracts are usually used to validate the value assigned to fields properties or indexers or to normalize their value (null-to-empty, trimming, normalizing case, ...)
            before assignment. Alternatively, a contract can be used to validate the value <i>returned</i> by a property or indexer, in which case the <paramref name="direction" /> parameter should be set to <see cref="F:Metalama.Framework.Aspects.ContractDirection.Output" />.
            </summary>
      <param name="targetMember">The field, property or indexer to which the contract should be added.</param>
      <param name="template">The name of the template method. This method must have a single run-time parameter named <c>value</c>, and be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.</param>
      <param name="direction">Direction of the data flow to which the contract should apply. See <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> for details.</param>
      <param name="tags">An optional opaque object of anonymous type passed to templates and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.IntroduceAttribute(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.IAttributeData,Metalama.Framework.Aspects.OverrideStrategy)">
      <summary>
            Adds a custom attribute to a given declaration.
            </summary>
      <param name="targetDeclaration">The declaration to which the custom attribute should be added.</param>
      <param name="attribute">The custom attribute to be added. It can be an existing <see cref="T:Metalama.Framework.Code.IAttribute" />, or you can use <see cref="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction" />
                to specify a new attribute.</param>
      <param name="whenExists">Specifies the strategy to follow when an attribute of the same type already exists on the target declaration. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" /> will fail the
                compilation with an error and is the default strategy. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Ignore" /> will silently ignore the introduction. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Override" /> will remove
                all previous instances and replace them by the new one. <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.New" /> will add the new instance regardless.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.RemoveAttributes(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.INamedType)">
      <summary>
            Removes all custom attributes of a given <see cref="T:Metalama.Framework.Code.INamedType" /> from a given declaration.
            </summary>
      <param name="targetDeclaration">The declaration from which custom attributes have to be removed.</param>
      <param name="attributeType">The type of custom attributes to be removed.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.RemoveAttributes(Metalama.Framework.Code.IDeclaration,System.Type)">
      <summary>
            Removes all custom attributes of a given <see cref="T:System.Type" /> from a given declaration.
            </summary>
      <param name="targetDeclaration">The declaration from which custom attributes have to be removed.</param>
      <param name="attributeType">The type of custom attributes to be removed.</param>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.AddAnnotation``1(``0,Metalama.Framework.Code.IAnnotation{``0},System.Boolean)">
      <summary>
            Adds a custom annotation to a declaration. An annotation is an arbitrary but serializable object that can then be retrieved
            using the <see cref="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetAnnotations``1" /> method of the <see cref="M:Metalama.Framework.Code.DeclarationExtensions.Enhancements``1(``0)" /> object.
            Annotations are a way of communication between aspects or classes of aspects.
            </summary>
      <param name="declaration">The declaration to which the annotation should be added.</param>
      <param name="annotation">The annotation.</param>
      <param name="export">A value indicating whether the annotation should be exported and made visible to other projects.
            Unless this parameter is set to <c>true</c>, the annotation will only be visible to the current project.</param>
      <typeparam name="TDeclaration">The type of declaration.</typeparam>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.WithTemplateProvider(Metalama.Framework.Aspects.TemplateProvider)">
      <summary>
            Returns a copy of the current <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> that will use the specified object to find template methods.
            </summary>
      <param name="templateProvider">A <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />.</param>
      <returns>An <see cref="T:Metalama.Framework.Advising.IAdviceFactory" />.</returns>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviceFactory.WithTemplateProvider(Metalama.Framework.Aspects.ITemplateProvider)">
      <summary>
            Returns a copy of the current <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> that will use the specified object to find template methods.
            </summary>
      <param name="templateProvider">An <see cref="T:Metalama.Framework.Aspects.ITemplateProvider" />.</param>
      <returns>An <see cref="T:Metalama.Framework.Advising.IAdviceFactory" />.</returns>
    </member>
    <member name="T:Metalama.Framework.Advising.IAdviceResult">
      <summary>
            A base interface that represents the result of any advice method of the <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IAdviceResult.AdviceKind">
      <summary>
            Gets the kind of advice whose the current object is the result.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IAdviceResult.Outcome">
      <summary>
            Gets the advice outcome, i.e. indication whether the advice was applied, was ignored because the same declaration already exists (according to <see cref="T:Metalama.Framework.Aspects.OverrideStrategy" />),
            or an error for different reasons. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IAdviser">
      <summary>
            An object that allows declarations to be advised using one of the extension methods of the <see cref="T:Metalama.Framework.Advising.AdviserExtensions" /> class.
            This interface is the non-generic base one. All advisers implement the generic interface <see cref="T:Metalama.Framework.Advising.IAdviser`1" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IAdviser.Diagnostics">
      <summary>
            Gets a service that allows to report or suppress diagnostics.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IAdviser.Target">
      <summary>
            Gets the declaration that will be advised.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.IAdviser.With``1(``0)">
      <summary>
            Gets a new <see cref="T:Metalama.Framework.Advising.IAdviser" /> for a different <see cref="P:Metalama.Framework.Advising.IAdviser.Target" /> declaration.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IAdviser`1">
      <summary>
            An object that allows declarations to be advised using one of the extension methods of the <see cref="T:Metalama.Framework.Advising.AdviserExtensions" /> class.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IAdviser`1.Target">
      <summary>
            Gets the declaration that will be advised.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IImplementInterfaceAdviceResult">
      <summary>
            Represents the result of the <see cref="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)" />
            method. The result can be used to introduce interface members using the extension methods in <see cref="T:Metalama.Framework.Advising.AdviserExtensions" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IImplementInterfaceAdviceResult.Interfaces">
      <summary>
            Gets a list of interfaces that were considered when implementing the given interface.
            </summary>
      <remarks>
            This property contains an empty list if the advice was completely ignored.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Advising.IImplementInterfaceAdviceResult.InterfaceMembers">
      <summary>
            Gets a list of interface members specified using <see cref="T:Metalama.Framework.Aspects.InterfaceMemberAttribute" /> that were considered when implementing the given interface.
            </summary>
      <remarks>
            This property contains only members of interfaces that were implemented. Members of interfaces that were ignored are not included in the list.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Advising.IImplementInterfaceAdviceResult.ExplicitMembers">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Advising.IAdviser`1" /> allowing to introduce explicit members to the primary implemented interface.
            For introducing memebers to its base interfaces, use the <see cref="P:Metalama.Framework.Advising.IImplementInterfaceAdviceResult.Interfaces" /> property.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IInterfaceImplementationResult">
      <summary>
            Describes an interface type implemented by <see cref="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IInterfaceImplementationResult.InterfaceType">
      <summary>
            Gets an interface type that was considered by the advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IInterfaceImplementationResult.Outcome">
      <summary>
            Gets a value indicating the action taken to implement the interface type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IInterfaceMemberImplementationResult">
      <summary>
            Describes an interface member implemented by <see cref="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IInterfaceMemberImplementationResult.InterfaceMember">
      <summary>
            Gets an interface member that was implemented.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IInterfaceMemberImplementationResult.Outcome">
      <summary>
            Gets a value indicating the action taken to implement the interface member.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IInterfaceMemberImplementationResult.TargetMember">
      <summary>
            Gets the member used to implement the interface. This may be either an existing member or a newly introduced member.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IIntroductionAdviceResult`1">
      <summary>
            Represents the result of the <c>Introduce*</c> methods of the <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IIntroductionAdviceResult`1.Declaration">
      <summary>
            Gets the introduced or overridden declaration. This returns the same value as the <see cref="P:Metalama.Framework.Advising.IAdviser`1.Target" />
            property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IIntroductionAdviceResult`1.ConflictingDeclaration">
      <summary>
            Gets the declaration that was in conflict, if the outcome is <see cref="F:Metalama.Framework.Advising.AdviceOutcome.Error" />. The member may be of a different kind that <see cref="P:Metalama.Framework.Advising.IIntroductionAdviceResult`1.Declaration" />. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.BeforeInstanceConstructor">
      <summary>
            Indicates that the advice should be executed before any user code in all instance constructors except those that are chained to a constructor of the current class (using the <c>this</c> chaining keyword). The initialization logic executes
            after the call to the base constructor.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.BeforeTypeConstructor">
      <summary>
            Indicates that the advice should be executed before the type constructor (aka static constructor) of the target type. If there is no type constructor, this advice adds one.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.AfterLastInstanceConstructor">
      <summary>
            Indicates that the advice should be executed after all constructors are finished but before the initialization block.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.AfterObjectInitialization">
      <summary>
            Indicates that the advice should be executed after all constructors are finished and after the initialization block.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.AfterDeserialize">
      <summary>
            Indicates that the advice should be executed when the instance of a target class is deserialized.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.AfterMemberwiseClone">
      <summary>
            Indicates that the advice should be executed when the instance of a target class is cloned.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InitializerKind.AfterWith">
      <summary>
            Indicated that the advice should be executed when the the target value type is mutated using the "with" expression.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions">
      <summary>
            Provides extension methods for the <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceProperty(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object)">
      <summary>
            Introduces a property to the target type, or overrides the implementation of an existing one, by specifying a property template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="template">The name of the property in the aspect class that will be used as a template for the new property.
                This property must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The type of this property can be either <c>dynamic</c> or any specific
                type. It is possible to dynamically change the type of the introduced property thanks to the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> returned by
                this method.
            </param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                property. The default scope depends on the scope of the template property. If the property is static, the introduced property is static. However, if the
                template property is non-static, then the introduced property copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="tags">An optional opaque object of anonymous type passed to the template property and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceProperty(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.String,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder},System.Object,System.Object)">
      <summary>
            Introduces a property to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="name">Name of the introduced property.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced property should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced property should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the field or property.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                property. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced property is static. However, if the
                template accessors are non-static, then the introduced property copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a property of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildProperty"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> that allows to dynamically change the name or type of the introduced property.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IInterfaceImplementationAdviser,Metalama.Framework.Code.IType,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="indexType">The type of the initial index parameter.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.Type,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="indexType">The type of the initial index parameter.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.Collections.Generic.IReadOnlyList{System.ValueTuple{Metalama.Framework.Code.IType,System.String}},System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="indices">The types and names of the index parameters.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceIndexer(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Type,System.String}},System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder},System.Object,System.Object)">
      <summary>
            Introduces an indexer to the target type, or overrides the implementation of an existing one, by specifying individual template methods for each accessor. 
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="indices">The types and names of the index parameters.</param>
      <param name="getTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                the introduced indexer should not have a getter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>T Get()</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="setTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the getter, or <c>null</c>
                if the introduced indexer should not have a setter. This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Set(T value</c>  where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the indexer.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                indexer. The default scope depends on the scope of the template accessors. If the accessors are static, the introduced indexer is static. However, if the
                template accessors are non-static, then the introduced indexer copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a indexer of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildIndexer"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" /> that allows to dynamically change the name or type of the introduced indexer.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceEvent(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IEventBuilder},System.Object)">
      <summary>
            Introduces a new event to the target type, or overrides the implementation of an existing one, by specifying an event template.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="eventTemplate">The name of the event in the aspect class that must be used as a template for the introduced event. This event
                must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The type of the template event can be any delegate type. The type of the introduced event
                can be changed dynamically thanks to the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> returned by this method. 
            </param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                event. The default scope depends on the scope of the template event. If the event is static, the introduced event is static. However, if the
                template event is non-static, then the introduced event copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when an event of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildEvent"></param>
      <param name="tags">An optional opaque object of anonymous type passed to the template event and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> that allows to change the name and the type of the event.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceEvent(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.String,System.String,System.String,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IEventBuilder},System.Object,System.Object)">
      <summary>
            Introduces a new event to the target type, or overrides the implementation of an existing one, by specifying individual template methods
            for the adder, the remover, and the raiser.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="eventName">The name of the introduced event.</param>
      <param name="addTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the adder.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="removeTemplate">The name of the method of the aspect class whose type and implementation will be used as a template for the remover.
                This method must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. The signature of this method must
                be <c>void Add(T value)</c> where <c>T</c> is either <c>dynamic</c> or a type compatible with the type of the event.</param>
      <param name="raiseTemplate">Not implemented.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                event. The default scope depends on the scope of the template event. If the event is static, the introduced event is static. However, if the
                template event is non-static, then the introduced event copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when an event of the same name is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildEvent"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property of the
                <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder" /> that allows to change the name and the type of the event.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="M:Metalama.Framework.Advising.InterfaceImplementationAdviserExtensions.IntroduceMethod(Metalama.Framework.Advising.IInterfaceImplementationAdviser,System.String,Metalama.Framework.Aspects.IntroductionScope,Metalama.Framework.Aspects.OverrideStrategy,System.Action{Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder},System.Object,System.Object)">
      <summary>
            Introduces a new method or overrides the implementation of the existing one.
            Use the <see cref="M:Metalama.Framework.Advising.IAdviser.With``1(``0)" /> method to apply the advice to another declaration than the current one.
            </summary>
      <param name="adviser">An <see cref="T:Metalama.Framework.Advising.IInterfaceImplementationAdviser" />.</param>
      <param name="template">Name of the method of the aspect class that will be used as a template for the introduced method. This method must be
                annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />. This method can have parameters and a return type. The actual parameters and return type
                of the introduced method can be modified using the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> returned by this method.</param>
      <param name="scope">Determines the scope (e.g. <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Instance" /> or <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />) of the introduced
                method. The default scope depends on the scope of the template method.
                If the method is static, the introduced method is static. However, if the template method is non-static, then the introduced method
                copies of the scope of the target declaration of the aspect.</param>
      <param name="whenExists">Determines the implementation strategy when a method of the same name and signature is already declared in the target type.
                The default strategy is to fail with a compile-time error.</param>
      <param name="buildMethod"></param>
      <param name="args">An object (typically of anonymous type) whose properties map to parameters or type parameters of the template methods.</param>
      <param name="tags">An optional opaque object of anonymous type passed to the template method and exposed under the <see cref="P:Metalama.Framework.Aspects.meta.Tags" /> property
                of the <see cref="T:Metalama.Framework.Aspects.meta" /> API.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> that allows to modify the name or signature, or to add custom attributes.</returns>
      <seealso href="@introducing-members" />
    </member>
    <member name="T:Metalama.Framework.Advising.InterfaceImplementationOutcome">
      <summary>
            Actions taken by the advice when implementing an interface.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InterfaceImplementationOutcome.Implement">
      <summary>
            The interface was implemented. Individual members of this interface will appear in <see cref="P:Metalama.Framework.Advising.IImplementInterfaceAdviceResult.InterfaceMembers" /> collection.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InterfaceImplementationOutcome.Ignore">
      <summary>
            The interface type was ignored. Members will not appear in <see cref="P:Metalama.Framework.Advising.IImplementInterfaceAdviceResult.InterfaceMembers" /> collection.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.InterfaceMemberImplementationOutcome">
      <summary>
            Actions taken by the advice when implementing an interface member.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InterfaceMemberImplementationOutcome.Introduce">
      <summary>
            Interface member was introduced as a new declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InterfaceMemberImplementationOutcome.Override">
      <summary>
            The interface member template was used to override an existing declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Advising.InterfaceMemberImplementationOutcome.UseExisting">
      <summary>
            An existing class member was used for to implement the interface member.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IOverrideAdviceResult`1">
      <summary>
            Represents the result of the <c>Override</c> methods of the <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.IOverrideAdviceResult`1.Declaration">
      <summary>
            Gets the declaration transformed by the advice method. For advice that modify a field,
            this is the property that now represents the field.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.IRemoveAttributesAdviceResult">
      <summary>
            Represents the result of the <see cref="M:Metalama.Framework.Advising.IAdviceFactory.RemoveAttributes(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.INamedType)" /> method.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Advising.MethodTemplateSelector">
      <summary>
            Specifies the templates that must be used by the <c>IAdviceFactory.Override(IMethod)</c> advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.DefaultTemplate">
      <summary>
            Gets the name of the template that must be applied if no other template is applicable. This property is required.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncTemplate">
      <summary>
            Gets the name of the template that must be applied to async methods, including async iterators (unless <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumerableTemplate" />
            or <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumeratorTemplate" /> is defined).
            If <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseAsyncTemplateForAnyAwaitable" /> is set to <c>true</c>, this template will be used for any method that has an awaitable return type,
            including <c>IAsyncEnumerable</c> and
            <c>IAsyncEnumerator</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumerableTemplate">
      <summary>
            Gets the name of the template that must be applied to yield-based iterator methods returning an <see cref="T:System.Collections.Generic.IEnumerable`1" /> or <see cref="T:System.Collections.IEnumerable" />.
            If the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseEnumerableTemplateForAnyEnumerable" /> is set to <c>true</c>, this template will be used for
            any method that returns the <see cref="T:System.Collections.Generic.IEnumerable`1" /> or <see cref="T:System.Collections.IEnumerable" /> type, even if it not a yield-based iterator. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumeratorTemplate">
      <summary>
            Gets the name of the template that must be applied to yield-based iterator methods returning an <see cref="T:System.Collections.Generic.IEnumerator`1" /> or <see cref="T:System.Collections.IEnumerator" />.
            If the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseEnumerableTemplateForAnyEnumerable" /> is set to <c>true</c>, this template will be used for
            any method that returns the <see cref="T:System.Collections.Generic.IEnumerator`1" /> or <see cref="T:System.Collections.IEnumerator" /> type, even if it not a yield-based iterator. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumerableTemplate">
      <summary>
            Gets the name of the template that must be applied to an async iterator method returning the <c>IAsyncEnumerable</c> type.
            If the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseEnumerableTemplateForAnyEnumerable" /> is set to <c>true</c>, this template will be used for
            any method that returns the <c>IAsyncEnumerable</c> type, even if it is not implemented as an async or yield-based iterator.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumeratorTemplate">
      <summary>
            Gets the name of the template that must be applied to an async iterator method returning the <c>IAsyncEnumerable</c> type.
            If the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseEnumerableTemplateForAnyEnumerable" /> is set to <c>true</c>, this template will be used for
            any method that returns the <c>IAsyncEnumerable</c> type, even if it is not implemented as an async or yield-based iterator.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.UseAsyncTemplateForAnyAwaitable">
      <summary>
            Gets a value indicating whether the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncTemplate" /> must be applied to all methods returning an awaitable type (including <c>IAsyncEnumerable</c>
            and <c>IAsyncEnumerator</c>) instead of only to methods that have the <c>async</c> modifier. If the implementation of the template method is async,
            the awaitable type must also have an async method builder, otherwise the method will be processed by <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.DefaultTemplate" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.MethodTemplateSelector.UseEnumerableTemplateForAnyEnumerable">
      <summary>
            Gets a value indicating whether the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumerableTemplate" />, <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumeratorTemplate" />, <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumerableTemplate" />,
            <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumeratorTemplate" /> must be applied to all methods returning a compatible return type (if set to <c>true</c>),
            instead of only to methods using the <c>yield</c> statement.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.MethodTemplateSelector.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Advising.MethodTemplateSelector" /> struct by specifying the name of the template methods to be applied. The named passed to this
            constructor must be the name of methods of the current aspect class, and these methods must be annotated with the <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" /> custom attribute.
            You can define several templates by passing a value to optional parameters. The appropriate template will be automatically selected according to
            the method to which the advice is applied. If several templates are eligible for a method, the template that is the last in the list of parameters is selected.
            </summary>
      <param name="defaultTemplate">Name of the template that must be applied if no other template is applicable. This parameter is required.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.DefaultTemplate" /> for details.</param>
      <param name="asyncTemplate">Name of the template that must be applied to async methods, including async iterators unless specified otherwise.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncTemplate" /> for details.</param>
      <param name="enumerableTemplate">Name of the template that must be applied to iterator methods  returning an an <see cref="T:System.Collections.Generic.IEnumerable`1" /> or <see cref="T:System.Collections.IEnumerable" />.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumerableTemplate" /> for details.</param>
      <param name="enumeratorTemplate">Name of the template that must be applied to an iterator method returning an an <see cref="T:System.Collections.Generic.IEnumerator`1" /> or <see cref="T:System.Collections.IEnumerator" />.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumeratorTemplate" /> for details.</param>
      <param name="asyncEnumerableTemplate">Name of the template that must be applied to an async iterator method returning an <c>IAsyncEnumerable</c>.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumerableTemplate" /> for details.
            </param>
      <param name="asyncEnumeratorTemplate">Name of the template that must be applied to an async iterator method returning an <c>IAsyncEnumerator</c>.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumeratorTemplate" /> for details.</param>
      <param name="useAsyncTemplateForAnyAwaitable">Indicates whether the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncTemplate" /> must be applied to all methods returning an awaitable
            type (including <c>IAsyncEnumerable</c> and <c>IAsyncEnumerator</c>), instead of only to methods that have the <c>async</c> modifier.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseAsyncTemplateForAnyAwaitable" /> for details.  
            </param>
      <param name="useEnumerableTemplateForAnyEnumerable">Indicates whether the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumerableTemplate" />, <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.EnumeratorTemplate" />, <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumerableTemplate" />,
            <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.AsyncEnumeratorTemplate" /> must be applied to all methods returning a compatible return type (if set to <c>true</c>),
            instead of only to methods using the <c>yield</c> statement.
            See <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.UseEnumerableTemplateForAnyEnumerable" /> for details.
            </param>
      <remarks>
            Note that this type has also an implicit conversion from <see cref="T:System.String" />.
            If you only want to specify a default template, you can pass a string, without calling the constructor.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Advising.MethodTemplateSelector.op_Implicit(System.String)~Metalama.Framework.Advising.MethodTemplateSelector">
      <summary>
            Converts a <see cref="T:System.String" /> to a new instance of the <see cref="T:Metalama.Framework.Advising.MethodTemplateSelector" /> where the <see cref="P:Metalama.Framework.Advising.MethodTemplateSelector.DefaultTemplate" /> property is
            set to this string.
            </summary>
      <param name="defaultTemplate">Name of the default template.</param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Advising.PullAction">
      <summary>
            Represents a way to pull a field or property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Advising.PullAction.None">
      <summary>
            Gets a <see cref="T:Metalama.Framework.Advising.PullAction" /> that means that the dependency has to be set to its default value.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.PullAction.UseExistingParameter(Metalama.Framework.Code.IParameter)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Advising.PullAction" /> that means that the dependency should be pulled from an existing constructor parameter.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Advising.PullAction.UseExpression(Metalama.Framework.Code.IExpression)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Advising.PullAction" /> that means that the dependency should be assigned to a given expression.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.Aspect">
      <summary>
            A base class from aspects that can be applied as custom attributes. Aspects must implement a specific generic instance
            of the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface, or derive from <see cref="T:Metalama.Framework.Aspects.TypeAspect" />, <see cref="T:Metalama.Framework.Aspects.MethodAspect" />,
            <see cref="T:Metalama.Framework.Aspects.ConstructorAspect" />, <see cref="T:Metalama.Framework.Aspects.FieldOrPropertyAspect" />, <see cref="T:Metalama.Framework.Aspects.EventAspect" /> or <see cref="T:Metalama.Framework.Aspects.CompilationAspect" />.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Aspects.AspectOrderAttribute">
      <summary>
            Custom attribute that specifies the order  of execution of aspects or aspect layers.
            </summary>
      <seealso href="@ordering-aspects" />
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectOrderAttribute.#ctor(Metalama.Framework.Aspects.AspectOrderDirection,System.Type[])">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Aspects.AspectOrderAttribute" /> class that specifies the order of execution
            of aspects. This constructor does not allow multi-layer aspects to overlap each other. If aspects are composed
            of several layers, all layers of each aspect are ordered as a single group. To order layers individually, use
            the other constructor.
            </summary>
      <param name="direction">The direction in which the aspect types are supplied. <see cref="F:Metalama.Framework.Aspects.AspectOrderDirection.RunTime" />
            means that the <paramref name="orderedAspectTypes" /> parameter specifies the run-time execution order, which is more intuitive to aspect users.
            <see cref="F:Metalama.Framework.Aspects.AspectOrderDirection.CompileTime" /> means that the compile-time execution order is supplied, which is intuitive to aspect authors.
            </param>
      <param name="orderedAspectTypes">A list of aspect types given the desired order of execution.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectOrderAttribute.#ctor(Metalama.Framework.Aspects.AspectOrderDirection,System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Aspects.AspectOrderAttribute" /> class that specified the order of execution
            of aspect layers. This constructor allows to specify the order of execution of individual layers.
            </summary>
      <param name="direction">The direction in which the aspect types are supplied. <see cref="F:Metalama.Framework.Aspects.AspectOrderDirection.RunTime" />
            means that the <paramref name="orderedAspectLayers" /> parameter specifies the run-time execution order, which is more intuitive to aspect users.
            <see cref="F:Metalama.Framework.Aspects.AspectOrderDirection.CompileTime" /> means that the compile-time execution order is supplied, which is intuitive to aspect authors.
            </param>
      <param name="orderedAspectLayers">A list of layer names composed of the full name of the aspect type and the name
            of the aspect layer. The following formats are allowed: <c>MyNamespace.MyAspectType</c> to match the default layer,
            <c>MyNamespace.MyAspectType:MyLayer</c> to match a non-default layer, or <c>MyNamespace.MyAspectType:*</c> to match
            all layers of an aspect.
            </param>
    </member>
    <member name="P:Metalama.Framework.Aspects.AspectOrderAttribute.OrderedAspectLayers">
      <summary>
            Gets the ordered list of aspect layers, in the format specified the constructor documentation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.AspectOrderAttribute.ApplyToDerivedTypes">
      <summary>
            Gets or sets a value indicating whether the relationships should apply to derived aspect types. The default value
            is <c>true</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.AspectOrderDirection">
      <summary>
            Specifies the order in which the aspect types or aspect layers are supplied to  <see cref="T:Metalama.Framework.Aspects.AspectOrderAttribute" />. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectOrderDirection.RunTime">
      <summary>
            Means that the <see cref="T:Metalama.Framework.Aspects.AspectOrderAttribute" />'s parameter specifies the run-time execution order, which is more intuitive to aspect users.
            Prior to Metalama 2024.2, this value was the only possible one.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectOrderDirection.CompileTime">
      <summary>
            Means that the <see cref="T:Metalama.Framework.Aspects.AspectOrderAttribute" />'s parameter specifies the compile-time execution order (i.e. the order in which
            the aspects are executed in Metalama), which is intuitive to aspect authors.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.AspectPredecessor">
      <summary>
            Represents the relationship that an object (attribute, fabric, aspect) has created or required another aspect or validator.
            These relationships are exposed on <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.Predecessors" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.AspectPredecessor.Kind">
      <summary>
            Gets the kind of relationship represented by the current <see cref="T:Metalama.Framework.Aspects.AspectPredecessor" />, and the kind of object
            present in the <see cref="P:Metalama.Framework.Aspects.AspectPredecessor.Instance" /> property. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.AspectPredecessor.Instance">
      <summary>
            Gets the object that created the aspect instance. It can be an <see cref="T:Metalama.Framework.Aspects.IAspectInstance" />, an <see cref="T:Metalama.Framework.Fabrics.IFabricInstance" />, or an <see cref="T:Metalama.Framework.Code.IAttribute" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.AspectPredecessorExtensions">
      <summary>
            Extension methods for <see cref="T:Metalama.Framework.Aspects.IAspectPredecessor" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectPredecessorExtensions.GetRoots(Metalama.Framework.Aspects.IAspectPredecessor)">
      <summary>
            Gets the roots of the predecessor tree. A root is a predecessor that does not itself have a predecessor.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.AspectPredecessorKind">
      <summary>
            Kinds of <see cref="T:Metalama.Framework.Aspects.AspectPredecessor" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectPredecessorKind.Attribute">
      <summary>
            The aspect has been created by a custom attribute. <see cref="P:Metalama.Framework.Aspects.AspectPredecessor.Instance" /> is an <see cref="T:Metalama.Framework.Code.IAttribute" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectPredecessorKind.ChildAspect">
      <summary>
            The aspect has been created by another aspect. <see cref="P:Metalama.Framework.Aspects.AspectPredecessor.Instance" /> is an <see cref="T:Metalama.Framework.Aspects.IAspect" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectPredecessorKind.RequiredAspect">
      <summary>
            The aspect has been required by another aspect using <see cref="M:Metalama.Framework.Advising.AdviserExtensions.RequireAspect(Metalama.Framework.Advising.IAdviser,System.Type)" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectPredecessorKind.Inherited">
      <summary>
            Aspects added because of aspect inheritance.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectPredecessorKind.Fabric">
      <summary>
            The aspect has been created by a fabric. <see cref="P:Metalama.Framework.Aspects.AspectPredecessor.Instance" /> is an <see cref="T:Metalama.Framework.Fabrics.Fabric" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.AspectPredecessorKind.Interactive">
      <summary>
            The aspect has been applied interactively by the user, e.g. as a live template.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspect``1(Metalama.Framework.Fabrics.IQuery{``0},System.Type,System.Func{``0,Metalama.Framework.Aspects.IAspect})">
      <summary>
            Adds a aspect to the current set of declarations or throws an exception if the aspect is not eligible for the aspect. This overload is non-generic.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="aspectType">The exact type of the aspect returned by <paramref name="createAspect" />. It is not allowed to specify a base type in this parameter, only the exact type.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspectIfEligible``1(Metalama.Framework.Fabrics.IQuery{``0},System.Type,System.Func{``0,Metalama.Framework.Aspects.IAspect},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Adds an aspect to the current set of declarations but only if the aspect is eligible for the declaration. This overload is non-generic.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="aspectType">The exact type of the aspect returned by <paramref name="createAspect" />. It is not allowed to specify a base type in this parameter, only the exact type.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
      <param name="eligibility">The scenarios for which the aspect may be eligible. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" /> | <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance" />.
            If <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.None" /> is provided, eligibility is not checked.
            </param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspect``2(Metalama.Framework.Fabrics.IQuery{``0},System.Func{``0,``1})">
      <summary>
            Adds an aspect to the current set of declarations or throws an exception if the aspect is not eligible for the aspect.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspectIfEligible``2(Metalama.Framework.Fabrics.IQuery{``0},System.Func{``0,``1},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Adds an aspect to the current set of declarations but only if the aspect is eligible for the declaration. 
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
      <param name="eligibility">The scenarios for which the aspect may be eligible. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" /> | <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance" />.
            If <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.None" /> is provided, eligibility is not checked.
            </param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspect``1(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.IDeclaration})">
      <summary>
            Adds an aspect to the current set of declarations or throws an exception if the aspect is not eligible for the aspect. This overload creates a new instance of the
            aspect class for each target declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspectIfEligible``1(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.IDeclaration},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Adds an aspect to the current set of declarations using the default constructor of the aspect type. This method
            does not verify the eligibility of the declaration for the aspect unless you specify the <paramref name="eligibility" /> parameter.
            This overload creates a new instance of the aspect class for each eligible target declaration.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="eligibility">The scenarios for which the aspect may be eligible. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" /> | <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance" />.
            If <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.None" /> is provided, eligibility is not checked.
            </param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.RequireAspect``1(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.IDeclaration})">
      <summary>
            Requires an instance of a specified aspect type to be present on a specified declaration. If the aspect
            is not present, this method adds a new instance of the aspect by using the default aspect constructor. 
            </summary>
      <remarks>
        <para>Calling this method causes the current aspect to be present in the <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.Predecessors" /> list
            even if the required aspect was already present on the target declaration.</para>
      </remarks>
      <typeparam name="TAspect">Type of the aspect. The type must be ordered after the aspect type calling this method.</typeparam>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspect``2(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Type,System.Func{``0,``1,Metalama.Framework.Aspects.IAspect})">
      <summary>
            Adds a aspect to the current set of declarations or throws an exception if the aspect is not eligible for the aspect. This overload is non-generic.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="aspectType">The exact type of the aspect returned by <paramref name="createAspect" />. It is not allowed to specify a base type in this parameter, only the exact type.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspectIfEligible``2(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Type,System.Func{``0,``1,Metalama.Framework.Aspects.IAspect},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Adds an aspect to the current set of declarations but only if the aspect is eligible for the declaration. This overload is non-generic.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="aspectType">The exact type of the aspect returned by <paramref name="createAspect" />. It is not allowed to specify a base type in this parameter, only the exact type.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
      <param name="eligibility">The scenarios for which the aspect may be eligible. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" /> | <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance" />.
            If <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.None" /> is provided, eligibility is not checked.
            </param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspect``3(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Func{``0,``1,``2})">
      <summary>
            Adds an aspect to the current set of declarations or throws an exception if the aspect is not eligible for the aspect.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.AspectQueryExtensions.AddAspectIfEligible``3(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Func{``0,``1,``2},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Adds an aspect to the current set of declarations but only if the aspect is eligible for the declaration. 
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="createAspect">A function that returns the aspect for a given declaration.</param>
      <param name="eligibility">The scenarios for which the aspect may be eligible. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" /> | <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance" />.
            If <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.None" /> is provided, eligibility is not checked.
            </param>
    </member>
    <member name="T:Metalama.Framework.Aspects.CompilationAspect">
      <summary>
            A base class for aspects that can be applied the compilation as custom attributes (using the <c>[assembly: MyAspect]</c> syntax).
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.CompilationAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.ICompilation})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.CompilationAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.ICompilation})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.CompiledTemplateAttribute">
      <summary>
            This custom attribute is internal to the Metalama infrastructure and should not be used in user code.
            It is added by Metalama when an aspect is compile to store the original characteristics of the template because some are
            changed during compilation.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.CompileTimeAttribute">
      <summary>
            Attribute that means that the target declaration (and all children declarations) can only be called from compile-time
            code and, therefore, not from run-time code. See <see cref="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute" /> for declarations
            that can be called both from compile-time and run-time code.
            </summary>
      <param name="isTemplateOnly">Indicates whether the target declaration can only be used from templates, but not from other compile-time code.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.CompileTimeAttribute.#ctor(System.Boolean,System.String)">
      <summary>
            Attribute that means that the target declaration (and all children declarations) can only be called from compile-time
            code and, therefore, not from run-time code. See <see cref="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute" /> for declarations
            that can be called both from compile-time and run-time code.
            </summary>
      <param name="isTemplateOnly">Indicates whether the target declaration can only be used from templates, but not from other compile-time code.</param>
    </member>
    <member name="P:Metalama.Framework.Aspects.CompileTimeAttribute.IsTemplateOnly">
      <summary>
            Gets a value indicating whether the target declaration can only be used from templates, but not from other compile-time code.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.ConstructorAspect">
      <summary>
            A base class for aspects that can be applied to constructors as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.ConstructorAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IConstructor})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.ConstructorAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IConstructor})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.ContractAspect">
      <summary>
            A base aspect that can validate or change the value of fields, properties, indexers, and parameters.
            </summary>
      <remarks>
        <para>A contract aspect can apply to the input or output data flow, or to both data flows, according to the <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> value
            passed to the constructor. Since the current class does not know the value of this parameter before it is instantiated, this class cannot
            set the eligibility conditions using the <see cref="M:Metalama.Framework.Aspects.ContractAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer})" /> method.
            If a derived class targets a specific <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> (i.e. if the choice is not left to the user),
            its implementation of <see cref="M:Metalama.Framework.Aspects.ContractAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer})" />
            can call <see cref="M:Metalama.Framework.Aspects.ContractAspect.BuildEligibilityForDirection(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer},Metalama.Framework.Aspects.ContractDirection)" />
            methods. This means that eligibility can be checked upfront by the IDE before suggesting the code actions.
            </para>
        <para>
            In any case, this aspect verifies the eligibility of the target with respect to the specific <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> and target declaration. This verification
            cannot be skipped.
            </para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.ContractAspect.#ctor(Metalama.Framework.Aspects.ContractDirection)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Aspects.ContractAspect" /> class.
            </summary>
      <param name="direction">The direction of the data flow (<see cref="F:Metalama.Framework.Aspects.ContractDirection.Input" />,  <see cref="F:Metalama.Framework.Aspects.ContractDirection.Output" /> or <see cref="F:Metalama.Framework.Aspects.ContractDirection.Both" />)
            to which this contract applies. See the <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> for details.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.ContractAspect.GetDefinedDirection(Metalama.Framework.Aspects.IAspectBuilder)">
      <summary>
            Gets or sets the direction of the data flow (<see cref="F:Metalama.Framework.Aspects.ContractDirection.Input" />,  <see cref="F:Metalama.Framework.Aspects.ContractDirection.Output" /> or <see cref="F:Metalama.Framework.Aspects.ContractDirection.Both" />)
            to which this contract applies, as defined by the current aspect. This method returns <see cref="F:Metalama.Framework.Aspects.ContractDirection.Default" /> by default. When this method returns <see cref="F:Metalama.Framework.Aspects.ContractDirection.Default" />,
            the actual direction is determined according to the characteristics of the target declaration.
            </summary>
      <remarks>
            In general, it is the responsibility of the <i>author</i> of the aspect, and not of its <i>user</i>, to define the eligible directions of a contract.
            However, the aspect's author can opt to allow users to define the contract direction by exposing this property as <c>public</c> in derived classes.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.ContractAspect.GetActualDirection(Metalama.Framework.Aspects.IAspectBuilder,Metalama.Framework.Aspects.ContractDirection)">
      <summary>
            Gets the actual direction of the contract given the direction returned by <see cref="M:Metalama.Framework.Aspects.ContractAspect.GetDefinedDirection(Metalama.Framework.Aspects.IAspectBuilder)" />, after resolving the <see cref="F:Metalama.Framework.Aspects.ContractDirection.Default" />
            value according to the characteristics of the target declaration, and after taking predecessors and secondary instances into account. The implementation of this method
            may return <see cref="F:Metalama.Framework.Aspects.ContractDirection.None" /> to skip the aspect.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.ContractAspect.BuildEligibilityForDirection(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer},Metalama.Framework.Aspects.ContractDirection)">
      <summary>
            Populates the <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for a field, property or indexer when the <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> is known.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.ContractAspect.BuildEligibilityForDirection(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter},Metalama.Framework.Aspects.ContractDirection)">
      <summary>
            Populates the <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for a parameter when the <see cref="T:Metalama.Framework.Aspects.ContractDirection" /> is known.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.ContractAspect.RedirectContracts(Metalama.Framework.Aspects.IAspectBuilder,Metalama.Framework.Code.IFieldOrPropertyOrIndexer,Metalama.Framework.Code.IParameter)">
      <summary>
            Redirects validation logic of <see cref="T:Metalama.Framework.Aspects.ContractAspect" /> from the specified property to the specified parameter.
            </summary>
      <param name="aspectBuilder">Current aspect builder.</param>
      <param name="sourceTarget">A declaration to redirect the validation logic from.</param>
      <param name="targetParameter">A parameter to redirect the validation logic to.</param>
      <remarks>
        <para>
            This call will only redirect validation logic of contracts applied after the current aspect. 
            Contracts applied before the current aspect will not be affected.
            </para>
        <para>
            If an aspect needs to see the contract aspect instances and redirect their validation logic at the same time, 
            it should be applied after the default layer of <see cref="T:Metalama.Framework.Aspects.ContractAspect" /> and before the layer that applies the contract logic, i.e. <see cref="F:Metalama.Framework.Aspects.ContractAspect.BuildLayer" />.
            </para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Aspects.ContractDirection">
      <summary>
            Directions of the data flow to which the contract applies.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.ContractDirection.None">
      <summary>
            Means that the contract is disabled.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.ContractDirection.Default">
      <summary>
            For all parameters except <c>out</c> parameters and read-only properties or indexers, equivalent to <see cref="F:Metalama.Framework.Aspects.ContractDirection.Input" />. Otherwise, equivalent to <see cref="F:Metalama.Framework.Aspects.ContractDirection.Output" />. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.ContractDirection.Input">
      <summary>
            Validates the input value of the parameter (before execution of the method) or the value assigned to the field, property or indexer (before the actual assignment).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.ContractDirection.Output">
      <summary>
            Validates the output value of an <c>out</c> or <c>ref</c> parameter or the value (after execution of the method), the value returned by the
            property or indexer getter, or the value assigned to the field at the moment when the field is retrieved.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.ContractDirection.Both">
      <summary>
            Both <see cref="F:Metalama.Framework.Aspects.ContractDirection.Input" /> and <see cref="F:Metalama.Framework.Aspects.ContractDirection.Output" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.DeclarativeAdviceAttribute">
      <summary>
            A base class for attributes that define declarative advice members. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.DeclarativeAdviceAttribute.Layer">
      <summary>
            Gets or sets the name of the aspect layer into which the member will be introduced. The layer must have been defined
            using the <see cref="T:Metalama.Framework.Aspects.LayersAttribute" /> custom attribute.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.DeclarativeAdviceAttribute.BuildAspectEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IDeclaration},Metalama.Framework.Code.IMemberOrNamedType)">
      <summary>
            Builds the eligibility of an aspect that contains the current declarative advice.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.DeclarativeAdviceAttribute.BuildAdvice(Metalama.Framework.Code.IMemberOrNamedType,System.String,Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IDeclaration})">
      <summary>
            Builds the aspect, i.e. translates the current declarative advice into a programmatic advice or possibly diagnostics
            and validators. In case of error, the implementation must report diagnostics and call <see cref="M:Metalama.Framework.Aspects.IAspectBuilder.SkipAspect" />.
            </summary>
      <param name="templateMember">The member or type to which the current attribute is applied.</param>
      <param name="templateMemberId">The a value that represents <paramref name="templateMember" /> and that must be supplied to <see cref="T:Metalama.Framework.Advising.IAdviceFactory" />.
                It is not actually the name, but a unique identifier of <paramref name="templateMember" />.</param>
      <param name="builder">An <see cref="T:Metalama.Framework.Aspects.IAspectBuilder`1" />.</param>
    </member>
    <member name="P:Metalama.Framework.Aspects.EditorExperienceAttribute.SuggestAsLiveTemplate">
      <summary>
            Gets or sets a value indicating whether the code refactoring menu should offer the possibility to apply this aspect as a live template, i.e., as an action that causes the aspect to applied to
            the source code itself. This property is <c>false</c> by default. The property is ignored if the aspect class does not have a default constructor. The eligibility
            of the aspect for the <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.LiveTemplate" /> scenario is taken into account. See <see cref="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})" /> for details.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.EditorExperienceAttribute.LiveTemplateSuggestionTitle">
      <summary>
            Gets or sets the title of the code refactoring menu item that applies the aspect as a live template. By default, the title is <c>Apply Foo</c> if the aspect class is named <c>FooAttribute</c>.
            To organize several aspects into sub-menus, use the vertical pipe (<c>|</c>) to separate the different menu levels.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.EditorExperienceAttribute.SuggestAsAddAttribute">
      <summary>
            Gets or sets a value indicating whether the code refactoring menu should offer the possibility to apply this aspect as a custom attribute. This property is <c>false</c> by default.
            The property is ignored if the aspect class does not have a default constructor. The eligibility
            of the aspect for the <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" /> or <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance" /> scenario is taken into account. See <see cref="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})" /> for details.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.EditorExperienceAttribute.AddAttributeSuggestionTitle">
      <summary>
            Gets or sets the title of the code refactoring menu item that applies the aspect as a custom attribute. By default, the title is <c>Add [Foo]</c> if the aspect class is named <c>FooAttribute</c>.
            To organize several aspects into sub-menus, use the vertical pipe (<c>|</c>) to separate the different menu levels.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.EventAspect">
      <summary>
            A base class for aspects that can be applied to events as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.EventAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IEvent})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.EventAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IEvent})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.ExcludeAspectAttribute">
      <summary>
            Custom attribute attribute that, when applied to a declaration, specifies that this declaration and all its members must not be
            the target of aspects of given types, unless the aspect is explicitly specified as a custom attribute.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.ExcludeAspectAttribute.#ctor(System.Type[])">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Aspects.ExcludeAspectAttribute" /> class.
            </summary>
      <param name="excludedAspectTypes"></param>
    </member>
    <member name="P:Metalama.Framework.Aspects.ExcludeAspectAttribute.Justification">
      <summary>
            Gets or sets the justification of the exclusion.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.FieldAspect">
      <summary>
            A base class for aspects that can be applied to fields as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.FieldAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IField})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.FieldAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IField})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.FieldOrPropertyAspect">
      <summary>
            A base class for aspects that can be applied to fields or properties as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.FieldOrPropertyAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IFieldOrProperty})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.FieldOrPropertyAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrProperty})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.ForcedGenericRunTimeOrCompileTimeAttribute">
      <summary>
            Attribute that means that the target declaration (and all children declarations) can be called both from compile-time
            and run-time code, even if the generic type arguments are not run-time-or-compile-time.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspect">
      <summary>
            The base interface for all aspects. A class should not implement
            this interface, but the strongly-typed variant <see cref="T:Metalama.Framework.Aspects.IAspect`1" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspect`1">
      <summary>
            The base interface for all aspects, with the type parameter indicating to which types
            of declarations the aspect can be added.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})">
      <summary>
            Initializes the aspect. The implementation must add advice, child aspects and validators
            using the <paramref name="builder" /> parameter.
            </summary>
      <param name="builder">An object that allows the aspect to add advice, child aspects and validators.</param>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspectBuilder">
      <summary>
            An object used by the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method of the aspect to provide advice, child
            aspects and validators, or report diagnostics. This is the weakly-typed variant of the <see cref="T:Metalama.Framework.Aspects.IAspectBuilder`1" /> interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.Project">
      <summary>
            Gets the current <see cref="T:Metalama.Framework.Project.IProject" />, which represents the <c>csproj</c> file and allows to share project-local data.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.AspectInstance">
      <summary>
            Gets the current <see cref="T:Metalama.Framework.Aspects.IAspectInstance" />, which gives access to the <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.Predecessors" />
            and the <see cref="P:Metalama.Framework.Aspects.IAspectInstance.SecondaryInstances" /> of the current aspect.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.Advice">
      <summary>
            Gets an object that allows to create advice, e.g. overriding members, introducing members, or implementing new interfaces.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.CancellationToken">
      <summary>
            Gets the cancellation token for the current operation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.IAspectBuilder.SkipAspect">
      <summary>
            Skips the application of the aspect to the code. Any provided advice and child aspects are ignored, but provided
            diagnostics are preserved. In multi-layer aspects, the next layers of the aspect are skipped. 
            </summary>
      <remarks>
            Note that reporting an error automatically causes the aspect to be skipped.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.IsAspectSkipped">
      <summary>
            Gets a value indicating whether the <see cref="M:Metalama.Framework.Aspects.IAspectBuilder.SkipAspect" /> method was called.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.AspectState">
      <summary>
            Gets or sets an arbitrary object that is then exposed on the <see cref="P:Metalama.Framework.Aspects.IAspectInstance.AspectState" /> property of
            the <see cref="T:Metalama.Framework.Aspects.IAspectInstance" /> interface. While a single instance of an aspect class can be used for
            several target declarations, the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder.AspectState" /> is specific to the target declaration. If the aspect
            is inherited, the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder.AspectState" /> must be compile-time-serializable (<see cref="T:Metalama.Framework.Serialization.ICompileTimeSerializable" /> or
            default serializable classes).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.Layer">
      <summary>
            Gets the name of the layer being built, or <c>null</c> if this is the default (initial) layer.
            When an aspect has several layers, the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method is called several times. To register
            aspect layers, add the <see cref="T:Metalama.Framework.Aspects.LayersAttribute" /> custom attribute to the aspect class.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.IAspectBuilder.With``1(``0)">
      <summary>
            Returns a copy of the current <see cref="T:Metalama.Framework.Aspects.IAspectBuilder" />, for use in the current execution context,
            but for a different <see cref="P:Metalama.Framework.Advising.IAdviser.Target" /> declaration.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder.Tags">
      <summary>
            Gets or sets the tags passed to all advice added by the current <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method. These tags
            can be consumed from the <c>meta.Tags</c> property.
            </summary>
      <remarks>
            Advice always receive the <i>last</i> value of the property, when the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> exits.
            These tags are merged with the ones passed as an argument of the <c>tags</c> parameter of any advise method.
            In case of conflit, the values passed to the advise method win.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspectBuilder`1">
      <summary>
            An object used by the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method of the aspect to provide advice, child
            aspects and validators, or report diagnostics. This is a strongly-typed variant of the <see cref="T:Metalama.Framework.Aspects.IAspectBuilder" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.IAspectBuilder`1.VerifyEligibility(Metalama.Framework.Eligibility.IEligibilityRule{`0})">
      <summary>
            Verifies that the target of the aspect matches an eligibility rule. If not, reports an eligibility error (unless the aspect can be used by inheritance) and skips the aspect.  
            </summary>
      <param name="rule">An eligibility rule created by <see cref="T:Metalama.Framework.Eligibility.EligibilityRuleFactory" />. For performance reasons, it is recommended that you store the rule in a static
            field of the aspect.</param>
      <returns>
        <c>true</c> if the aspect target qualifies for the given rule, otherwise <c>false</c> (in this case, the <see cref="M:Metalama.Framework.Aspects.IAspectBuilder.SkipAspect" /> method is automatically called. </returns>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder`1.Target">
      <summary>
            Gets the declaration to which the aspect was added in the state it was <i>before</i> the aspect was applied.
            </summary>
      <seealso cref="P:Metalama.Framework.Aspects.IAspectBuilder`1.AdvisedTarget" />
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder`1.AdvisedTarget">
      <summary>
            Gets the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder`1.Target" /> declaration in the <i>current</i> state, including all modifications performed by the current aspect.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectBuilder`1.Outbound">
      <summary>
            Gets an object that allows to add child advice (even to code added by aspects executed after the current one) and to validate code and code references.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspectClass">
      <summary>
            Represents the metadata of an aspect class.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.FullName">
      <summary>
            Gets the fully qualified type of the aspect.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.ShortName">
      <summary>
            Gets the name of the aspect type without the namespace and without the <c>Attribute</c> suffix.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.DisplayName">
      <summary>
            Gets the name of the aspect displayed to the design-time UI. This property should not be used to report diagnostics (<see cref="P:Metalama.Framework.Aspects.IAspectClass.ShortName" />
            should be used instead). It can be set by adding the <see cref="T:System.ComponentModel.DisplayNameAttribute" /> custom attribute to the aspect class. By default, it is equal to <see cref="P:Metalama.Framework.Aspects.IAspectClass.ShortName" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.Description">
      <summary>
            Gets the optional long description of the aspect. This property can be set by adding the <see cref="T:System.ComponentModel.DescriptionAttribute" /> custom attribute to the aspect class. By default, it is <c>null</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.IsAbstract">
      <summary>
            Gets a value indicating whether the aspect class is an abstract class.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.IsInheritable">
      <summary>
            Gets a value indicating whether instances of this aspect class are inherited by derived declarations.
            This property returns <c>null</c> when the aspect class implements the <see cref="T:Metalama.Framework.Aspects.IConditionallyInheritableAspect" />, because each aspect instance
            can decide whether it is inheritable or not. This property returns <c>true</c> when the aspect class is annotated with the <see cref="T:Metalama.Framework.Aspects.InheritableAttribute" /> custom attribute.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.IsAttribute">
      <summary>
            Gets a value indicating whether the aspect class derives from <see cref="T:System.Attribute" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectClass.Type">
      <summary>
            Gets the type of the aspect. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspectInstance">
      <summary>
            Represents an instance of an aspect. The instance of the <see cref="T:Metalama.Framework.Aspects.IAspect" /> itself is in the <see cref="P:Metalama.Framework.Aspects.IAspectInstance.Aspect" /> property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectInstance.Aspect">
      <summary>
            Gets the aspect instance.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectInstance.AspectClass">
      <summary>
            Gets the aspect type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectInstance.IsSkipped">
      <summary>
            Gets a value indicating whether the current aspect instance has been skipped. This value is <c>true</c> if
            the aspect evaluation resulted in an error or if the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method invoked
            <see cref="M:Metalama.Framework.Aspects.IAspectBuilder.SkipAspect" />, if it has been excluded using <see cref="T:Metalama.Framework.Aspects.ExcludeAspectAttribute" />,
            or when the target declaration was not eligible.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectInstance.IsInheritable">
      <summary>
            Gets a value indicating whether the current aspect instance can be inherited by derived declarations.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectInstance.SecondaryInstances">
      <summary>
            Gets the other instances of the same <see cref="P:Metalama.Framework.Aspects.IAspectInstance.AspectClass" /> on the same <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.TargetDeclaration" />.
            When several instances of the same <see cref="P:Metalama.Framework.Aspects.IAspectInstance.AspectClass" /> are found on the same <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.TargetDeclaration" />,
            they are ordered by priority, and only the first one gets executed. The other instances are exposed on this property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectInstance.AspectState">
      <summary>
            Gets the optional opaque object defined by the aspect for the specific <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.TargetDeclaration" /> using the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder.AspectState" />
            property of the <see cref="T:Metalama.Framework.Aspects.IAspectBuilder" /> interface.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspectPredecessor">
      <summary>
            Base interface for objects that can cause aspects to be added to a compilation. Predecessors are exposed on
            the <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.Predecessors" /> property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectPredecessor.PredecessorDegree">
      <summary>
            Gets the number of predecessors between the root cause and the current predecessor, or <c>0</c>
            if the current predecessor is the root cause. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectPredecessor.TargetDeclaration">
      <summary>
            Gets the declaration to which the aspect or fabric is applied.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IAspectPredecessor.Predecessors">
      <summary>
            Gets the list of objects that have caused the current aspect instance (but not any instance in the <see cref="P:Metalama.Framework.Aspects.IAspectInstance.SecondaryInstances" /> list)
            to be created. The ordering of this list is undetermined.
            </summary>
      <seealso href="@child-aspects" />
    </member>
    <member name="T:Metalama.Framework.Aspects.IAspectState">
      <summary>
            An empty interface that must be implemented by objects assigned to the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder.AspectState" /> property of the
            <see cref="T:Metalama.Framework.Aspects.IAspectBuilder" /> interface.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IConditionallyInheritableAspect">
      <summary>
            An interface that can be implemented by aspect that can be inheritable or non-inheritable
            based of a field or property of the aspect. When all the instances of the aspect class are unconditionally inheritable,
            the class must be annotated with the <see cref="T:Metalama.Framework.Aspects.InheritableAttribute" /> instead.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.MethodBase">
      <summary>
            Gets the target method or constructor, or the accessor if this is a template for a field, property or event,
            or throws an exception if the advice does not target a method, constructor or accessor.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Field">
      <summary>
            Gets the target field, or throws an exception if the advice does not target a field.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.FieldOrProperty">
      <summary>
            Gets the target field or property, or throws an exception if the advice does not target a field or a property.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.FieldOrPropertyOrIndexer">
      <summary>
            Gets the target field or property or indexer, or throws an exception if the advice does not target a field or a property or an indexer.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Declaration">
      <summary>
            Gets the target declaration.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Member">
      <summary>
            Gets the target member (method, constructor, field, property or event, but not a nested type), or
            throws an exception if the advice does not target a member.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Method">
      <summary>
            Gets the target method, or the accessor if this is a template for a field, property or event,
            or throws an exception if the advice does not target a method or accessor.
            </summary>
      <remarks>
            To invoke the method, use <see cref="M:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke(System.Object[])" />,
            e.g. <c>meta.Target.Method.Invoke(1, 2, 3);</c>.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Constructor">
      <summary>
            Gets the target constructor, or throws an exception if the advice does not target a constructor.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Property">
      <summary>
            Gets the target field or property, or throws an exception if the advice does not target a field or a property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Event">
      <summary>
            Gets the target event, or throws an exception if the advice does not target an event.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Parameters">
      <summary>
            Gets the list of parameters of the current <see cref="P:Metalama.Framework.Aspects.IMetaTarget.Method" />, <see cref="P:Metalama.Framework.Aspects.IMetaTarget.Constructor" />,  <see cref="P:Metalama.Framework.Aspects.IMetaTarget.Property" /> or <see cref="P:Metalama.Framework.Aspects.IMetaTarget.Indexer" /> or throws
            an exception if the advice does not target a method, constructor, property or indexer.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Parameter">
      <summary>
            Gets the target parameter or throws an exception if the advice does not target a parameter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Indexer">
      <summary>
            Gets the target indexer, or throws an exception if the advice does not target an indexer.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Type">
      <summary>
            Gets the code model of current type including the introductions of the current aspect type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Compilation">
      <summary>
            Gets the code model of the whole compilation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.Project">
      <summary>
            Gets the project being compiled.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IMetaTarget.ContractDirection">
      <summary>
            Gets the direction of the contract for which the template is being expanded.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.InheritableAttribute">
      <summary>
            Custom attribute that, when applied to an aspect class, means that instances of this aspect
            are inherited from the base class or interface to derived classes, from base methods to method overrides,
            from interface methods to method implementations, and so on. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.InterfaceMemberAttribute">
      <summary>
            Custom attribute that, when applied to a member of an aspect class, means that this aspect member is a template implementing a member of an interface implemented by
            <see cref="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.InterfaceMemberAttribute.IsExplicit">
      <summary>
            Gets or sets a value indicating whether the interface member should be introduced explicitly.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.InterfaceMemberAttribute.WhenExists">
      <summary>
            Gets or sets a value indication the override strategy when interface member conflicts with an existing class member.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.InterfaceMemberOverrideStrategy">
      <summary>
            Member conflict behavior of interface introduction advice.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.InterfaceMemberOverrideStrategy.Default">
      <summary>
            The behavior depends on the <see cref="T:Metalama.Framework.Aspects.OverrideStrategy" /> specified when calling the <see cref="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)" />
            method. When set to <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" />, the default value is <see cref="F:Metalama.Framework.Aspects.InterfaceMemberOverrideStrategy.Fail" />. When set to <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Override" />,
            the strategy is to override.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.InterfaceMemberOverrideStrategy.Fail">
      <summary>
            The advice fails with a compilation error if a matching interface member already exists in the target declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.InterfaceMemberOverrideStrategy.MakeExplicit">
      <summary>
            The advice introduces the interface member as explicit even if the interface member was supposed to be introduced as implicit.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.InterfaceMemberOverrideStrategy.Ignore">
      <summary>
            When the <see cref="T:Metalama.Framework.Aspects.OverrideStrategy" /> of the <see cref="M:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Aspects.OverrideStrategy,System.Object)" />
            is set to <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Override" />, does not override this member if there is already an implementation. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IntroduceAttribute">
      <summary>
            Custom attribute that can be applied to any member of an aspect class and that means that this member must be introduced to
            the target class of the aspect. 
            </summary>
      <seealso href="@introducing-members" />
    </member>
    <member name="P:Metalama.Framework.Aspects.IntroduceAttribute.WhenExists">
      <summary>
            Gets or sets the implementation strategy (like <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Override" />, <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" /> or <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Ignore" />) when the member is already declared in the target type.
            The default value is <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" />. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IntroduceAttribute.WhenInherited">
      <summary>
            Gets or sets the implementation strategy (like <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Override" />, <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" /> or <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Ignore" />) when the member is already declared
            in a parent class of the target type.
            The default value is <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" />. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IntroductionScope">
      <summary>
            Scope of introduction advice.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.IntroductionScope.Default">
      <summary>
            If the advice template is static, the behavior is the same as <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Static" />, otherwise behavior is the same as <see cref="F:Metalama.Framework.Aspects.IntroductionScope.Target" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.IntroductionScope.Instance">
      <summary>
            Introduced member will be always of instance scope.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.IntroductionScope.Static">
      <summary>
            Introduced member will be always of static scope.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.IntroductionScope.Target">
      <summary>
            Introduced member will be always of the same scope as the target declaration.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.InvalidTemplateSignatureException">
      <summary>
            An exception thrown by <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> when compile-time code attempts to add a template
            to a target declaration and the template is not compatible with the advice and the target declaration.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.IObjectReader">
      <summary>
            Exposes as a dictionary the tags passed to an advise.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.IObjectReader.Source">
      <summary>
            Gets the source object (typically an object of an anonymous type).
            </summary>
      <remarks>
             If there are several source objects (i.e. when both <c>aspectBuilder.Tags</c> and the
            <c>tags</c> method parameter are set), this propertyr returns an <c>ImmutableArray&lt;object&gt;</c>
            with all sources.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Aspects.ITemplateProvider">
      <summary>
            An interface that specifies that the type contains templates. Templates must be annotated with <see cref="T:Metalama.Framework.Aspects.TemplateAttribute" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.LayersAttribute">
      <summary>
            Custom attribute that, when applied to an aspect class, means that this aspect class uses several
            layers, and defines the name and the order of execution of these layers. In multi-aspect layers,
            the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method is called several times, once for each layer.
            The current layer is exposed in the <see cref="P:Metalama.Framework.Aspects.IAspectBuilder.Layer" /> property.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.meta">
      <summary>
            The entry point for the meta model, which can be used in templates to inspect the target code or access other
            features of the template language.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.Target">
      <summary>
            Gets access to the declaration being overridden or introduced.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Proceed">
      <summary>
            Invokes the logic that has been overwritten. For instance, in an <see cref="T:Metalama.Framework.Aspects.OverrideMethodAspect" />,
            calling <see cref="M:Metalama.Framework.Aspects.meta.Proceed" /> invokes the method being overridden. Note that the way how the
            logic is invoked (as a method call or inlining) is considered an implementation detail.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.ProceedAsync">
      <summary>
            Synonym to <see cref="M:Metalama.Framework.Aspects.meta.Proceed" />, but the return type is exposed as a <c>Task&lt;dynamic?&gt;</c>.
            Only use this method when the return type of the method or accessor is task-like. Note that
            the actual return type of the overridden method or accessor is the one of the overwritten semantic, so it
            can be a void <see cref="T:System.Threading.Tasks.Task" />, a <see cref="T:System.ValueType" />, or any other type.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.ProceedEnumerable">
      <summary>
            Synonym to <see cref="M:Metalama.Framework.Aspects.meta.Proceed" />, but the return type is exposed as a <c>IEnumerable&lt;dynamic?&gt;</c>.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.ProceedEnumerator">
      <summary>
            Synonym to <see cref="M:Metalama.Framework.Aspects.meta.Proceed" />, but the return type is exposed as a <c>IEnumerator&lt;dynamic?&gt;</c>.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.DebugBreak">
      <summary>
            Requests the debugger to break, if any debugger is attached to the current process.
            </summary>
      <seealso href="@debugging-aspects" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.CompileTime``1(``0)">
      <summary>
            Coerces an <paramref name="expression" /> to be interpreted as compile time. This is typically used
            to coerce expressions that can be either run-time or compile-time, such as a literal. Since ambiguous expressions are
            interpreted as run-time by default, this method allows to change that behavior.
            </summary>
      <param name="expression">An expression.</param>
      <typeparam name="T"></typeparam>
      <returns>Exactly <paramref name="expression" />, but coerced as a compile-time expression.</returns>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.RunTime``1(``0)">
      <summary>
            Converts a compile-value into run-time value by serializing the compile-time value into a some syntax that will
            evaluate, at run time, to the same value as at compile time.
            </summary>
      <param name="value">A compile-time value.</param>
      <typeparam name="T"></typeparam>
      <returns>A value that is structurally equivalent to the compile-time <paramref name="value" />.</returns>
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.This">
      <summary>
            Gets a <c>dynamic</c> object that represents an instance of the target type. It can be used as a value (e.g. as a method argument)
            or can be used to get access to <i>instance</i> members of the instance (e.g. <c>meta.This.MyMethod()</c>).
            The <see cref="P:Metalama.Framework.Aspects.meta.This" /> property exposes the state of the target type as it is <i>after</i> the application
            of all aspects. If the member is <c>virtual</c>, a virtual call is performed, therefore the implementation on the child type
            (possibly with all applied aspects) is performed.  It corresponds to <see cref="T:Metalama.Framework.Code.Invokers.InvokerOptions" />.<see cref="F:Metalama.Framework.Code.Invokers.InvokerOptions.Final" />.  To access the prior layer (or the base type, if there is no prior layer), use <see cref="P:Metalama.Framework.Aspects.meta.Base" />.
            To access static members, use <see cref="P:Metalama.Framework.Aspects.meta.ThisType" />.
            </summary>
      <seealso cref="P:Metalama.Framework.Aspects.meta.Base" />
      <seealso cref="P:Metalama.Framework.Aspects.meta.ThisType" />
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.Base">
      <summary>
            Gets a <c>dynamic</c> object that must be used to get access to <i>instance</i> members of the instance (e.g. <c>meta.Base.MyMethod()</c>).
            The <see cref="P:Metalama.Framework.Aspects.meta.Base" /> property exposes the state of the target type as it is <i>before</i> the application
            of the current aspect layer. It corresponds to <see cref="T:Metalama.Framework.Code.Invokers.InvokerOptions" />.<see cref="F:Metalama.Framework.Code.Invokers.InvokerOptions.Default" />. To access the final layer, use <see cref="P:Metalama.Framework.Aspects.meta.This" />.
            To access static members, use <see cref="P:Metalama.Framework.Aspects.meta.BaseType" />.
            </summary>
      <seealso cref="P:Metalama.Framework.Aspects.meta.This" />
      <seealso cref="P:Metalama.Framework.Aspects.meta.BaseType" />
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.ThisType">
      <summary>
            Gets a <c>dynamic</c> object that must be used to get access to <i>static</i> members of the type (e.g. <c>meta.ThisStatic.MyStaticMethod()</c>).
            The <see cref="P:Metalama.Framework.Aspects.meta.ThisType" /> property exposes the state of the target type as it is <i>after</i> the application
            of all aspects.  It corresponds to <see cref="T:Metalama.Framework.Code.Invokers.InvokerOptions" />.<see cref="F:Metalama.Framework.Code.Invokers.InvokerOptions.Final" />. To access the prior layer (or the base type, if there is no prior layer), use <see cref="P:Metalama.Framework.Aspects.meta.BaseType" />.
            To access instance members, use <see cref="P:Metalama.Framework.Aspects.meta.This" />.
            </summary>
      <seealso cref="P:Metalama.Framework.Aspects.meta.This" />
      <seealso cref="P:Metalama.Framework.Aspects.meta.BaseType" />
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.BaseType">
      <summary>
            Gets a <c>dynamic</c> object that must be used to get access to <i>static</i> members of the type (e.g. <c>meta.BaseStatic.MyStaticMethod()</c>).
            The <see cref="P:Metalama.Framework.Aspects.meta.BaseType" /> property exposes the state of the target type as it is <i>before</i> the application
            of the current aspect layer.  It corresponds to <see cref="T:Metalama.Framework.Code.Invokers.InvokerOptions" />.<see cref="F:Metalama.Framework.Code.Invokers.InvokerOptions.Default" />. To access the final layer, use <see cref="P:Metalama.Framework.Aspects.meta.ThisType" />.
            To access instance members, use <see cref="P:Metalama.Framework.Aspects.meta.Base" />.
            </summary>
      <seealso cref="P:Metalama.Framework.Aspects.meta.Base" />
      <seealso cref="P:Metalama.Framework.Aspects.meta.ThisType" />
      <seealso href="@templates" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.Tags">
      <summary>
            Gets the dictionary of tags that were passed to the <see cref="T:Metalama.Framework.Advising.IAdviceFactory" /> method by the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method.
            </summary>
      <seealso href="sharing-state-with-advice" />
    </member>
    <member name="P:Metalama.Framework.Aspects.meta.AspectInstance">
      <summary>
            Gets the current <see cref="T:Metalama.Framework.Aspects.IAspectInstance" />, which gives access to the <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.Predecessors" />
            and the <see cref="P:Metalama.Framework.Aspects.IAspectInstance.SecondaryInstances" /> of the current aspect.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Cast(Metalama.Framework.Code.IType,System.Object)">
      <summary>
            Generates the cast syntax for the specified type.  
            </summary>
      <param name="type"></param>
      <param name="value">Must be explicitly cast to <c>object</c> otherwise the C# compiler will emit an error.</param>
      <returns></returns>
      <seealso href="@templates" />
      <seealso cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.CastTo(Metalama.Framework.Code.IExpression,Metalama.Framework.Code.IType)" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Default(Metalama.Framework.Code.IType)">
      <summary>
            Generates the <c>default(T)</c> syntax for the specified type.
            </summary>
      <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default(Metalama.Framework.Code.IType)" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Default(Metalama.Framework.Code.SpecialType)">
      <summary>
            Generates the <c>default(T)</c> syntax for the specified type.
            </summary>
      <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default(Metalama.Framework.Code.IType)" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Default(System.Type)">
      <summary>
            Generates the <c>default(T)</c> syntax for the specified type.
            </summary>
      <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default(Metalama.Framework.Code.IType)" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InsertComment(System.String[])">
      <summary>
            Injects a comment to the target code.
            </summary>
      <param name="lines">A list of comment lines, without the <c>//</c> prefix. Null strings are processed as blank ones and will inject a blank comment line.</param>
      <remarks>
            This method is not able to add a comment to an empty block. The block must contain at least one statement.
            </remarks>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Inserts a statement into the target code, where the statement is given as an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.IExpression)">
      <summary>
            Inserts a statement into the target code, where the statement is given as an <see cref="T:Metalama.Framework.Code.IExpression" />.
            Note that not all expressions can be used as statements.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InsertStatement(System.String)">
      <summary>
            Inserts a statement into the target code, where the statement is given as a <see cref="T:System.String" />.
            Calling this overload is equivalent to calling the <see cref="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.SyntaxBuilders.IStatement)" /> overload
            with the result of the <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.Parse(System.String)" /> method.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InvokeTemplate(System.String,Metalama.Framework.Aspects.TemplateProvider,System.Object)">
      <summary>
            Calls another template method. This overload accepts a <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />.
            </summary>
      <param name="templateName">The name of the called template method.</param>
      <param name="templateProvider">A <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />.</param>
      <param name="args">Compile-time template arguments that will be passed to the template.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InvokeTemplate(System.String,Metalama.Framework.Aspects.ITemplateProvider,System.Object)">
      <summary>
            Calls another template method. This overload accepts an <see cref="T:Metalama.Framework.Aspects.ITemplateProvider" />. 
            </summary>
      <param name="templateName">The name of the called template method.</param>
      <param name="templateProvider">An optional <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />, or <see langword="default" /> for the current template provider (usually the current aspect).</param>
      <param name="args">Compile-time template arguments that will be passed to the template.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.InvokeTemplate(Metalama.Framework.Aspects.TemplateInvocation,System.Object)">
      <summary>
            Calls another template method.
            </summary>
      <param name="templateInvocation">Object that contains information about the called template method.</param>
      <param name="args">Compile-time template arguments that will be passed to the template, in addition to arguments from <paramref name="templateInvocation" />.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Return">
      <summary>
            Inserts a <c>return;</c> statement into the target code.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.meta.Return(System.Object)">
      <summary>
            Inserts a <c>return</c> statement into the target code.
            This can be used to return a value from <see langword="void" />-returning template methods.
            </summary>
      <param name="value">The value to return.</param>
    </member>
    <member name="T:Metalama.Framework.Aspects.MethodAspect">
      <summary>
            A base class for aspects that can be applied to methods as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.MethodAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IMethod})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.MethodAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMethod})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.OverrideEventAspect">
      <summary>
            A base aspect that overrides the implementation of an event.
            </summary>
      <seealso href="@overriding-events" />
    </member>
    <member name="M:Metalama.Framework.Aspects.OverrideEventAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IEvent})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.OverrideFieldOrPropertyAspect">
      <summary>
            A base aspect that overrides the implementation of a field or a property.
            </summary>
      <seealso href="@overriding-fields-or-properties" />
    </member>
    <member name="M:Metalama.Framework.Aspects.OverrideFieldOrPropertyAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IFieldOrProperty})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.OverrideFieldOrPropertyAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrProperty})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.OverrideMethodAspect">
      <summary>
            A base aspect that overrides the implementation of a method.
            </summary>
      <seealso href="@overriding-methods" />
    </member>
    <member name="M:Metalama.Framework.Aspects.OverrideMethodAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IMethod})">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Aspects.OverrideMethodAspect.UseEnumerableTemplateForAnyEnumerable">
      <summary>
            Gets or sets a value indicating whether the <see cref="M:Metalama.Framework.Aspects.OverrideMethodAspect.OverrideAsyncMethod" /> template must be applied to all methods returning an awaitable
            type (including <c>IAsyncEnumerable</c> and <c>IAsyncEnumerator</c>), instead of only to methods that have the <c>async</c> modifier.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.OverrideMethodAspect.UseAsyncTemplateForAnyAwaitable">
      <summary>
            Gets or sets a value indicating whether the <see cref="M:Metalama.Framework.Aspects.OverrideMethodAspect.OverrideEnumerableMethod" />, <see cref="M:Metalama.Framework.Aspects.OverrideMethodAspect.OverrideEnumeratorMethod" />,
            <c>OverrideAsyncEnumerableMethod"</c> or  <c>OverrideAsyncEnumeratorMethod"</c> template must be applied to all methods returning
            a compatible return type, instead of only to methods using the <c>yield</c> statement.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.OverrideMethodAspect.OverrideMethod">
      <summary>
            Default template of the new method implementation.
            </summary>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Aspects.OverrideStrategy">
      <summary>
            Conflict behavior of introduction advice.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.OverrideStrategy.Default">
      <summary>
            The advice fails with a compilation error if the member already exists in the target declaration. Same as <see cref="F:Metalama.Framework.Aspects.OverrideStrategy.Fail" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.OverrideStrategy.Fail">
      <summary>
            The advice fails with a compilation error if the member exists in the target declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.OverrideStrategy.Ignore">
      <summary>
            Advice is ignored if the member already exists in the target declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Aspects.OverrideStrategy.Override">
      <summary>
            Advice attempts to override the existing member or fails with a compilation error if that is not possible.
            </summary>
      <remarks>
            For attributes, this first removes all existing instances of the attribute.
            </remarks>
    </member>
    <member name="F:Metalama.Framework.Aspects.OverrideStrategy.New">
      <summary>
            If the member already exists, the advice attempts to redefine it using <c>new</c> or fails with a compilation error if that is not possible.
            </summary>
      <remarks>
            For attributes, this adds an instance of the attribute, even when some already exist.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Aspects.ParameterAspect">
      <summary>
            A base class for aspects that can be applied to parameters as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.ParameterAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IParameter})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.ParameterAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.PropertyAspect">
      <summary>
            A base class for aspects that can be applied to properties as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.PropertyAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.IProperty})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.PropertyAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IProperty})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.RequireAspectWeaverAttribute">
      <summary>
            Custom attribute that, when applied an an aspect class, means that this aspect class is implemented by a low-level weaver built with Metalama SDK.
            When the <see cref="T:Metalama.Framework.Aspects.RequireAspectWeaverAttribute" /> is added to a type, the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method is not invoked.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.RequireAspectWeaverAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Aspects.RequireAspectWeaverAttribute" /> class.
            </summary>
      <param name="weaverType">Full name (namespace and name but not assembly name) of the type implementing the aspect. This type must implement the
            <c>IAspectWeaver</c> interface and be annotated with the <c>[MetalamaPlugin]</c> attribute.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.RequireAspectWeaverAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Aspects.RequireAspectWeaverAttribute" /> class.
            </summary>
      <param name="weaverType">The type implementing the aspect. This type must implement the
            <c>IAspectWeaver</c> interface and be annotated with the <c>[MetalamaPlugin]</c> attribute.</param>
    </member>
    <member name="P:Metalama.Framework.Aspects.RequireAspectWeaverAttribute.Type">
      <summary>
            Gets the namespace-qualified name of the type implementing the aspect.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.RunTimeAttribute">
      <summary>
            Attribute that means that the target declaration (and all children declarations) can only be called from run-time
            code and, therefore, not from compile-time code. Code is run-time by default, so this attribute only makes sense on classes or interface that
            are run-time-only but derive a run-time-or-compile-time type. See <see cref="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute">
      <summary>
            Attribute that means that the target declaration (and all children declarations) can be called both from compile-time
            and run-time code. See <see cref="T:Metalama.Framework.Aspects.CompileTimeAttribute" /> for declarations that cannot be called from run-time code.
            </summary>
      <remarks>
        <para>
            You can use this attribute on classes that must be included in the compile-time project and therefore made
            available to your aspects.
            </para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Aspects.ScopeAttribute">
      <summary>
            A base class for all custom attributes that influence the scope (compile-time or run-time) of the code
            or its role in an aspect.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.TemplateAttribute">
      <summary>
            The base class for all custom attributes that mark a declaration as a template.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.TemplateAttribute.IsEmpty">
      <summary>
            Gets or sets a value indicating whether the template is an empty implementation, which means that the framework will consider the template
            to be undefined unless it is overridden in a derived class. It is similar to an abstract template implementation, but aspect deriving
            from the abstract class is not obliged to provide an implementation for the empty but non-abstract template.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.TemplateInvocation">
      <summary>
            Represents call to a template method.
            </summary>
      <param name="TemplateName">The name of the called template method.</param>
      <param name="TemplateProvider">An optional <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />, or <c>default</c> if the
            current template provider should be used.</param>
      <param name="Arguments">Compile-time template arguments that will be passed to the template.</param>
    </member>
    <member name="M:Metalama.Framework.Aspects.TemplateInvocation.#ctor(System.String,Metalama.Framework.Aspects.TemplateProvider,System.Object)">
      <summary>
            Represents call to a template method.
            </summary>
      <param name="TemplateName">The name of the called template method.</param>
      <param name="TemplateProvider">An optional <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />, or <c>default</c> if the
            current template provider should be used.</param>
      <param name="Arguments">Compile-time template arguments that will be passed to the template.</param>
    </member>
    <member name="P:Metalama.Framework.Aspects.TemplateInvocation.TemplateName">
      <summary>The name of the called template method.</summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.TemplateInvocation.TemplateProvider">
      <summary>An optional <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />, or <c>default</c> if the
            current template provider should be used.</summary>
    </member>
    <member name="P:Metalama.Framework.Aspects.TemplateInvocation.Arguments">
      <summary>Compile-time template arguments that will be passed to the template.</summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.TemplateProvider">
      <summary>
            Wraps a template provider type or instance.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.TemplateProvider.FromInstance(Metalama.Framework.Aspects.ITemplateProvider)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Aspects.TemplateProvider" /> from an object instance.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Aspects.TemplateProvider.FromType``1">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Aspects.TemplateProvider" /> from a type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.ThisAttribute">
      <summary>
            When applied to a template method parameter, indicates that the introduced parameter should have the <see langword="this" /> modifier, and that the introduced method should be an extension method.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Aspects.TypeAspect">
      <summary>
            A base class for aspects that can be applied to types as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.TypeAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.INamedType})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.TypeAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.INamedType})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Aspects.TypeParameterAspect">
      <summary>
            A base class for aspects that can be applied to type parameters (i.e. generic parameters) as custom attributes.
            </summary>
      <remarks>
        <para>This class is a redundant helper class. The aspect framework only respects the <see cref="T:Metalama.Framework.Aspects.IAspect`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Aspects.TypeParameterAspect.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{Metalama.Framework.Code.ITypeParameter})">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Aspects.TypeParameterAspect.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.ITypeParameter})">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Code.Accessibility">
      <summary>
            Accessibility of types and members, for instance <see cref="F:Metalama.Framework.Code.Accessibility.Private" /> or <see cref="F:Metalama.Framework.Code.Accessibility.Public" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.AccessibilityExtensions.IsSupersetOf(Metalama.Framework.Code.Accessibility,Metalama.Framework.Code.Accessibility)">
      <summary>
            Returns whether the left accessibility is strictly less restrictive than the right accessibility.
            </summary>
      <example>
            For example, <c>a.IsSupersetOf(Accessibility.Protected)</c> returns <see langword="true" /> for <c>a</c> being
            <see cref="F:Metalama.Framework.Code.Accessibility.ProtectedInternal" /> or <see cref="F:Metalama.Framework.Code.Accessibility.Public" />.
            </example>
    </member>
    <member name="M:Metalama.Framework.Code.AccessibilityExtensions.IsSubsetOf(Metalama.Framework.Code.Accessibility,Metalama.Framework.Code.Accessibility)">
      <summary>
            Returns whether the left accessibility is strictly more restrictive than the right accessibility.
            </summary>
      <example>
            For example, <c>a.IsSubsetOf(Accessibility.Protected)</c> returns <see langword="true" /> for <c>a</c> being
            <see cref="F:Metalama.Framework.Code.Accessibility.Private" /> or <see cref="F:Metalama.Framework.Code.Accessibility.PrivateProtected" />.
            </example>
    </member>
    <member name="M:Metalama.Framework.Code.AccessibilityExtensions.IsSupersetOrEqual(Metalama.Framework.Code.Accessibility,Metalama.Framework.Code.Accessibility)">
      <summary>
            Returns whether the left accessibility is less restrictive or equal than the right accessibility.
            </summary>
      <example>
            For example, <c>a.IsSupersetOf(Accessibility.Protected)</c> returns <see langword="true" /> for <c>a</c> being
            <see cref="F:Metalama.Framework.Code.Accessibility.Protected" />, <see cref="F:Metalama.Framework.Code.Accessibility.ProtectedInternal" /> or <see cref="F:Metalama.Framework.Code.Accessibility.Public" />.
            </example>
    </member>
    <member name="M:Metalama.Framework.Code.AccessibilityExtensions.IsSubsetOrEqual(Metalama.Framework.Code.Accessibility,Metalama.Framework.Code.Accessibility)">
      <summary>
            Returns whether the left accessibility is more restrictive or equal than the right accessibility.
            </summary>
      <example>
            For example, <c>a.IsSubsetOf(Accessibility.Protected)</c> returns <see langword="true" /> for <c>a</c> being
            <see cref="F:Metalama.Framework.Code.Accessibility.Protected" />, <see cref="F:Metalama.Framework.Code.Accessibility.Private" /> or <see cref="F:Metalama.Framework.Code.Accessibility.PrivateProtected" />.
            </example>
    </member>
    <member name="T:Metalama.Framework.Code.AsyncInfo">
      <summary>
            Information about an async method, returned by the <see cref="M:Metalama.Framework.Code.MethodExtensions.GetAsyncInfo(Metalama.Framework.Code.IMethod)" /> extension method of <see cref="T:Metalama.Framework.Code.IMethod" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.AsyncInfo.IsAsync">
      <summary>
            Gets a value indicating whether the method has an async implementation, i.e. has the <c>async</c> modifier.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.AsyncInfo.IsAwaitable">
      <summary>
            Gets a value indicating whether the return type of the method is awaitable, i.e. whether it can be used with the <c>await</c> keyword.
            This does not include <c>IAsyncEnumerable</c>, which can be used with <c>await foreach</c> but not <c>await</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.AsyncInfo.HasMethodBuilder">
      <summary>
            Gets a value indicating whether the return type of the method has an <c>AsyncMethodBuilderAttribute</c> custom attribute.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.AsyncInfo.IsAwaitableOrVoid">
      <summary>
            Gets a value indicating whether the return type of the method is either awaitable (see <see cref="P:Metalama.Framework.Code.AsyncInfo.IsAwaitable" />) either <c>void</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.AsyncInfo.ResultType">
      <summary>
            Gets the type of the result of the async method, i.e. the type of the <c>await</c> expression.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.AttributeExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Code.IAttribute" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.AttributeExtensions.ToAttributeConstruction(Metalama.Framework.Code.IAttribute)">
      <summary>
            Converts an <see cref="T:Metalama.Framework.Code.IAttribute" /> to an <see cref="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction" /> object.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.AttributeExtensions.TryGetNamedArgument(Metalama.Framework.Code.IAttribute,System.String,Metalama.Framework.Code.TypedConstant@)">
      <summary>
            Tries to get a named argument (i.e. the value assigned to a field or property).
            </summary>
      <param name="attribute"></param>
      <param name="name"></param>
      <param name="value"></param>
      <returns>
        <c>true</c> if the attribute defines this named argument, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.AttributeExtensions.GetArgumentValue``1(Metalama.Framework.Code.IAttribute,System.String,``0)">
      <summary>
            Tries to gets the value of an argument given its name, considering both <see cref="P:Metalama.Framework.Code.IAttributeData.NamedArguments" /> and <see cref="P:Metalama.Framework.Code.IAttributeData.ConstructorArguments" />.
            For constructor arguments, the name of the corresponding parameter is taken into account. Comparisons are case-insensitive.
            In case of ambiguity, the first match wins.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.AttributeExtensions.TryGetArgumentValue``1(Metalama.Framework.Code.IAttribute,System.String,``0@)">
      <summary>
            Tries to gets the value of an argument given its name, considering both <see cref="P:Metalama.Framework.Code.IAttributeData.NamedArguments" /> and <see cref="P:Metalama.Framework.Code.IAttributeData.ConstructorArguments" />.
            For constructor arguments, the name of the corresponding parameter is taken into account. Comparisons are case-insensitive.
            In case of ambiguity, the first match wins.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.AttributeExtensions.TryConstruct(Metalama.Framework.Code.IAttribute,Metalama.Framework.Diagnostics.ScopedDiagnosticSink,System.Attribute@)">
      <summary>
            Tries to construct an instance of the attribute represented by the current <see cref="T:Metalama.Framework.Code.IAttribute" />. The attribute type
            must not be a run-time-only type.
            </summary>
      <param name="attribute"></param>
      <param name="diagnosticSink"></param>
      <param name="constructedAttribute"></param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Code.CodeDisplayContext">
      <summary>
            Reserved for future use. Specifies the context for which the display string must be generated.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.CodeDisplayFormat">
      <summary>
            Defines the formatting options of <see cref="M:Metalama.Framework.Code.IDisplayable.ToDisplayString(Metalama.Framework.Code.CodeDisplayFormat,Metalama.Framework.Code.CodeDisplayContext)" />. Only well-known instances of this classes,
            exposed as properties, are currently supported.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.CodeDisplayFormat.FullyQualified">
      <summary>
            Emits fully-qualified code references, including namespaces and aliases.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.CodeDisplayFormat.DiagnosticMessage">
      <summary>
            Formats code references as in a C# error message.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.CodeDisplayFormat.MinimallyQualified">
      <summary>
            Emits minimally-qualified code references.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.CodeDisplayFormat.ShortDiagnosticMessage">
      <summary>
            Formats code references as in a C# short error message.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IAttributeCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IAttribute" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.IAttributeCollection.GetConstructedAttributesOfType``1">
      <summary>
            Gets the constructed attributes of a given type.
            </summary>
      <typeparam name="T"></typeparam>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IConstructorCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IConstructor" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IEventCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IEvent" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IFieldCollection">
      <summary>
            Represents a list of fields.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.Collections.IFieldCollection.Item(System.String)">
      <summary>
            Gets a field of a given name or throws an exception if there is none.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IFieldOrPropertyCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IField" /> or <see cref="T:Metalama.Framework.Code.IProperty" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IImplementedInterfaceCollection">
      <summary>
            List of interfaces implemented by a named type.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.IImplementedInterfaceCollection.Contains(System.Type)">
      <summary>
            Determines whether the current collection contains a given <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IIndexerCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IIndexer" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IMemberOrNamedTypeCollection`1">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IMemberOrNamedType" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.INamedDeclarationCollection`1">
      <summary>
            A collection of named elements.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.INamedDeclarationCollection`1.OfName(System.String)">
      <summary>
            Gets the set of members of a given name. Note that for named types, the short name will be matched,
            as opposed to the full, namespace-prefixed name.
            </summary>
      <param name="name">The member name (not including the namespace, for types).</param>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IMethodCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IMethod" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.INamedArgumentList">
      <summary>
            Represents a list of names arguments (i.e. setting of field or property values) in an <see cref="T:Metalama.Framework.Code.IAttributeData" />. The primary interface
            is an <see cref="T:System.Collections.Generic.IReadOnlyList`1" /> because the order of arguments may be important if property setters have a side effect.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.INamedTypeCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.INamedTypeCollection.OfTypeDefinition(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets the types in the collection that are derived from a given generic type,
            taking any type instance into account.
            </summary>
      <param name="typeDefinition"></param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.INamespaceCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.INamespace" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IParameterList">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IParameter" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.IPropertyCollection">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.IProperty" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.Collections.IPropertyCollection.Item(System.String)">
      <summary>
            Gets a property of a given name or throws an exception if there is none.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.ITypeParameterList">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.ITypeParameter" />.
            </summary>
      <remarks>
        <para>The order of items in this list is undetermined and may change between versions.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.Collections.ParameterListExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Code.Collections.IParameterList" /> class.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.ParameterListExtensions.OfParameterType``1(Metalama.Framework.Code.Collections.IParameterList)">
      <summary>
            Selects the parameters of a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.ParameterListExtensions.OfParameterType(Metalama.Framework.Code.Collections.IParameterList,System.Type)">
      <summary>
            Selects the parameters of a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Collections.ParameterListExtensions.OfParameterType(Metalama.Framework.Code.Collections.IParameterList,Metalama.Framework.Code.IType)">
      <summary>
            Selects the parameters of a given type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Comparers.ICompilationComparers">
      <summary>
            Exposes comparers of different characteristics.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.Comparers.ICompilationComparers.Default">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> allowing to compare types and declarations considers equal two instances that represent
            the same type or declaration even if they belong to different compilation versions. This comparer ignores
            the nullability annotations of reference types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.Comparers.ICompilationComparers.IncludeNullability">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> allowing to compare types and declarations considers equal two instances that represent
            the same type or declaration even if they belong to different compilation versions. This comparer takes
            the nullability annotations of reference types into account.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Comparers.IDeclarationComparer">
      <summary>
            An umbrella interface for an equality comparer of <see cref="T:Metalama.Framework.Code.IDeclaration" /> and <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Comparers.IRefEqualityComparer">
      <summary>
            This interface exists to write assertions that a dictionary has been created with the proper comparer.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Comparers.ITypeComparer">
      <summary>
            Extends <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> of <see cref="T:Metalama.Framework.Code.IType" /> with the method <see cref="M:Metalama.Framework.Code.Comparers.ITypeComparer.IsConvertibleTo(Metalama.Framework.Code.IType,Metalama.Framework.Code.IType,Metalama.Framework.Code.ConversionKind)" />,
            which checks for type inheritance and not equality.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Comparers.ITypeComparer.IsConvertibleTo(Metalama.Framework.Code.IType,Metalama.Framework.Code.IType,Metalama.Framework.Code.ConversionKind)">
      <summary>
            Equivalent to the <c>is</c> operator in C#. Gets a value indicating whether the left <see cref="T:Metalama.Framework.Code.IType" /> is assignable to right <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
      <returns></returns>
    </member>
    <member name="M:Metalama.Framework.Code.Comparers.ITypeComparer.IsConvertibleTo(Metalama.Framework.Code.IType,System.Type,Metalama.Framework.Code.ConversionKind)">
      <summary>
            Equivalent to the <c>is</c> operator in C#. Gets a value indicating whether the left <see cref="T:System.Type" /> is assignable to right <see cref="T:System.Type" />.
            </summary>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Code.Comparers.TypeComparison">
      <summary>
            Specifies which comparer should be used.
            </summary>
      <seealso cref="P:Metalama.Framework.Code.ICompilation.Comparers" />
    </member>
    <member name="F:Metalama.Framework.Code.Comparers.TypeComparison.Default">
      <summary>
            Does not take nullability into account.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Comparers.TypeComparison.IncludeNullability">
      <summary>
            Takes nullability into account.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ConstructorCollectionExtensions">
      <summary>
            Provides extension methods to the <see cref="T:Metalama.Framework.Code.Collections.IConstructorCollection" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ConstructorCollectionExtensions.OfCompatibleSignature(Metalama.Framework.Code.Collections.IConstructorCollection,System.Collections.Generic.IReadOnlyList{System.Type})">
      <summary>
            Gets a list of constructors with signatures compatible with specified constraints given using the <c>System.Reflection</c> API.
            </summary>
      <param name="constructors">A collection of constructors.</param>
      <param name="argumentTypes">Constraint on reflection types of arguments. <c>Null</c>items in the list signify any type.</param>
      <returns>Enumeration of constructors matching specified constraints.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.ConstructorCollectionExtensions.OfCompatibleSignature(Metalama.Framework.Code.Collections.IConstructorCollection,System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.IType},System.Collections.Generic.IReadOnlyList{System.Nullable{Metalama.Framework.Code.RefKind}})">
      <summary>
            Gets a list of constructors with signatures compatible with specified constraints given using the Metalama API.
            </summary>
      <param name="constructors">A collection of constructors.</param>
      <param name="argumentTypes">Constraint on types of arguments. <c>Null</c>items in the list signify any type.</param>
      <param name="refKinds">Constraint on reference kinds of arguments. <c>Null</c>items in the list signify any reference kind.</param>
      <returns>Enumeration of constructors matching specified constraints.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.ConstructorCollectionExtensions.OfExactSignature(Metalama.Framework.Code.Collections.IConstructorCollection,System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.IType},System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.RefKind})">
      <summary>
            Gets a constructor that exactly matches the specified signature given using the <c>System.Reflection</c> API.
            </summary>
      <param name="constructors">A collection of constructors.</param>
      <param name="parameterTypes">List of parameter types.</param>
      <param name="refKinds">List of parameter reference kinds, or <c>null</c> if all parameters should be by-value.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.IConstructor" /> that matches the given signature.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.ConstructorCollectionExtensions.OfExactSignature(Metalama.Framework.Code.Collections.IConstructorCollection,Metalama.Framework.Code.IConstructor)">
      <summary>
            Gets a constructor that exactly matches the signature of the specified method.
            </summary>
      <param name="constructors">A collection of constructors.</param>
      <param name="signatureTemplate">Constructor signature of which to should be considered.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.IConstructor" /> that matches the given signature.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.ConstructorInitializerKind">
      <summary>
            Describes the kind of constructor initializer.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConstructorInitializerKind.None">
      <summary>
            The constructor has no explicit initializer.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConstructorInitializerKind.Base">
      <summary>
            The initializer refers to the base constructor.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConstructorInitializerKind.This">
      <summary>
            The initializer reference another constructor of the same type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ConversionKind">
      <summary>
            Describes conversion between types possible during comparison.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConversionKind.Default">
      <summary>
            Accepts any value that is type-compatible, including boxing conversions, but excluding user-defined implicit operators. This corresponds to the behavior of C# <c>is</c> operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConversionKind.Reference">
      <summary>
            Accepts any value that is reference-compatible with the given type i.e. instances of subclasses or interface implementations, but refuses boxing conversions.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConversionKind.Implicit">
      <summary>
            Accepts any value implicitly convertible to the given type, including boxing and user-defined implicit operators. This corresponds to C# value assignability.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ConversionKind.TypeDefinition">
      <summary>
            Accepts any value that extends or implements a type that is of the same type definition as the given type definition.
            </summary>
      <remarks>
            For non-generic types behaves like <see cref="F:Metalama.Framework.Code.ConversionKind.Reference" />. For generic types, ignores all type arguments and tests that 
            the given type definition is equal to a type definition of the value, a type definition of any base type, or a type definition of
            any implemented interface (by the type itself or by any base type, including base interfaces).
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction">
      <summary>
            Encapsulates the information necessary to create a custom attribute. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.Constructor">
      <summary>
            Gets the attribute constructor.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.Type">
      <summary>
            Gets the attribute type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.ConstructorArguments">
      <summary>
            Gets the constructor arguments.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.NamedArguments">
      <summary>
            Gets the named arguments, i.e. the assigned fields and properties.
            Note that the order may be important in case of non-trivial property setters.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.Create(Metalama.Framework.Code.IConstructor,System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.TypedConstant},System.Collections.Generic.IReadOnlyList{System.Collections.Generic.KeyValuePair{System.String,Metalama.Framework.Code.TypedConstant}})">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction" /> by explicitly specifying the constructor and strongly-typed arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.Create(System.Type,System.Collections.Generic.IReadOnlyList{System.Object},System.Collections.Generic.IReadOnlyList{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction" /> by specifying the reflection <see cref="T:System.Type" /> of the attribute.
            The method will attempt to find a suitable constructor.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction.Create(Metalama.Framework.Code.INamedType,System.Collections.Generic.IReadOnlyList{System.Object},System.Collections.Generic.IReadOnlyList{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction" /> by specifying the <see cref="T:Metalama.Framework.Code.INamedType" /> of the attribute.
            The method will attempt to find a suitable constructor.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IDeclarationBuilder">
      <summary>
            Allows to complete the construction of a declaration that has been created by an advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IDeclarationBuilder.IsFrozen">
      <summary>
            Gets a value indicating whether the builder has been frozen. When the value is <c>true</c>, modifications can no longer be performed.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IDeclarationBuilder.Freeze">
      <summary>
            Freezes the declaration so that modifications can no longer be performed.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IDeclarationBuilder.AddAttribute(Metalama.Framework.Code.DeclarationBuilders.AttributeConstruction)">
      <summary>
            Adds a custom attribute to the current declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IDeclarationBuilder.RemoveAttributes(Metalama.Framework.Code.INamedType)">
      <summary>
            Removes all custom attributes of a given type from the current declaration.
            </summary>
      <param name="type">TYpe of custom attributes to be removed.</param>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder">
      <summary>
            Allows to complete the construction of an event that has been created by an advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder.Type">
      <summary>
            Gets or sets the event type (i.e. the type of the delegates handled by this event).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder.AddMethod">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> for the event adder.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder.RemoveMethod">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> for the event remover.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IEventBuilder.RaiseMethod">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> for the event raiser.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder">
      <summary>
            Allows to complete the construction of a field that has been created by an advice.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IFieldOrPropertyBuilder">
      <summary>
            Base interface for <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder" /> and <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IFieldOrPropertyBuilder.InitializerExpression">
      <summary>
            Gets or sets the initializer expression (i.e. the expression at the right hand of the equal sign).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IFieldOrPropertyBuilder.IsRequired">
      <summary>
            Gets or sets a value indicating whether the field or property is <c>required</c>, i.e. it must be initialized
            when an instance of the declaring type is initialized.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IFieldOrPropertyOrIndexerBuilder">
      <summary>
            Base interface for <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IFieldBuilder" />, <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> and <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IFieldOrPropertyOrIndexerBuilder.Writeability">
      <summary>
            Gets or sets writeability of the field, property or indexer, i.e. the situations in which it can be written.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IHasParametersBuilder">
      <summary>
            Represents a builder of method, constructor, or indexer. Overrides the <see cref="P:Metalama.Framework.Code.DeclarationBuilders.IHasParametersBuilder.Parameters" /> property to allow
            using <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilderList" /> interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IHasParametersBuilder.Parameters">
      <summary>
            Gets the list of parameters of the current method (but not the return parameter).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IHasTypeBuilder">
      <summary>
            Exposes a settable <see cref="P:Metalama.Framework.Code.DeclarationBuilders.IHasTypeBuilder.Type" /> property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IHasTypeBuilder.Type">
      <summary>
            Gets or sets the type of the field or property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IHasTypeBuilder.RefKind">
      <summary>
            Gets or sets the <see cref="T:Metalama.Framework.Code.RefKind" /> of the property, indexer or property
            (i.e. <see cref="F:Metalama.Framework.Code.RefKind.Ref" />, <see cref="F:Metalama.Framework.Code.RefKind.Out" />, ...).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder">
      <summary>
            Allows to complete the construction of an indexer that has been created by an advice.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder.AddParameter(System.String,Metalama.Framework.Code.IType,Metalama.Framework.Code.RefKind,System.Nullable{Metalama.Framework.Code.TypedConstant})">
      <summary>
            Adds a parameter to the current indexer and specifies its type using an <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
      <param name="name"></param>
      <param name="type"></param>
      <param name="refKind"></param>
      <param name="defaultValue"></param>
      <returns></returns>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder.AddParameter(System.String,System.Type,Metalama.Framework.Code.RefKind,System.Nullable{Metalama.Framework.Code.TypedConstant})">
      <summary>
            Adds a parameter to the current indexer and specifies its type using a reflection <see cref="T:System.Type" />.
            </summary>
      <param name="name"></param>
      <param name="type"></param>
      <param name="refKind"></param>
      <param name="defaultValue"></param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IMemberBuilder">
      <summary>
            Allows to complete the construction of a member (but not a named type) that has been created by an advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberBuilder.IsVirtual">
      <summary>
            Gets or sets a value indicating whether the member is <c>virtual</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberBuilder.IsExtern">
      <summary>
            Gets or sets a value indicating whether the member is <c>extern</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder">
      <summary>
            Allows to complete the construction of a member or named type that has been created by an advice.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder.Accessibility">
      <summary>
            Gets or sets the accessibility of the member.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder.Name">
      <summary>
            Gets or sets the member name.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder.IsStatic">
      <summary>
            Gets or sets a value indicating whether the member is <c>static</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder.IsSealed">
      <summary>
            Gets or sets a value indicating whether the member is <c>sealed</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder.IsAbstract">
      <summary>
            Gets or sets a value indicating whether the member is <c>abstract</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMemberOrNamedTypeBuilder.IsPartial">
      <summary>
            Gets or sets a value indicating whether the member is <c>partial</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IMethodBaseBuilder.AddParameter(System.String,Metalama.Framework.Code.IType,Metalama.Framework.Code.RefKind,System.Nullable{Metalama.Framework.Code.TypedConstant})">
      <summary>
            Appends a parameter to the method.
            </summary>
      <param name="name">Parameter name.</param>
      <param name="type">Parameter type.</param>
      <param name="refKind">
        <c>out</c>, <c>ref</c>...</param>
      <param name="defaultValue">Default value.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder" /> that allows you to further build the new parameter.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IMethodBaseBuilder.AddParameter(System.String,System.Type,Metalama.Framework.Code.RefKind,System.Nullable{Metalama.Framework.Code.TypedConstant})">
      <summary>
            Appends a parameter to the method.
            </summary>
      <param name="name">Parameter name.</param>
      <param name="type">Parameter type.</param>
      <param name="refKind">
        <c>out</c>, <c>ref</c>...</param>
      <param name="defaultValue">Default value.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder" /> that allows you to further build the new parameter.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder">
      <summary>
            Allows to complete the construction of a method that has been created by an advice.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder.AddTypeParameter(System.String)">
      <summary>
            Adds a generic parameter to the method.
            </summary>
      <param name="name"></param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.ITypeParameterBuilder" /> that allows you to further build the new parameter.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder.ReturnParameter">
      <remarks>
            Gets an object allowing to read and modify the method return type and custom attributes,
            or  <c>null</c> for methods that don't have return types: constructors and finalizers.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder.ReturnType">
      <summary>
            Gets or sets the method return type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.INamedTypeBuilder.IsPartial">
      <summary>
            Gets or sets a value indicating whether the type is marked as <c>partial</c> in source code. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.INamedTypeBuilder.BaseType">
      <summary>
            Gets or sets the type from which the current type derives.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationBuilders.INamedTypeBuilder.AddTypeParameter(System.String)">
      <summary>
            Adds a generic parameter to the type.
            </summary>
      <param name="name">Name of the generic parameter.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.DeclarationBuilders.ITypeParameterBuilder" /> that allows you to further build the new parameter.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder">
      <summary>
            Allows to complete the construction of a parameter that has been created using e.g.
            <see cref="M:Metalama.Framework.Code.DeclarationBuilders.IMethodBaseBuilder.AddParameter(System.String,Metalama.Framework.Code.IType,Metalama.Framework.Code.RefKind,System.Nullable{Metalama.Framework.Code.TypedConstant})" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder.DefaultValue">
      <remarks>
            Gets or sets the default value of the parameter, or  <c>default</c> if the parameter type is a struct and the default
            value of the parameter is the default value of the struct type.
            </remarks>
      <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder.Type">
      <summary>
            Gets or sets the parameter type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder.RefKind">
      <summary>
            Gets or sets the parameter ref kind.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder.Name">
      <summary>
            Gets or sets of the parameter name.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder.IsParams">
      <summary>
            Gets or sets a value indicating whether the parameter has the <c>params</c> modifier.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder.IsThis">
      <summary>
            Gets or sets a value indicating whether the parameter has the <see langword="this" /> modifier, meaning that the containing method is an extension method.
            </summary>
      <remarks>
            For templates, you can also use <see cref="T:Metalama.Framework.Aspects.ThisAttribute" />.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilderList">
      <summary>
            Read-only list of <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IParameterBuilder" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder">
      <summary>
            Allows to complete the construction of a property that has been created by an advice.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyOrIndexerBuilder">
      <summary>
            Base interface for <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IPropertyBuilder" /> and <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IIndexerBuilder" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IPropertyOrIndexerBuilder.GetMethod">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> for the getter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.IPropertyOrIndexerBuilder.SetMethod">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.DeclarationBuilders.IMethodBuilder" /> for the setter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.DeclarationBuilders.ITypeParameterBuilder.HasDefaultConstructorConstraint">
      <summary>
            Gets or sets a value indicating whether the generic parameter has the <c>new()</c> constraint.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationEnhancements`1">
      <summary>
            Gives access to the aspects, options and annotations on a declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetAspects``1">
      <summary>
            Gets the set of instances of a specified type of aspects that have been applied to a specified declaration.
            </summary>
      <param name="declaration">The declaration.</param>
      <typeparam name="TAspect">The exact type of aspects.</typeparam>
      <returns>The set of aspects of exact type <typeparamref name="T" /> applied on the current <see cref="P:Metalama.Framework.Code.DeclarationEnhancements`1.Declaration" />.</returns>
      <remarks>
            You can call this method only for aspects that have been already been applied or are being applied, i.e. you can query aspects
            that are applied before the current aspect, or you can query instances of the current aspects applied in a parent class.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationEnhancements`1.HasAspect(System.Type)">
      <summary>
            Determines if the current declaration has at least one aspect of the given type.
            </summary>
      <remarks>
            You can call this method only for aspects that have been already been applied or are being applied, i.e. you can query aspects
            that are applied before the current aspect, or you can query instances of the current aspects applied in a parent class.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetAspectInstances">
      <summary>
            Gets the set of aspects (represented by their <see cref="T:Metalama.Framework.Aspects.IAspectInstance" />) that have been applied to a specified declaration.
            </summary>
      <param name="declaration">The declaration.</param>
      <returns>The set of aspects of exact type <typeparamref name="T" /> applied on the current <see cref="P:Metalama.Framework.Code.DeclarationEnhancements`1.Declaration" />.</returns>
      <remarks>
            This method will only return aspects that have been already been applied or are being applied, i.e. you can query aspects
            that are applied before the current aspect, or you can query instances of the current aspects applied in a parent class.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationEnhancements`1.HasAspect``1">
      <summary>
            Determines if the current declaration has at least one aspect of the given type.
            </summary>
      <remarks>
            You can call this method only for aspects that have been already been applied or are being applied, i.e. you can query aspects
            that are applied before the current aspect, or you can query instances of the current aspects applied in a parent class.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetOptions``1">
      <summary>
            Gets the options effective for the current declarations. Options provided by aspects through the <see cref="T:Metalama.Framework.Options.IHierarchicalOptionsProvider" /> are available only when and after the given
            aspect instance has been initialized; options provided by other means are available immediately.
            </summary>
      <typeparam name="TOptions">The type of options.</typeparam>
      <seealso href="@exposing-options" />
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetAnnotations``1">
      <summary>
            Gets the list of annotations of a given type on the current declaration.
            </summary>
      <typeparam name="TAnnotation">The type of annotations.</typeparam>
      <returns>The list of annotations of this type on the current declaration.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationExtensions">
      <summary>
            Extension methods for <see cref="T:Metalama.Framework.Code.IDeclaration" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.IsContainedIn(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Code.IDeclaration)">
      <summary>
            Determines if a given declaration is a child of another given declaration, using the <see cref="P:Metalama.Framework.Code.IDeclaration.ContainingDeclaration" />
            relationship for all declarations except for named type, where the parent namespace is considered.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.ContainingAncestors(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets all containing ancestors, i.e. <c>declaration.ContainingDeclaration</c>, <c>declaration.ContainingDeclaration.ContainingDeclaration</c>,
            <c>declaration.ContainingDeclaration.ContainingDeclaration.ContainingDeclaration</c>... 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.ContainingAncestorsAndSelf(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets all containing ancestors including the current declaration, i.e. <c>declaration</c>, <c>declaration.ContainingDeclaration</c>, <c>declaration.ContainingDeclaration.ContainingDeclaration</c>,
            <c>declaration.ContainingDeclaration.ContainingDeclaration.ContainingDeclaration</c>... 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.Enhancements``1(``0)">
      <summary>
            Gets an object that gives access to the aspects, options and annotations on the current declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.GetClosestNamedType(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the declaring <see cref="T:Metalama.Framework.Code.INamedType" /> of a given declaration if the declaration is not an <see cref="T:Metalama.Framework.Code.INamedType" />, or the <see cref="T:Metalama.Framework.Code.INamedType" /> itself if the given declaration is itself an <see cref="T:Metalama.Framework.Code.INamedType" />. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.GetClosestMemberOrNamedType(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the declaring <see cref="T:Metalama.Framework.Code.IMemberOrNamedType" /> of a given declaration if the declaration if not an <see cref="T:Metalama.Framework.Code.IMemberOrNamedType" />, or the <see cref="T:Metalama.Framework.Code.IMemberOrNamedType" /> itself if the given declaration is itself an <see cref="T:Metalama.Framework.Code.IMemberOrNamedType" />. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.GetTopmostNamedType(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the topmost type of a nested type, i.e. a type that is not contained in any other type. If the given type is not a given type,
            returns the given type itself. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.GetNamespace(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the namespace of a given declaration, i.e. the namespace itself if the given declaration is a namespace,
            the closest containing namespace, or the global namespace if an <see cref="T:Metalama.Framework.Code.ICompilation" /> is given.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.ForCompilation``1(``0,Metalama.Framework.Code.ICompilation)">
      <summary>
            Gets a representation of the current declaration in a different version of the compilation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.TryForCompilation``1(``0,Metalama.Framework.Code.ICompilation,``0@)">
      <summary>
            Tries to get a representation of the current declaration in a different version of the compilation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.ContainedChildren(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the declarations (namespaces, types, methods, properties, fields, constructors, events, indexers) directly contained in the given declaration.
            </summary>
      <remarks>The method does not descent into accessors, custom attributes, parameters, or type parameters.</remarks>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.ContainedDescendants(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the declarations (namespaces, types, methods, properties, fields, constructors, events, indexers) in the given declaration
            and in any child of the declaration.
            </summary>
      <remarks>The method does not descent into accessors, custom attributes, parameters, or type parameters.</remarks>
    </member>
    <member name="M:Metalama.Framework.Code.DeclarationExtensions.ContainedDescendantsAndSelf(Metalama.Framework.Code.IDeclaration)">
      <summary>
            Gets the declarations (namespaces, types, methods, properties, fields, constructors, events, indexers) in the given declaration
            and in any child of the declaration, plus the given declaration.
            </summary>
      <remarks>The method does not descent into accessors, custom attributes, parameters, or type parameters.</remarks>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationKind">
      <summary>
            Kinds of <see cref="T:Metalama.Framework.Code.IDeclaration" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.None">
      <summary>
            Not a valid declaration represented by <see cref="T:Metalama.Framework.Code.IDeclaration" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Compilation">
      <summary>
        <see cref="T:Metalama.Framework.Code.ICompilation" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.NamedType">
      <summary>
        <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Method">
      <summary>
        <see cref="T:Metalama.Framework.Code.IMethod" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Property">
      <summary>
        <see cref="T:Metalama.Framework.Code.IProperty" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Indexer">
      <summary>
        <see cref="T:Metalama.Framework.Code.IIndexer" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Field">
      <summary>
        <see cref="T:Metalama.Framework.Code.IField" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Event">
      <summary>
        <see cref="T:Metalama.Framework.Code.IEvent" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Parameter">
      <summary>
        <see cref="T:Metalama.Framework.Code.IParameter" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.TypeParameter">
      <summary>
        <see cref="T:Metalama.Framework.Code.ITypeParameter" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Attribute">
      <summary>
        <see cref="T:Metalama.Framework.Code.IAttribute" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.ManagedResource">
      <summary>
        <see cref="T:Metalama.Framework.Code.IManagedResource" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Constructor">
      <summary>
        <see cref="T:Metalama.Framework.Code.IConstructor" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Finalizer">
      <summary>
        <see cref="T:Metalama.Framework.Code.IMethod" /> that is a finalizer (historically referred to as destructors).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Operator">
      <summary>
        <see cref="T:Metalama.Framework.Code.IMethod" /> that is an operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.AssemblyReference">
      <summary>
            A reference assembly, implementing <see cref="T:Metalama.Framework.Code.IAssembly" />. Note
            that the current assembly is represented by <see cref="T:Metalama.Framework.Code.ICompilation" /> that inherits <see cref="T:Metalama.Framework.Code.IAssembly" />, but the
            <see cref="T:Metalama.Framework.Code.DeclarationKind" /> for the current compilation is <see cref="F:Metalama.Framework.Code.DeclarationKind.Compilation" /> and not <see cref="F:Metalama.Framework.Code.DeclarationKind.AssemblyReference" />. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Namespace">
      <summary>
        <see cref="T:Metalama.Framework.Code.INamespace" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationKind.Type">
      <summary>
        <see cref="T:Metalama.Framework.Code.IType" />, but neither an <see cref="T:Metalama.Framework.Code.INamedType" /> nor an <see cref="T:Metalama.Framework.Code.ITypeParameter" />.
            Note that <see cref="T:Metalama.Framework.Code.IType" /> is not an <see cref="T:Metalama.Framework.Code.IDeclaration" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DeclarationOriginKind">
      <summary>
            Kinds of <see cref="T:Metalama.Framework.Code.IDeclarationOrigin" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationOriginKind.Source">
      <summary>
            Indicates that the declaration belongs to the current project and stems from source code and not from a source generator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationOriginKind.External">
      <summary>
            Indicates that the declaration stems from a different project or assembly.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationOriginKind.Aspect">
      <summary>
            Indicates that the declaration was created by an aspect of the current project or an inherited aspect applied to the current project.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DeclarationOriginKind.Generator">
      <summary>
            Indicates that the declaration belongs to the current project and has been generated by a source generator. Note that such code is
            not visible at design time.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.DerivedTypesOptions">
      <summary>
            Options for the <see cref="M:Metalama.Framework.Code.ICompilation.GetDerivedTypes(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.DerivedTypesOptions)" /> method.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DerivedTypesOptions.Default">
      <summary>
            Equivalent to <see cref="F:Metalama.Framework.Code.DerivedTypesOptions.All" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DerivedTypesOptions.All">
      <summary>
            Returns all types declared in the current compilation that derive from the given type, directly or indirectly.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DerivedTypesOptions.DirectOnly">
      <summary>
            Only returns types declared in the current compilation that directly derive from the given type.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DerivedTypesOptions.FirstLevelWithinCompilationOnly">
      <summary>
            Only returns types of the current compilation that derive from the given type or from an intermediate derived type of the given type, only
            if the derived type is an external type. That is, does not return types of the current compilation that derive from another type in
            the current compilation that derives from the given type.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.DerivedTypesOptions.IncludingExternalTypesDangerous">
      <summary>
            Returns types of the current compilation and of any referenced project or assembly. This setting is dangerous because not all types referenced
            by the current compilation are returned: only types <i>declared</i> or <i>used as attributes</i> in the current compilation and all their base
            types are indexed. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.EnumerableKind">
      <summary>
            Kinds of iterators.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.None">
      <summary>
            None. The method does not returns an enumerable or enumerator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.IEnumerable">
      <summary>
            A method returning a generic <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.IEnumerator">
      <summary>
            A method returning a generic <see cref="T:System.Collections.Generic.IEnumerator`1" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.UntypedIEnumerable">
      <summary>
            A method returning a non-generic <see cref="T:System.Collections.IEnumerable" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.UntypedIEnumerator">
      <summary>
            A method returning a non-generic <see cref="T:System.Collections.IEnumerator" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.IAsyncEnumerable">
      <summary>
            A method returning <c>System.Collections.Generic.IAsyncEnumerable</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.EnumerableKind.IAsyncEnumerator">
      <summary>
            A method returning <c>System.Collections.Generic.IAsyncEnumerator</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ExecutionScope">
      <summary>
            Enumerates the possible execution scopes of a declaration i.e. <see cref="F:Metalama.Framework.Code.ExecutionScope.RunTime" />, <see cref="F:Metalama.Framework.Code.ExecutionScope.CompileTime" /> or <see cref="F:Metalama.Framework.Code.ExecutionScope.RunTimeOrCompileTime" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ExecutionScope.Default">
      <summary>
            Equal to <see cref="F:Metalama.Framework.Code.ExecutionScope.RunTime" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ExecutionScope.RunTime">
      <summary>
            Run-time-only declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ExecutionScope.CompileTime">
      <summary>
            Compile-time-only declaration. Typically a type annotated with <see cref="T:Metalama.Framework.Aspects.CompileTimeAttribute" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ExecutionScope.RunTimeOrCompileTime">
      <summary>
            Run-time-or-compile-time declaration. Typically an aspect or a type annotated with <see cref="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.GenericExtensions">
      <summary>
            Provides extension methods to work with generic declarations.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.IsSelfOrDeclaringTypeGeneric(Metalama.Framework.Code.IMemberOrNamedType)">
      <summary>
            Returns <c>true</c> if the current declaration, or any the declaring type, is generic.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.GetBase(Metalama.Framework.Code.IMemberOrNamedType)">
      <summary>
            Gets the base type of a type or the base member of an overridden member, if any.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.WithTypeArguments(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.IType[])">
      <summary>
            Constructs a generic instance of an <see cref="T:Metalama.Framework.Code.INamedType" />, with type arguments given as <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.ForTypeInstance(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType)">
      <summary>
            Returns a representation of the current nested <see cref="T:Metalama.Framework.Code.INamedType" />, but for a different generic instance
            of the declaring type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.ForTypeInstance(Metalama.Framework.Code.IField,Metalama.Framework.Code.INamedType)">
      <summary>
            Returns a representation of the current <see cref="T:Metalama.Framework.Code.IField" />, but for a different generic instance
            of the declaring type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.ForTypeInstance(Metalama.Framework.Code.IMethod,Metalama.Framework.Code.INamedType)">
      <summary>
            Returns a representation of the current <see cref="T:Metalama.Framework.Code.IMethod" />, but for a different generic instance
            of the declaring type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.ForTypeInstance(Metalama.Framework.Code.IProperty,Metalama.Framework.Code.INamedType)">
      <summary>
            Returns a representation of the current <see cref="T:Metalama.Framework.Code.IProperty" />, but for a different generic instance
            of the declaring type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.ForTypeInstance(Metalama.Framework.Code.IEvent,Metalama.Framework.Code.INamedType)">
      <summary>
            Returns a representation of the current <see cref="T:Metalama.Framework.Code.IEvent" />, but for a different generic instance
            of the declaring type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.GenericExtensions.ForTypeInstance(Metalama.Framework.Code.IConstructor,Metalama.Framework.Code.INamedType)">
      <summary>
            Returns a representation of the current <see cref="T:Metalama.Framework.Code.IConstructor" />, but for a different generic instance
            of the declaring type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IAnnotation">
      <summary>
            A non-generic base interface for the generic <see cref="T:Metalama.Framework.Code.IAnnotation`1" />. You should always implement the generic interface.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IAnnotation`1">
      <summary>
            An annotation is an arbitrary but serializable object that can then be retrieved
            using the <see cref="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetAnnotations``1" /> method of the <see cref="M:Metalama.Framework.Code.DeclarationExtensions.Enhancements``1(``0)" /> object.
            Annotations are a way of communication between aspects or classes of aspects.
            </summary>
      <typeparam name="T">The type of declarations to which the annotation can be added.</typeparam>
    </member>
    <member name="T:Metalama.Framework.Code.IAssembly">
      <summary>
            Represents an assembly (typically a reference assembly).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssembly.GlobalNamespace">
      <summary>
            Gets the global namespace (i.e. the one with an empty name).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssembly.IsExternal">
      <summary>
            Gets a value indicating whether the assembly represents a reference (<c>true</c>), or the project being built (<c>false</c>).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssembly.Identity">
      <summary>
            Gets the assembly identity.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssembly.Types">
      <summary>
            Gets the list of types declared in this assembly, in all namespaces, but not the nested types.
            In case of partial compilations (see <see cref="P:Metalama.Framework.Code.ICompilation.IsPartial" />), this collection only contain the types in the current
            partial compilation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssembly.AllTypes">
      <summary>
            Gets the list of types declared in this assembly, in all namespaces, including recursively all nested types.
            In case of partial compilations (see <see cref="P:Metalama.Framework.Code.ICompilation.IsPartial" />), this collection only contain the types in the current
            partial compilation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IAssembly.AreInternalsVisibleFrom(Metalama.Framework.Code.IAssembly)">
      <summary>
            Gets a value indicating whether <c>internal</c> members of the current assembly are accessible from a given assembly. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IAssemblyIdentity">
      <summary>
            Represents an assembly identity, used in project references.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.Name">
      <summary>
            Gets the assembly name.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.Version">
      <summary>
            Gets the assembly version.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.CultureName">
      <summary>
            Gets the assembly culture, or an empty string if the culture is neutral.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.PublicKey">
      <summary>
            Gets the full public key, or an empty array.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.PublicKeyToken">
      <summary>
            Gets the public key token, or an empty array.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.IsStrongNamed">
      <summary>
            Gets a value indicating whether the assembly has either a <see cref="P:Metalama.Framework.Code.IAssemblyIdentity.PublicKey" /> or a <see cref="P:Metalama.Framework.Code.IAssemblyIdentity.PublicKeyToken" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAssemblyIdentity.HasPublicKey">
      <summary>
            Gets a value indicating whether the assembly has a full <see cref="P:Metalama.Framework.Code.IAssemblyIdentity.PublicKey" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IAttribute">
      <summary>
            Represent a custom attributes.
            </summary>
      <seealso cref="T:Metalama.Framework.Code.AttributeExtensions" />
    </member>
    <member name="P:Metalama.Framework.Code.IAttribute.ContainingDeclaration">
      <summary>
            Gets the declaration that owns the custom attribute.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IAttributeData">
      <summary>
            Represent the members of a custom attribute, but not its relationship to the containing declaration.
            </summary>
      <remarks>
            Values of <see cref="P:Metalama.Framework.Code.IAttributeData.ConstructorArguments" /> and <see cref="P:Metalama.Framework.Code.IAttributeData.NamedArguments" /> are represented as:
            <list type="bullet"><item>Primitive types as themselves (e.g. int as int, string as string).</item><item>Enums as their underlying type.</item><item><see cref="T:System.Type" /> as <see cref="T:Metalama.Framework.Code.IType" />.</item><item>Arrays as <c>IReadOnlyList&lt;object&gt;</c>.</item></list></remarks>
    </member>
    <member name="P:Metalama.Framework.Code.IAttributeData.Type">
      <summary>
            Gets the custom attribute type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAttributeData.Constructor">
      <summary>
            Gets the constructor to be used to instantiate the custom attribute.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAttributeData.ConstructorArguments">
      <summary>
            Gets the parameters passed to the <see cref="P:Metalama.Framework.Code.IAttributeData.Constructor" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IAttributeData.NamedArguments">
      <summary>
            Gets the named arguments (either fields or properties) of the attribute.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ICompilation">
      <summary>
            Represents a set of types compiled together. See also <see cref="T:Metalama.Framework.Project.IProject" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilation.Project">
      <summary>
            Gets information about the project from which the compilation was created.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilation.ManagedResources">
      <summary>
            Gets the list of managed resources in the current compilation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilation.Comparers">
      <summary>
            Gets a equality comparers that can be used with declarations of this compilation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ICompilation.GetDerivedTypes(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Gets the set of types, in the current compilation, that are derived from a given base type (given as an <see cref="T:Metalama.Framework.Code.INamedType" />).
            </summary>
      <param name="baseType">The base type.</param>
      <param name="options">Options that determine whether the search should be deep or shallow.</param>
    </member>
    <member name="M:Metalama.Framework.Code.ICompilation.GetDerivedTypes(System.Type,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Gets the set of types, in the current compilation, that are derived from a given base type (given as a <see cref="T:System.Type" />).
            </summary>
      <param name="baseType">The base type.</param>
      <param name="options">Options that determine whether the search should be deep or shallow.</param>
    </member>
    <member name="M:Metalama.Framework.Code.ICompilation.GetAllAttributesOfType(Metalama.Framework.Code.INamedType,System.Boolean)">
      <summary>
            Gets all attributes of a given type in the current compilation, where the attribute type is given as an <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
      <param name="type">The attribute type.</param>
      <param name="includeDerivedTypes">A value indicating whether attributes of types derived from <paramref name="type" /> should be returned as well.</param>
      <returns>A list of attributes.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.ICompilation.GetAllAttributesOfType(System.Type,System.Boolean)">
      <summary>
            Gets all attributes of a given type in the current compilation, where the attribute type is given as a <see cref="T:System.Type" />.
            </summary>
      <param name="type">The attribute type.</param>
      <param name="includeDerivedTypes">A value indicating whether attributes of types derived from <paramref name="type" /> should be returned as well.</param>
      <returns>A list of attributes.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilation.IsPartial">
      <summary>
            Gets a value indicating whether the current compilation is partial, i.e. incomplete. Metalama uses partial compilations
            at design time, when only the closure of modified types are being incrementally recompiled.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilation.Cache">
      <summary>
            Gets a service that caches declarations of the current compilation. It is typically used to cache often-used declarations
            across aspect instances.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilation.Factory">
      <summary>
            Gets a service that allows to create declaration and type instances for the current <see cref="T:Metalama.Framework.Code.ICompilation" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ICompilationElement">
      <summary>
            Exposes a <see cref="P:Metalama.Framework.Code.ICompilationElement.Compilation" /> property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilationElement.Compilation">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.ICompilation" /> to which this type belongs (which does not mean that the type is declared
            by the main project of the compilation).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ICompilationElement.DeclarationKind">
      <summary>
            Gets the kind of declaration.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IConstructor">
      <summary>
            Represents an instance constructor or a static constructor.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IConstructor.IsPrimary">
      <summary>
            Gets a value indicating whether this constructor is the primary constructor of the type.
            </summary>
      <remarks>
            Primary constructors are recognized only for the current compilation.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.IConstructor.InitializerKind">
      <summary>
            Gets a <see cref="T:Metalama.Framework.Code.ConstructorInitializerKind" /> that specifies the initializer semantics of the constructor.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IConstructor.ToConstructorInfo">
      <summary>
            Gets a <see cref="T:System.Reflection.ConstructorInfo" /> that represents the current constructor at run time.
            </summary>
      <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.IConstructor.Definition">
      <summary>
            Gets the definition of the constructor. If the current declaration is a constructor of
            a generic type instance, this returns the constructor in the generic type definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IDeclaration">
      <summary>
            Represent a declaration.
            </summary>
      <remarks>
            The <see cref="T:Metalama.Framework.Code.IDeclaration" /> interface implements <see cref="T:System.IEquatable`1" />. The implementation uses the <see cref="P:Metalama.Framework.Code.Comparers.ICompilationComparers.Default" /> comparer.
            To use a different comparer, choose a different comparer from <see cref="T:Metalama.Framework.Code.IDeclaration" />.<see cref="P:Metalama.Framework.Code.ICompilationElement.Compilation" />.<see cref="P:Metalama.Framework.Code.ICompilation.Comparers" />.
            </remarks>
      <seealso cref="T:Metalama.Framework.Code.DeclarationExtensions" />
    </member>
    <member name="M:Metalama.Framework.Code.IDeclaration.ToRef">
      <summary>
            Gets a reference to the compilation, which can be used to identify the current declaration
            in a different revision of the compilation. The reference object is compile-time serializable. It is guaranteed to
            be deserializable in a different process, even with a different version of Metalama.
            </summary>
      <returns></returns>
    </member>
    <member name="M:Metalama.Framework.Code.IDeclaration.ToSerializableId">
      <summary>
            Gets a serializable identifier for the current declaration. This identifier is guaranteed to
            be deserializable in a different process, even with a different version of Metalama.
            </summary>
      <seealso cref="M:Metalama.Framework.Code.IDeclaration.ToRef" />
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.DeclaringAssembly">
      <summary>
            Gets the declaring assembly, which can be the current <see cref="P:Metalama.Framework.Code.ICompilationElement.Compilation" />
            or a reference assembly.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.Origin">
      <summary>
            Gets the origin of the current declaration.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.ContainingDeclaration">
      <summary>
            Gets the containing declaration, such as a <see cref="T:Metalama.Framework.Code.INamedType" /> for nested
            types or for methods. For non-nested types, returns the containing assembly
            (and not the namespace, use <see cref="P:Metalama.Framework.Code.INamedType.ContainingNamespace" /> for that).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.Attributes">
      <summary>
            Gets the collection of custom attributes on the declaration.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.IsImplicitlyDeclared">
      <summary>
            Gets a value indicating whether the member is implicitly declared, i.e. declared without being represented in source code.
            Returns <c>false</c> if it is explicitly declared in code.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.Depth">
      <summary>
            Gets the depth of the current declaration in the code model. The value of the <see cref="P:Metalama.Framework.Code.IDeclaration.Depth" /> property has no absolute meaning,
            only a relative one, i.e. it is only relevant when comparing the depth of two declarations. A declaration has always a greater depth
            than the declaration in which it is contained. A type has always a greater depths than the base it derives from or the interfaces
            it implements.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.BelongsToCurrentProject">
      <summary>
            Gets a value indicating whether the current declaration is declared to the current project. It returns <c>false</c> for declarations
            declared in referenced projects or assemblies.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.Sources">
      <summary>
            Gets the set of syntax nodes of the source code that declare the current declaration, or an empty
            set if the current declaration is not backed by source code.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclaration.GenericContext">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.IGenericContext" /> for the current declaration.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IDeclarationCache">
      <summary>
            A service that caches declarations of the current compilation. It is typically used to cache often-used declarations
            across aspect instances.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IDeclarationCache.GetOrAdd``1(System.Func{Metalama.Framework.Code.ICompilation,``0})">
      <summary>
            Gets an item from the cache or computes it and add its.
            </summary>
      <param name="func">The delegate that computes the item. The cache key is the <see cref="T:System.Reflection.MethodInfo" /> of this delegate.
            It is essential that the implementation of this delegate is "static", i.e. has no reference to anything else than the <see cref="T:Metalama.Framework.Code.ICompilation" />
            it is provided with. </param>
      <typeparam name="T">The kind of cached item.</typeparam>
    </member>
    <member name="T:Metalama.Framework.Code.IDeclarationFactory">
      <summary>
            Allows to get instances of the <see cref="T:Metalama.Framework.Code.IType" /> interface or to test for type equality or inheritance.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IDeclarationFactory.GetTypeByReflectionName(System.String)">
      <summary>
            Get type based on its full name, as used in reflection.
            </summary>
      <remarks>
        <para>
            For nested types, this means using <c>+</c>, e.g. to get <see cref="T:System.Environment.SpecialFolder" />, use <c>System.Environment+SpecialFolder</c>.
            </para>
        <para>
            For generic type definitions, this requires using <c>`</c>, e.g. to get <c>List&lt;T&gt;</c>, use <c>System.Collections.Generic.List`1</c>.
            </para>
        <para>
            Constructed generic types (e.g. <c>List&lt;int&gt;</c>) are not supported, for those, use <see cref="M:Metalama.Framework.Code.GenericExtensions.WithTypeArguments(Metalama.Framework.Code.IMethod,Metalama.Framework.Code.IType[])" />.
            </para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.IDeclarationFactory.GetTypeByReflectionType(System.Type)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.IType" /> given a reflection <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IDeclarationFactory.GetSpecialType(Metalama.Framework.Code.SpecialType)">
      <summary>
            Gets a <see cref="T:Metalama.Framework.Code.INamedType" /> representing a given <see cref="T:Metalama.Framework.Code.SpecialType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IDeclarationFactory.GetDeclarationFromId(Metalama.Framework.Code.SerializableDeclarationId)">
      <summary>
            Gets a declaration from a serialized identifier generated by <see cref="M:Metalama.Framework.Code.IRef.ToSerializableId" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IDeclarationOrigin">
      <summary>
            Represents the origin of the code, i.e. the artefact or function created the declaration.
            </summary>
      <seealso cref="T:Metalama.Framework.Code.IAspectDeclarationOrigin" />
    </member>
    <member name="P:Metalama.Framework.Code.IDeclarationOrigin.Kind">
      <summary>
            Gets the kind of origin.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IDeclarationOrigin.IsCompilerGenerated">
      <summary>
            Gets a value indicating whether the declaration or its parent has an <see cref="T:System.Runtime.CompilerServices.CompilerGeneratedAttribute" /> regardless of the origin <see cref="P:Metalama.Framework.Code.IDeclarationOrigin.Kind" />.
            This property is currently <c>false</c> for declarations introduced by aspects because Metalama does not add the <see cref="T:System.Runtime.CompilerServices.CompilerGeneratedAttribute" />
            to introduced declarations. Check the <see cref="P:Metalama.Framework.Code.IDeclarationOrigin.Kind" /> property to skip declarations added by aspects.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IDisplayable">
      <summary>
            Defines a method <see cref="M:Metalama.Framework.Code.IDisplayable.ToDisplayString(Metalama.Framework.Code.CodeDisplayFormat,Metalama.Framework.Code.CodeDisplayContext)" /> that renders the current declaration into a human-readable
            string.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IDisplayable.ToDisplayString(Metalama.Framework.Code.CodeDisplayFormat,Metalama.Framework.Code.CodeDisplayContext)">
      <summary>
            Renders the current declaration into a human-readable string.
            </summary>
      <param name="format">Reserved for future use. Specifies formatting options.</param>
      <param name="context">Reserved for future use. Specifies the context in which the string must be displayed. This allow to abbreviate a few pieces of information.</param>
      <returns>A human-readable string for the current declaration.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.IEvent">
      <summary>
            Represent an event.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.Type">
      <summary>
            Gets the type of the event, i.e. the type of the delegate.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.AddMethod">
      <summary>
            Gets the method implementing the <c>add</c> semantic. In case of field-like events, this property returns
            an object that does not map to source code but allows to add aspects and advice as with a normal method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.RemoveMethod">
      <summary>
            Gets the method implementing the <c>remove</c> semantic. In case of field-like events, this property returns
            an object that does not map to source code but allows to add aspects and advice as with a normal method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.RaiseMethod">
      <summary>
            Gets an object that represents the <c>raise</c> semantic and allows to add aspects and advice
            as with a normal method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.OverriddenEvent">
      <summary>
            Gets the base event that is overridden by the current event.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.ExplicitInterfaceImplementations">
      <summary>
            Gets a list of interface events this event explicitly implements.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.Definition">
      <summary>
            Gets the definition of the event. If the current declaration is an event of
            a generic type instance, this returns the event in the generic type definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IEvent.ToEventInfo">
      <summary>
            Gets an <see cref="T:System.Reflection.EventInfo" /> that represents the current event at run time.
            </summary>
      <returns>An <see cref="T:System.Reflection.EventInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.IEvent.InitializerExpression">
      <summary>
            Gets the initializer expression (i.e. the expression at the right hand of the equal sign) of the field-like event, if any.
            When the event is defined in source code, this property returns an <see cref="T:Metalama.Framework.Code.ISourceExpression" />, which
            exposes a <see cref="T:Metalama.Framework.Code.TypedConstant" /> when possible.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IExpression">
      <summary>
            A compile-time representation of a run-time expression.
            To create an expression, use <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory" /> or <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" />. Note that
            <see cref="T:Metalama.Framework.Code.IField" />, <see cref="T:Metalama.Framework.Code.IProperty" /> and <see cref="T:Metalama.Framework.Code.IParameter" /> also implement the <see cref="T:Metalama.Framework.Code.IExpression" /> interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IExpression.IsAssignable">
      <summary>
            Gets a value indicating whether the <see cref="P:Metalama.Framework.Code.IExpression.Value" /> can be set.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IExpression.Value">
      <summary>
            Gets syntax for the current <see cref="T:Metalama.Framework.Code.IExpression" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IField">
      <summary>
            Represents a field. Note that fields can be promoted to properties by aspects.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IField.ConstantValue">
      <summary>
            Gets the value of the field, if the field is a <c>const</c>. Not to be confused with the <see cref="P:Metalama.Framework.Code.IFieldOrProperty.InitializerExpression" />,
            which is available even if the field is not <c>const</c>, but only when the field is defined in source code (as opposed to being defined
            in a referenced assembly).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IField.Definition">
      <summary>
            Gets the definition of the field. If the current declaration is a field of
            a generic type instance, this returns the field in the generic type definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IField.OverridingProperty">
      <summary>
            Gets the property that this field has been overridden into. The opposite side of this relationship is the <see cref="P:Metalama.Framework.Code.IProperty.OriginalField" />
            of the <see cref="T:Metalama.Framework.Code.IProperty" /> interface.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IFieldOrProperty">
      <summary>
            A base interface for <see cref="T:Metalama.Framework.Code.IField" /> and <see cref="T:Metalama.Framework.Code.IProperty" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IFieldOrProperty.IsAutoPropertyOrField">
      <summary>
            Gets a value indicating whether the declaration is an auto-property or a field, or <c>null</c> if the
            implementation of the property cannot be determined, for instance for properties in a referenced assembly.
            </summary>
      <remarks>
            When an automatic property has been overridden, this property will still return <c>true</c>, even if the actual
            property implementation no longer corresponds to the one of an automatic property.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.IFieldOrProperty.ToFieldOrPropertyInfo">
      <summary>
            Gets a <see cref="T:Metalama.Framework.RunTime.FieldOrPropertyInfo" /> that represents the current field or property at run time.
            </summary>
      <returns>A <see cref="T:Metalama.Framework.RunTime.FieldOrPropertyInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.IFieldOrProperty.IsRequired">
      <summary>
            Gets a value indicating whether the field or property is <c>required</c>, i.e. it must be initialized
            when an instance of the declaring type is initialized.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IFieldOrProperty.InitializerExpression">
      <summary>
            Gets the initializer expression (i.e. the expression at the right hand of the equal sign), if any.
            When the field or property is defined in source code, this property returns an <see cref="T:Metalama.Framework.Code.ISourceExpression" />, which
            exposes a <see cref="T:Metalama.Framework.Code.TypedConstant" /> when possible.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IFieldOrPropertyOrIndexer">
      <summary>
            A base interface for <see cref="T:Metalama.Framework.Code.IProperty" />, <see cref="T:Metalama.Framework.Code.IField" /> and <see cref="T:Metalama.Framework.Code.IIndexer" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IFieldOrPropertyOrIndexer.Writeability">
      <summary>
            Gets writeability of the field, property or indexer, i.e. the situations in which it can be written.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IFieldOrPropertyOrIndexer.GetMethod">
      <summary>
            Gets the property getter, or <c>null</c> if the property is write-only. In case of automatic properties, this property returns
            an object that does not map to source code but allows to add aspects and advice as with a normal method. In case of fields,
            this property returns a pseudo-method that can be the target of aspects and advice, as if the field were a property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IFieldOrPropertyOrIndexer.SetMethod">
      <summary>
            Gets the property getter, or <c>null</c> if the property is read-only. In case of automatic properties, this property returns
            an object that does not map to source code but allows to add aspects and advice as with a normal method. In case of fields,
            this property returns a pseudo-method that can be the target of aspects and advice, as if the field were a property.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IGeneric">
      <summary>
            An interface, common to <see cref="T:Metalama.Framework.Code.INamedType" /> and <see cref="T:Metalama.Framework.Code.IMethod" />, that represents a generic declaration, i.e. a declaration
            with type parameters. 
            </summary>
      <remarks>
            In Metalama, and unlike <c>System.Reflection</c>, generic types and methods are always fully bound. In generic declarations,
            such as in (<c>typeof(List&lt;&gt;)</c>, type parameters are bound to themselves, i.e. the content of the <see cref="P:Metalama.Framework.Code.IGeneric.TypeArguments" /> and <see cref="P:Metalama.Framework.Code.IGeneric.TypeParameters" />
            properties are identical.
            </remarks>
      <seealso cref="T:Metalama.Framework.Code.GenericExtensions" />
    </member>
    <member name="P:Metalama.Framework.Code.IGeneric.TypeParameters">
      <summary>
            Gets the generic parameters of the current type or method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IGeneric.TypeArguments">
      <summary>
            Gets the generic type arguments of the current type or method, which are the type values
            applied to the <see cref="P:Metalama.Framework.Code.IGeneric.TypeParameters" /> of the current type. The number of items in this list is always the same
            as in <see cref="P:Metalama.Framework.Code.IGeneric.TypeParameters" />. 
            </summary>
      <remarks>
            When reflecting a generic declaration, i.e. with unbound type parameters, the content
            of this collection is identical to <see cref="P:Metalama.Framework.Code.IGeneric.TypeParameters" />. That is, there is no such thing as an unbound generic declaration
            in Metalama because generic declarations are bound to their parameters.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.IGeneric.IsGeneric">
      <summary>
            Gets a value indicating whether this member has type parameters, regardless the fact that the containing type, if any, is generic.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IGeneric.IsCanonicalGenericInstance">
      <summary>
            Gets a value indicating whether all type parameters are bound to themselves, i.e. if the content of <see cref="P:Metalama.Framework.Code.IGeneric.TypeArguments" /> and <see cref="P:Metalama.Framework.Code.IGeneric.TypeParameters" /> are equal.
            This property returns <c>true</c> if the current declaration has no generic argument. For generic methods, this property returns <c>false</c> if the declaring type is generic but is not a canonical generic instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IGenericContext">
      <summary>
            Represents a context in which type parameters are mapped to their values.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IGenericContext.IsEmptyOrIdentity">
      <summary>
            Gets a value indicating whether the current context contains any non-trivial mapping.
            This value is <c>true</c> if there is no type parameter in the context of the current declaration
            or if the context is unbound, i.e. in the context of a generic type definition.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IHasAccessors">
      <summary>
            A base interface for <see cref="T:Metalama.Framework.Code.IProperty" /> and <see cref="T:Metalama.Framework.Code.IEvent" />. Exposes <see cref="M:Metalama.Framework.Code.IHasAccessors.GetAccessor(Metalama.Framework.Code.MethodKind)" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IHasAccessors.GetAccessor(Metalama.Framework.Code.MethodKind)">
      <summary>
            Gets the accessor for a given <see cref="T:Metalama.Framework.Code.MethodKind" />, or <c>null</c> if the member does not define
            an accessor of this kind.
            </summary>
      <param name="methodKind">
        <see cref="F:Metalama.Framework.Code.MethodKind.PropertyGet" />, <see cref="F:Metalama.Framework.Code.MethodKind.PropertySet" />,
            <see cref="F:Metalama.Framework.Code.MethodKind.EventAdd" />, <see cref="F:Metalama.Framework.Code.MethodKind.EventRemove" /> or <see cref="F:Metalama.Framework.Code.MethodKind.EventRaise" />.</param>
      <returns></returns>
    </member>
    <member name="P:Metalama.Framework.Code.IHasAccessors.Accessors">
      <summary>
            Gets the list of accessors defined by the current event or property.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IHasParameters">
      <summary>
            Represents a method, constructor, or indexer.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IHasParameters.Parameters">
      <summary>
            Gets the list of parameters of the current method (but not the return parameter).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IHasType">
      <summary>
            Exposes a <see cref="P:Metalama.Framework.Code.IHasType.Type" /> property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IHasType.Type">
      <summary>
            Gets the type of the expression, member, or parameter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IHasType.RefKind">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.RefKind" /> of the expression, member, or parameter
            (i.e. <see cref="F:Metalama.Framework.Code.RefKind.Ref" />, <see cref="F:Metalama.Framework.Code.RefKind.Out" />, ...).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IIndexer">
      <summary>
            Represents an indexer, i.e. a <c>this[*]</c> property.
            </summary>
      <seealso cref="T:Metalama.Framework.Code.IProperty" />
    </member>
    <member name="P:Metalama.Framework.Code.IIndexer.ExplicitInterfaceImplementations">
      <summary>
            Gets a list of interface properties this property explicitly implements.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IIndexer.OverriddenIndexer">
      <summary>
            Gets the base property that is overridden by the current property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IIndexer.Definition">
      <summary>
            Gets the definition of the indexer. If the current declaration is an indexer of
            a generic type instance, this returns the indexer in the generic type definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IManagedResource">
      <summary>
            Represents a managed resource.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IMember">
      <summary>
            Base interface for <see cref="T:Metalama.Framework.Code.IMethod" />, <see cref="T:Metalama.Framework.Code.IFieldOrProperty" />, <see cref="T:Metalama.Framework.Code.IEvent" />, but not <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMember.IsVirtual">
      <summary>
            Gets a value indicating whether the member is <c>virtual</c>.
            </summary>
      <seealso cref="M:Metalama.Framework.Code.MemberExtensions.IsOverridable(Metalama.Framework.Code.IMember)" />
    </member>
    <member name="P:Metalama.Framework.Code.IMember.IsAsync">
      <summary>
            Gets a value indicating whether the member is <c>async</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMember.IsOverride">
      <summary>
            Gets a value indicating whether the member is <c>override</c>.
            </summary>
      <seealso cref="M:Metalama.Framework.Code.MemberExtensions.IsOverridable(Metalama.Framework.Code.IMember)" />
    </member>
    <member name="P:Metalama.Framework.Code.IMember.IsExtern">
      <summary>
            Gets a value indicating whether the member has an external implementation, i.e. has the <c>extern</c> modifier.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMember.IsExplicitInterfaceImplementation">
      <summary>
            Gets a value indicating whether the member is an explicit implementation of an interface member.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMember.HasImplementation">
      <summary>
            Gets a value indicating whether the member has an implementation or is only a definition without a body.
            </summary>
      <remarks>
            Members without implementation are, for example, <c>abstract</c> members, <c>extern</c> methods, <c>partial</c> members without implementation part or <c>const</c> fields. 
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.IMember.DeclaringType">
      <summary>
            Gets the type containing the current member.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMember.Definition">
      <summary>
            Gets the definition of the member. If the current declaration is a generic method instance or a member of
            a generic type instance, this returns the generic definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IMemberOrNamedType">
      <summary>
            Base interface for <see cref="T:Metalama.Framework.Code.IMethod" />, <see cref="T:Metalama.Framework.Code.IFieldOrPropertyOrIndexer" />, <see cref="T:Metalama.Framework.Code.IEvent" />, and <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.Accessibility">
      <summary>
            Gets the member accessibility (or visibility), i.e. <see cref="F:Metalama.Framework.Code.Accessibility.Private" />, <see cref="F:Metalama.Framework.Code.Accessibility.Protected" />
            and so on.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.IsStatic">
      <summary>
            Gets a value indicating whether the member is <c>static</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.IsSealed">
      <summary>
            Gets a value indicating whether the member is <c>sealed</c>.
            </summary>
      <seealso cref="M:Metalama.Framework.Code.MemberExtensions.IsOverridable(Metalama.Framework.Code.IMember)" />
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.IsNew">
      <summary>
            Gets a value indicating whether the member hides another member defined in base types. When <c>true</c>, this is equivalent to <c>new</c> keyword being <i>expected</i> in the source code although this property will return <c>true</c> even when the <c>new</c> keyword is not present but expected.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.DeclaringType">
      <summary>
            Gets the type containing the current member, or <c>null</c> if the current member is not contained
            within a type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IMemberOrNamedType.ToMemberInfo">
      <summary>
            Gets a <see cref="T:System.Reflection.MemberInfo" /> that represents the current member at run time.
            </summary>
      <returns>A <see cref="T:System.Reflection.MemberInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.ExecutionScope">
      <summary>
            Gets a value indicating whether the declaration executes at compile time, at run time, or both.
            </summary>
      <seealso cref="T:Metalama.Framework.Aspects.CompileTimeAttribute" />
      <seealso cref="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute" />
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.Definition">
      <summary>
            Gets the definition of the member or type. If the current declaration is a generic type instance, a generic method instance, or a member of
            a generic type instance, this returns the generic definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMemberOrNamedType.IsPartial">
      <summary>
            Gets a value indicating whether the type or member is marked as <c>partial</c> in source code. 
            </summary>
      <remarks>
            To check whether a partial member has an implementation, check the <see cref="P:Metalama.Framework.Code.IMember.HasImplementation" /> property.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.IMethod">
      <summary>
            Represents a method, but not a constructor.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.MethodKind">
      <summary>
            Gets the kind of method (such as <see cref="F:Metalama.Framework.Code.MethodKind.Default" /> or <see cref="F:Metalama.Framework.Code.MethodKind.PropertyGet" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.ReturnParameter">
      <summary>
            Gets an object representing the method return type and custom attributes, or  <c>null</c> for methods that don't have return types: constructors and finalizers.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.ReturnType">
      <summary>
            Gets the method return type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.OverriddenMethod">
      <summary>
            Gets the base method that is overridden by the current method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.ExplicitInterfaceImplementations">
      <summary>
            Gets a list of interface methods that this method explicitly implements.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IMethod.ToMethodInfo">
      <summary>
            Gets a <see cref="T:System.Reflection.MethodInfo" /> that represents the current method at run time.
            </summary>
      <returns>A <see cref="T:System.Reflection.MethodInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.DeclaringMember">
      <summary>
            Gets the parent property or event when the current <see cref="T:Metalama.Framework.Code.IMethod" /> represents a property or event accessor, otherwise <c>null</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.IsReadOnly">
      <summary>
            Gets a value indicating whether the method is <c>readonly</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.OperatorKind">
      <summary>
            Gets a value indicating the type of operator the methods represents.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IMethod.Definition">
      <summary>
            Gets the definition of the method. If the current method a generic method instance or a method of
            a generic type instance, this returns the generic definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IMethodBase">
      <summary>
            Represents a method or a constructor.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IMethodBase.ToMethodBase">
      <summary>
            Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the current method or constructor at run time.
            </summary>
      <returns>A <see cref="T:System.Reflection.MethodBase" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.INamedDeclaration.Name">
      <summary>
            Gets the declaration name. If the member is an <see cref="T:Metalama.Framework.Code.INamedType" /> or <see cref="T:Metalama.Framework.Code.INamespace" />, the <see cref="P:Metalama.Framework.Code.INamedDeclaration.Name" />
            property gets the short name of the type or namespace, without the parent namespace. See also <see cref="P:Metalama.Framework.Code.INamedType.ContainingNamespace" />
            and <see cref="P:Metalama.Framework.Code.INamespaceOrNamedType.FullName" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.INamedType">
      <summary>
            Represents a class, struct, interface, enum, or delegate.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.BaseType">
      <summary>
            Gets the type from which the current type derives.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllImplementedInterfaces">
      <summary>
            Gets the list of all interfaces (recursive) that the current type implements.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.ImplementedInterfaces">
      <summary>
            Gets the list of interfaces that the current type implements.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.ContainingNamespace">
      <summary>
            Gets the namespace of the current type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.NestedTypes">
      <summary>
            Gets the nested types of the current type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllTypes">
      <summary>
            Gets the list of nested types defined in the current type or inherited from the base types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Properties">
      <summary>
            Gets the list of properties defined in the current type, but not those inherited from the base types.
            Note that fields can be promoted to properties by aspects, so a source code field can be 
            represented in the <see cref="P:Metalama.Framework.Code.INamedType.Properties" /> collection instead of the <see cref="P:Metalama.Framework.Code.INamedType.Fields" />
            collection.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllProperties">
      <summary>
            Gets the list of properties defined in the current type or inherited from the base types.
            Note that fields can be promoted to properties by aspects, so a source code field can be 
            represented in the <see cref="P:Metalama.Framework.Code.INamedType.Properties" /> collection instead of the <see cref="P:Metalama.Framework.Code.INamedType.Fields" />
            collection. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Indexers">
      <summary>
            Gets the list of indexers defined in the current type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllIndexers">
      <summary>
            Gets the list of indexers defined in the current type or inherited from the base types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Fields">
      <summary>
            Gets the list of fields defined in the current type, but not those inherited from the base type.
            Note that fields can be promoted to properties by aspects, so a source code field can be 
            represented in the <see cref="P:Metalama.Framework.Code.INamedType.Properties" /> collection instead of the <see cref="P:Metalama.Framework.Code.INamedType.Fields" />
            collection.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllFields">
      <summary>
            Gets the list of fields defined in the current type or inherited from the base types.
            Note that fields can be promoted to properties by aspects, so a source code field can be 
            represented in the <see cref="P:Metalama.Framework.Code.INamedType.Properties" /> collection instead of the <see cref="P:Metalama.Framework.Code.INamedType.Fields" />
            collection. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.FieldsAndProperties">
      <summary>
            Gets the union of the <see cref="P:Metalama.Framework.Code.INamedType.Fields" /> and <see cref="P:Metalama.Framework.Code.INamedType.Properties" /> collections.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllFieldsAndProperties">
      <summary>
            Gets the union of the <see cref="P:Metalama.Framework.Code.INamedType.AllFields" /> and <see cref="P:Metalama.Framework.Code.INamedType.AllProperties" /> collections.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Events">
      <summary>
            Gets the list of events defined in the current type, but not those inherited from the base
            types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllEvents">
      <summary>
            Gets the list of events defined in the current type or inherited from the base types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Methods">
      <summary>
            Gets the list of methods defined in the current type, but not those inherited from the base
            type, and not constructors or the finalizer.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.AllMethods">
      <summary>
            Gets the list of methods defined in the current type or inherited from the base type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.PrimaryConstructor">
      <summary>
            Gets the primary constructor if it is defined, otherwise returns <c>null</c>.
            </summary>
      <remarks>
            Primary constructors are recognized only for the current compilation.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Constructors">
      <summary>
            Gets the list of constructors, including the implicit default constructor if any, but not the static constructor. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.StaticConstructor">
      <summary>
            Gets the static constructor.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Finalizer">
      <summary>
            Gets the finalizer of the type. For value types returns <c>null</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.IsReadOnly">
      <summary>
            Gets a value indicating whether the type is <c>readonly</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.IsRef">
      <summary>
            Gets a value indicating whether the type is a <c>ref</c> struct.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.INamedType.IsSubclassOf(Metalama.Framework.Code.INamedType)">
      <summary>
            Determines whether the type if subclass of the given class or interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.INamedType.TryFindImplementationForInterfaceMember(Metalama.Framework.Code.IMember,Metalama.Framework.Code.IMember@)">
      <summary>
            Finds the the implementation of the given interface member that is valid for this type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.Definition">
      <summary>
            Gets the type definition with unassigned type parameters. When the current <see cref="T:Metalama.Framework.Code.INamedType" /> is not a generic type instance,
            returns the current <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamedType.UnderlyingType">
      <summary>
            Gets the underlying type of an enum, the non-nullable type of a nullable reference type, or the current type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.INamespace">
      <summary>
            Represents a namespace inside the current compilation or an external assembly, according to the <see cref="P:Metalama.Framework.Code.IDeclaration.DeclaringAssembly" /> property.
            </summary>
      <remarks>
            At design time, namespaces of the current compilation can be partial, or incomplete. See <see cref="P:Metalama.Framework.Code.INamespace.IsPartial" /> for details.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.INamespace.IsGlobalNamespace">
      <summary>
            Gets a value indicating whether the current namespace represents the global (or root) namespace.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamespace.Namespaces">
      <summary>
            Gets the list of children namespaces of the current namespace the <see cref="P:Metalama.Framework.Code.IDeclaration.DeclaringAssembly" />.
            In case of partial compilations (see <see cref="P:Metalama.Framework.Code.INamespace.IsPartial" />), this collection only contain the namespaces in the current
            partial compilation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.INamespace.GetDescendant(System.String)">
      <summary>
            Gets a descendant of the current namespace.
            </summary>
      <param name="ns">Dot-separated name of the namespace relatively to the current namespace.</param>
    </member>
    <member name="P:Metalama.Framework.Code.INamespace.IsPartial">
      <summary>
            Gets a value indicating whether the current namespace is partial, i.e. incomplete. Metalama uses partial compilations
            at design time, when only the closure of modified types are being incrementally recompiled. In this scenario, namespaces
            of the current compilation are partial. Namespaces of external assemblies are never partial.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.INamespaceOrNamedType">
      <summary>
            Represents a namespace or a named type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamespaceOrNamedType.FullName">
      <summary>
            Gets the full name of the namespace or type, or an empty string if this is the global namespace.
            The separator for nested types is the dot, and there is no suffix for generic types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.INamespaceOrNamedType.Types">
      <summary>
            Gets the list of types defined in the current namespace or type. 
            </summary>
      <remarks>
            If the current object is an <see cref="T:Metalama.Framework.Code.INamedType" />,
            this is the collection of nested types. If the current object is an <see cref="T:Metalama.Framework.Code.INamespace" />, the collection only
            includes types inside the <see cref="P:Metalama.Framework.Code.IDeclaration.DeclaringAssembly" />. In case of partial compilations (see <see cref="P:Metalama.Framework.Code.INamespace.IsPartial" />),
            this collection only contain the types in the current partial compilation.
            </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.INamespaceOrNamedType.ContainingNamespace">
      <summary>
            Gets the parent namespace, or <c>null</c> if the current object is the global namespace
            (i.e. ig <see cref="P:Metalama.Framework.Code.INamespace.IsGlobalNamespace" /> is <c>true</c>).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Invokers.IConstructorInvoker">
      <summary>
            Allows invocation of the constructor.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IConstructorInvoker.Invoke(System.Object[])">
      <summary>
            Generates run-time code that invokes the current constructor with a given list of arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IConstructorInvoker.Invoke(System.Collections.Generic.IEnumerable{Metalama.Framework.Code.IExpression})">
      <summary>
            Generates run-time code that invokes the current constructor with a given list of argument expressions.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Invokers.IEventInvoker">
      <summary>
            Allows adding/removing delegates to/from events.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IEventInvoker.Add(System.Object)">
      <summary>
            Generates run-time code that adds a given handler to the event. By default, the target instance
            of the event is <c>this</c> unless the event is static, and the <c>base</c> implementation of the event is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IEventInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IEventInvoker.Remove(System.Object)">
      <summary>
            Generates run-time code that removes a given handler from the event. By default, the target instance
            of the event is <c>this</c> unless the event is static, and the <c>base</c> implementation of the event is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IEventInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IEventInvoker.Raise(System.Object[])">
      <summary>
            Generates run-time code that raises the current event with specified arguments. By default, the target instance
            of the event is <c>this</c> unless the event is static, and the <c>base</c> implementation of the event is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IEventInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IEventInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IEventInvoker" /> for the same event and target but with different options.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IEventInvoker.With(System.Object,Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IEventInvoker" /> for the same event but with a different target instance and optionally different options.
            </summary>
      <param name="target">The run-time expression that represents the target instance of the method. This expression cannot be <c>dynamic</c>.
            If you need to pass a <c>dynamic</c> expression, you have to explicitly cast it to <see cref="T:Metalama.Framework.Code.IExpression" />.
            </param>
      <param name="options"></param>
    </member>
    <member name="T:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker">
      <summary>
            Allows accessing the the value of fields or properties through the <see cref="P:Metalama.Framework.Code.IExpression.Value" /> property of
            the <see cref="T:Metalama.Framework.Code.IExpression" /> interface. By default, the target instance
            of the field or property is <c>this</c> unless the property is static, and the <c>base</c> implementation of the property is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker" /> for the same field or property and target but with different options.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker.With(System.Object,Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker" /> for the same field or property but with a different field or property and with different options.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Invokers.IIndexerInvoker">
      <summary>
            Allows accessing the value of indexers.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IIndexerInvoker.GetValue(System.Object[])">
      <summary>
            Generates run-time code that gets the value of the current indexer with specified arguments. By default, the target instance
            of the indexer is <c>this</c> unless the indexer is static, and the <c>base</c> implementation of the indexer is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IIndexerInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IIndexerInvoker.SetValue(System.Object,System.Object[])">
      <summary>
            Generates run-time code that sets the value of the current indexer with specified arguments. By default, the target instance
            of the indexer is <c>this</c> unless the indexer is static, and the <c>base</c> implementation of the indexer is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IIndexerInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
      <remarks>
            Note: the order of parameters is different than in C# code:
            e.g. <c>instance[args] = value</c> is <c>indexer.SetIndexerValue(instance, value, args)</c>.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IIndexerInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IIndexerInvoker" /> for the same index and target but with different options.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IIndexerInvoker.With(System.Object,Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IIndexerInvoker" /> for the same indexer but with a different field or property and with different options.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Invokers.IMethodInvoker">
      <summary>
            Allows invocation of the method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke(System.Object[])">
      <summary>
            Generates run-time code that invokes the current method with a given list of arguments. By default, the target instance
            of the method is <c>this</c> unless the method is static, and the <c>base</c> implementation of the method is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IMethodInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke(System.Collections.Generic.IEnumerable{Metalama.Framework.Code.IExpression})">
      <summary>
            Generates run-time code that invokes the current method with a given list of argument expressions. By default, the target instance
            of the method is <c>this</c> unless the method is static, and the <c>base</c> implementation of the method is invoked,
            i.e. the implementation before the current aspect layer. To change the default values, or to use the <c>?.</c> null-conditional operator,
            use the <see cref="M:Metalama.Framework.Code.Invokers.IMethodInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IMethodInvoker.With(Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IMethodInvoker" /> for the same method and target with different options.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.Invokers.IMethodInvoker.With(System.Object,Metalama.Framework.Code.Invokers.InvokerOptions)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.Invokers.IMethodInvoker" /> for the same method but with a different target instance and optionally different options.
            </summary>
      <param name="target">The run-time expression that represents the target instance of the method. This expression cannot be <c>dynamic</c>.
            If you need to pass a <c>dynamic</c> expression, you have to explicitly cast it to <see cref="T:Metalama.Framework.Code.IExpression" />.
            </param>
      <param name="options"></param>
    </member>
    <member name="T:Metalama.Framework.Code.Invokers.InvokerOptions">
      <summary>
            Options that influence the behavior of invokers, i.e. <see cref="T:Metalama.Framework.Code.Invokers.IMethodInvoker" />, <see cref="T:Metalama.Framework.Code.Invokers.IFieldOrPropertyInvoker" />,
            <see cref="T:Metalama.Framework.Code.Invokers.IEventInvoker" /> or <see cref="T:Metalama.Framework.Code.Invokers.IIndexerInvoker" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Invokers.InvokerOptions.Default">
      <summary>
            When the invoked member is the target member of the current template (i.e. <c>meta.Target.Declaration</c>), and when no target instance or type is explicitly specified,
            for the invoker, equivalent to <see cref="F:Metalama.Framework.Code.Invokers.InvokerOptions.Base" />. Otherwise, equivalent to <see cref="F:Metalama.Framework.Code.Invokers.InvokerOptions.Final" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Invokers.InvokerOptions.Current">
      <summary>
            Generates calls to the <i>current</i> implementation, i.e. after all overrides or introductions by the current aspect layer,
            but before any next aspect layer or any derived type. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Invokers.InvokerOptions.Base">
      <summary>
            Generates calls to the <i>base</i> implementation, i.e. before any override or introduction by the current aspect layer. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Invokers.InvokerOptions.Final">
      <summary>
            Causes the <i>final</i> implementation to be called, i.e. the implementation after all overrides by aspects
            and, if the member is <c>virtual</c>, by derived classes through the <c>override</c> keyword. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Invokers.InvokerOptions.OrderMask">
      <summary>
            Mask for bits that encode order values.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Invokers.InvokerOptions.NullConditional">
      <summary>
            Specifies that the null-conditional access operator (<c>?.</c> aka Elvis) has to be used instead of the dot operator. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IObjectCreationExpression">
      <summary>
            A compile-time representation of a run-time object creation expression.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IParameter">
      <summary>
            Represents a parameter of a method or property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IParameter.Index">
      <summary>
            Gets the parameter position, or <c>-1</c> for <see cref="P:Metalama.Framework.Code.IMethod.ReturnParameter" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IParameter.DefaultValue">
      <remarks>
            Gets the default value of the parameter, or  <c>default</c> if the parameter type is a struct and the default
            value of the parameter is the default value of the struct type.
            </remarks>
      <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
    </member>
    <member name="P:Metalama.Framework.Code.IParameter.IsParams">
      <summary>
            Gets a value indicating whether the parameter has the <see langword="params" /> modifier.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IParameter.IsThis">
      <summary>
            Gets a value indicating whether the parameter has the <see langword="this" /> modifier, meaning that the containing method is an extension method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IParameter.DeclaringMember">
      <summary>
            Gets the parent <see cref="T:Metalama.Framework.Code.IMethod" />, <see cref="T:Metalama.Framework.Code.IConstructor" /> or <see cref="T:Metalama.Framework.Code.IIndexer" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IParameter.ToParameterInfo">
      <summary>
            Gets a <see cref="T:System.Reflection.ParameterInfo" /> that represents the current parameter at run time.
            </summary>
      <returns>A <see cref="T:System.Reflection.ParameterInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.IProperty">
      <summary>
            Represents a property.
            </summary>
      <seealso cref="T:Metalama.Framework.Code.IIndexer" />
    </member>
    <member name="P:Metalama.Framework.Code.IProperty.ExplicitInterfaceImplementations">
      <summary>
            Gets a list of interface properties this property explicitly implements.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IProperty.OverriddenProperty">
      <summary>
            Gets the base property that is overridden by the current property.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IProperty.Definition">
      <summary>
            Gets the definition of the property. If the current declaration is a property of
            a generic type instance, this returns the property in the generic type definition. Otherwise, it returns the current instance.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IProperty.OriginalField">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.IField" /> from which the current property was generated. This property returns
            <c>null</c> in compilations in which the field has <i>already</i> been transformed into a property.
            It returns non-null only if the field is <i>being</i> transformed into a property.  The opposite side of this relationship is the
            <see cref="P:Metalama.Framework.Code.IField.OverridingProperty" /> of the <see cref="T:Metalama.Framework.Code.IProperty" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IPropertyOrIndexer.ToPropertyInfo">
      <summary>
            Gets a <see cref="T:System.Reflection.PropertyInfo" /> that represents the current property at run time.
            </summary>
      <returns>A <see cref="T:System.Reflection.PropertyInfo" /> that can be used only in run-time code.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.IRef">
      <summary>
            Represents a reference to an <see cref="T:Metalama.Framework.Code.IDeclaration" /> or <see cref="T:Metalama.Framework.Code.IType" />, which is valid across different compilation versions
            (i.e. <see cref="T:Metalama.Framework.Code.ICompilation" />) and, when serialized, across projects and processes.
            References can be resolved using <see cref="M:Metalama.Framework.Code.RefExtensions.GetTarget``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)" />.
            All objects implementing this interface also implement the stronly-typed <see cref="T:Metalama.Framework.Code.IRef`1" />.
            </summary>
      <remarks>
        <para>Use <see cref="T:Metalama.Framework.Code.Comparers.RefEqualityComparer`1" /> to compare instances of <see cref="T:Metalama.Framework.Code.IRef" />.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.IRef.ToSerializableId">
      <summary>
            Returns a string that uniquely identifies the declaration represented by the current reference. This identifier can then be resolved using <see cref="M:Metalama.Framework.Code.IDeclarationFactory.GetDeclarationFromId(Metalama.Framework.Code.SerializableDeclarationId)" />, even in
            a different process or with a different version of Metalama than the one that created the id.
            </summary>
      <returns>A string, or <c>null</c> if the current reference cannot be serialized to a public id.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.IRef.As``1">
      <summary>
            Changes the reference type. This method can be used in two scenarios: instead of a C# cast with durable references (see <see cref="P:Metalama.Framework.Code.IRef.IsDurable" />),
            or between <see cref="T:Metalama.Framework.Code.IField" /> and <see cref="T:Metalama.Framework.Code.IProperty" /> when a field is overridden into a property (see <see cref="P:Metalama.Framework.Code.IField.OverridingProperty" />
            and <see cref="P:Metalama.Framework.Code.IProperty.OriginalField" />).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IRef.IsDurable">
      <summary>
            Gets a value indicating whether the reference can be kept in memory without keeping a reference to the state of the project.
            Most references are bound to a specific state of the project. They are faster to resolve but prevent that specific project state to be garbage-collected.
            Durable references are slower to resolve but not cause a memory leak if they stay in memory for a long time.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IRef.GetTargetInterface(Metalama.Framework.Code.ICompilation,System.Type,Metalama.Framework.Code.IGenericContext,System.Boolean)">
      <summary>
            Gets the target of the reference for a given compilation, and specify the type of the interface to be returned.
            Normally, the extension methods <see cref="M:Metalama.Framework.Code.RefExtensions.GetTarget``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)" />
            or <see cref="M:Metalama.Framework.Code.RefExtensions.GetTargetOrNull``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)" />
            should be used instead of this one.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IRef`1">
      <summary>
            Represents a reference to an <see cref="T:Metalama.Framework.Code.IDeclaration" /> or <see cref="T:Metalama.Framework.Code.IType" />, which is valid across different compilation versions
            (i.e. <see cref="T:Metalama.Framework.Code.ICompilation" />) and, when serialized, across projects and processes. References can be resolved using
            <see cref="M:Metalama.Framework.Code.RefExtensions.GetTarget``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)" />.
            </summary>
      <typeparam name="T">The type of the target object of the declaration or type.</typeparam>
      <remarks>
        <para>Use <see cref="T:Metalama.Framework.Code.Comparers.RefEqualityComparer`1" /> to compare instances of <see cref="T:Metalama.Framework.Code.IRef" />.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.ISourceExpression">
      <summary>
            Represents an <see cref="T:Metalama.Framework.Code.IExpression" /> defined in source code, as opposed to a generated expression.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ISourceExpression.AsSyntaxNode">
      <summary>
            Gets the source Roslyn object representing the current expression.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ISourceExpression.AsString">
      <summary>
            Gets the string representing the current expression, with normalize whitespaces.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ISourceExpression.AsFullString">
      <summary>
            Gets the string representing the current expression, including original whitespaces.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ISourceExpression.AsTypedConstant">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.TypedConstant" /> corresponding to the current expression, or <c>null</c>
            if the current expression cannot be represented as a <see cref="T:Metalama.Framework.Code.TypedConstant" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IteratorInfo">
      <summary>
            Information about an iterator method, returned by the <see cref="M:Metalama.Framework.Code.MethodExtensions.GetIteratorInfo(Metalama.Framework.Code.IMethod)" /> extension method of <see cref="T:Metalama.Framework.Code.IMethod" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IteratorInfo.IsIteratorMethod">
      <summary>
            Gets a value indicating whether the method is an iterator (i.e., has a <c>yield return</c> or <c>yield break</c> statement).
            This property evaluates to <c>false</c> for methods that return an enumerable type but do not use <c>yield</c>,
            and <c>null</c> for methods that are not defined in the current project.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IteratorInfo.ItemType">
      <summary>
            Gets the type of items being enumerated (the <c>int</c> in <c>IEnumerable&lt;int&gt;</c>).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IteratorInfo.EnumerableKind">
      <summary>
            Gets the kind of enumerable (<see cref="F:Metalama.Framework.Code.EnumerableKind.IEnumerable" />, <see cref="F:Metalama.Framework.Code.EnumerableKind.IEnumerator" />,
            <see cref="F:Metalama.Framework.Code.EnumerableKind.IAsyncEnumerable" />, ...), regardless of whether the method is a yield-base iterator (see <see cref="P:Metalama.Framework.Code.IteratorInfo.IsIteratorMethod" />).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.IType">
      <summary>
            Represents a constructed type, for instance an array, a generic type instance, a pointer.
            A class, struct, enum or delegate are represented as an <see cref="T:Metalama.Framework.Code.INamedType" />, which
            derive from <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
      <remarks>
            The <see cref="T:Metalama.Framework.Code.IType" /> interface implements <see cref="T:System.IEquatable`1" />. The implementation uses the <see cref="P:Metalama.Framework.Code.Comparers.ICompilationComparers.Default" /> comparer.
            To use a different comparer, choose a different comparer from <see cref="T:Metalama.Framework.Code.IDeclaration" />.<see cref="P:Metalama.Framework.Code.ICompilationElement.Compilation" />.<see cref="P:Metalama.Framework.Code.ICompilation.Comparers" />.
            You can also use <see cref="M:Metalama.Framework.Code.IType.Equals(Metalama.Framework.Code.IType,Metalama.Framework.Code.Comparers.TypeComparison)" /> and specify a <see cref="T:Metalama.Framework.Code.Comparers.TypeComparison" />.
            </remarks>
      <seealso cref="T:Metalama.Framework.Code.TypeExtensions" />
    </member>
    <member name="P:Metalama.Framework.Code.IType.TypeKind">
      <summary>
            Gets the kind of type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IType.SpecialType">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.SpecialType" /> enumeration value for the current type. Provides a fast way to determine whether
            the current type is of a well-known type. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IType.ToType">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that represents the current type at run time.
            </summary>
      <returns>A <see cref="T:System.Type" /> that can be used only in run-time code.</returns>
    </member>
    <member name="P:Metalama.Framework.Code.IType.IsReferenceType">
      <summary>
            Gets a value indicating whether the type is a reference type. If the type is a generic parameter
            without a <c>struct</c>, <c>class</c> or similar constraint, this property evaluates to <c>null</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.IType.IsNullable">
      <summary>
            Gets the nullability of the type, or <c>null</c> if the type is a reference type but its nullability has not been analyzed or specified.
            This property returns <c>false</c> for normal value types and <c>true</c> for the <see cref="T:System.Nullable`1" /> type. Note that in
            case of nullable value types, the current type represents the <see cref="T:System.Nullable`1" /> type itself, and the inner value type
            is exposed as <see cref="P:Metalama.Framework.Code.INamedType.UnderlyingType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IType.Equals(Metalama.Framework.Code.SpecialType)">
      <summary>
            Determines whether the current type is equal to a well-known special type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IType.MakeArrayType(System.Int32)">
      <summary>
            Creates an array type whose element type is the current type.
            </summary>
      <param name="rank">Number of dimensions of the array.</param>
    </member>
    <member name="M:Metalama.Framework.Code.IType.MakePointerType">
      <summary>
            Creates a pointer type pointing at the current type.
            </summary>
      <returns></returns>
    </member>
    <member name="M:Metalama.Framework.Code.IType.ToNullable">
      <summary>
            Creates a nullable type from the current <see cref="T:Metalama.Framework.Code.IType" />. If the current type is already nullable, returns the current type.
            If the type is a value type, returns a <see cref="T:System.Nullable`1" /> of this type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.IType.ToNonNullable">
      <summary>
            Returns the non-nullable type from the current <see cref="T:Metalama.Framework.Code.IType" />. If the current type is a non-nullable reference type, returns the current type.
            If the current type is a <see cref="T:System.Nullable`1" />, i.e. a nullable value type, returns the underlying type.
            </summary>
      <remarks>
            Note that for non-value type type parameters, this method strips the nullable annotation, if any,
            which means it returns a type whose <see cref="P:Metalama.Framework.Code.IType.IsNullable" /> property returns <see langword="null" />.
            This is because C# has no way to express non-nullability for type parameters.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Code.ITypeParameter">
      <summary>
            Represents a generic parameter of a method or type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.Index">
      <summary>
            Gets the position of the generic parameter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.TypeConstraints">
      <summary>
            Gets the type constraints of the generic parameter.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.TypeKindConstraint">
      <summary>
            Gets the constraint on the kind of type, e.g. <see cref="F:Metalama.Framework.Code.TypeKindConstraint.Class" /> or <see cref="F:Metalama.Framework.Code.TypeKindConstraint.Struct" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.AllowsRefStruct">
      <summary>
            Gets a value indicating whether the generic parameter has the <c>allows ref struct</c> anti-constraint.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.Variance">
      <summary>
            Gets the kind variance: <see cref="F:Metalama.Framework.Code.VarianceKind.In" />, <see cref="F:Metalama.Framework.Code.VarianceKind.Out" /> or <see cref="F:Metalama.Framework.Code.VarianceKind.None" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.IsConstraintNullable">
      <summary>
            Gets a value indicating whether the <see cref="F:Metalama.Framework.Code.TypeKindConstraint.Class" /> constraint has the nullable annotation (?).
            This property returns <c>null</c> if the <see cref="P:Metalama.Framework.Code.ITypeParameter.TypeKindConstraint" /> has a different value than <see cref="F:Metalama.Framework.Code.TypeKindConstraint.Class" />
            or if the nullability of the generic parameter is not analyzed.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.HasDefaultConstructorConstraint">
      <summary>
            Gets a value indicating whether the generic parameter has the <c>new()</c> constraint.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.ITypeParameter.ResolvedType">
      <summary>
            Gets the concrete <see cref="T:Metalama.Framework.Code.IType" /> to which the type parameter is resolved, if the parent type or method
            is a generic instance. If it is a generic definition, returns the current instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.MemberExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Code.IMember" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.MemberExtensions.IsOverridable(Metalama.Framework.Code.IMember)">
      <summary>
            Determines whether a member can be overridden, ie. whether it is <c>virtual</c>, <c>abstract</c>, or <c>override</c> but not <c>sealed</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.MethodCollectionExtensions">
      <summary>
            Provides extension methods to the <see cref="T:Metalama.Framework.Code.Collections.IMethodCollection" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfCompatibleSignature(Metalama.Framework.Code.Collections.IMethodCollection,System.String,System.Collections.Generic.IReadOnlyList{System.Type},System.Nullable{System.Boolean})">
      <summary>
            Gets the list of methods with signatures compatible with specified constraints.
            </summary>
      <param name="methods">A collection of methods.</param>
      <param name="name">Name of the method.</param>
      <param name="argumentTypes">Constraint on reflection types of arguments. <c>Null</c>items in the list signify any type.</param>
      <param name="isStatic">Constraint on staticity of the method.</param>
      <returns>Enumeration of methods matching specified constraints.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfCompatibleSignature(Metalama.Framework.Code.Collections.IMethodCollection,System.String,System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.IType},System.Collections.Generic.IReadOnlyList{System.Nullable{Metalama.Framework.Code.RefKind}},System.Nullable{System.Boolean})">
      <summary>
            Gets the list of methods with signatures compatible with specified constraints.
            </summary>
      <param name="methods">A collection of methods.</param>
      <param name="name">Name of the method.</param>
      <param name="argumentTypes">Constraint on types of arguments. <c>Null</c>items in the list signify any type.</param>
      <param name="refKinds">Constraint on reference kinds of arguments. <c>Null</c>items in the list signify any reference kind.</param>
      <param name="isStatic">Constraint on staticity of the method.</param>
      <returns>Enumeration of methods matching specified constraints.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfExactSignature(Metalama.Framework.Code.Collections.IMethodCollection,System.String,System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.IType},System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.RefKind},System.Nullable{System.Boolean})">
      <summary>
            Gets a method that exactly matches the specified signature.
            </summary>
      <param name="methods">A collection of methods.</param>
      <param name="name">Name of the method.</param>
      <param name="parameterTypes">List of parameter types.</param>
      <param name="refKinds">List of parameter reference kinds, or <c>null</c> if all parameters should be by-value.</param>
      <param name="isStatic">Staticity of the method.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.IMethod" /> that matches the given signature.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfExactSignature(Metalama.Framework.Code.Collections.IMethodCollection,Metalama.Framework.Code.IMethod,System.Boolean)">
      <summary>
            Gets a method that exactly matches the signature of the specified method.
            </summary>
      <param name="methods">A collection of methods.</param>
      <param name="signatureTemplate">Method signature of which to should be considered.</param>
      <param name="matchIsStatic">Value indicating whether the staticity of the method should be matched.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.IMethod" /> that matches the given signature.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfExactSignature(Metalama.Framework.Code.Collections.IIndexerCollection,System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.IType},System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.RefKind})">
      <summary>
            Gets an indexer that exactly matches the specified signature.
            </summary>
      <param name="indexers">A collection of indexers.</param>
      <param name="parameterTypes">List of parameter types.</param>
      <param name="refKinds">List of parameter reference kinds, or <c>null</c> if all parameters should be by-value.</param>
      <returns>An <see cref="T:Metalama.Framework.Code.IIndexer" /> that matches the given signature.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfExactSignature(Metalama.Framework.Code.Collections.IIndexerCollection,Metalama.Framework.Code.IIndexer)">
      <summary>
            Gets an indexer that exactly matches the signature of the specified method.
            </summary>
      <param name="indexers">A collection of indexers.</param>
      <param name="signatureTemplate">Indexer signature of which to should be considered.</param>
      <returns>A <see cref="T:Metalama.Framework.Code.IMethod" /> that matches the given signature.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.MethodCollectionExtensions.OfKind(Metalama.Framework.Code.Collections.IMethodCollection,Metalama.Framework.Code.MethodKind)">
      <summary>
            Gets the list of methods of a given <see cref="T:Metalama.Framework.Code.MethodKind" /> (such as <see cref="F:Metalama.Framework.Code.MethodKind.Operator" /> or <see cref="F:Metalama.Framework.Code.MethodKind.Default" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.MethodExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Code.IMethod" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.MethodExtensions.GetIteratorInfo(Metalama.Framework.Code.IMethod)">
      <summary>
            Determines whether a method is a <c>yield</c>-based iterator and returns an <see cref="T:Metalama.Framework.Code.IteratorInfo" /> value
            exposing details about the iterator.
            </summary>
      <param name="method"></param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Code.MethodKind">
      <summary>
            Kinds of <see cref="T:Metalama.Framework.Code.IMethodBase" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.Default">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.Finalizer">
      <summary>
            Finalizer (destructor).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.PropertyGet">
      <summary>
            Property getter.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.PropertySet">
      <summary>
            Property setter.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.EventAdd">
      <summary>
            Event adder.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.EventRemove">
      <summary>
            Event remover.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.EventRaise">
      <summary>
            Event raiser.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.ExplicitInterfaceImplementation">
      <summary>
            Explicit interface implementation.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.Operator">
      <summary>
            Operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.LocalFunction">
      <summary>
            Local function.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.Lambda">
      <summary>
            Lambda.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.MethodKind.DelegateInvoke">
      <summary>
            Delegate invocation.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.NamedTypeExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Code.INamedType" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.GetMetadataName(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets the name of a named type in metadata format, i.e. the <c>`1</c>, <c>`2</c>, ... suffixes for generic types.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.GetFullMetadataName(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets the full name of a named type in metadata format, i.e. with <c>+</c> as the nested type separator and the <c>`1</c>, <c>`2</c>, ... suffixes
            for generic types.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.MethodsAndAccessors(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets all methods of a named type, including the accessors of properties and events.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.Members(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets all members of the current type, except nested types.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.AllMembers(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets all members of the current type and members inherited from the base type, except nested types.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.NestedTypes(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets all nested types of the current type, and all recursively all nested types of those nested types, but not the current type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamedTypeExtensions.NestedTypesAndSelf(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets all nested types of the current type, and all recursively all nested types of those nested types, including the current type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamespaceExtensions.IsAncestorOf(Metalama.Framework.Code.INamespace,Metalama.Framework.Code.INamespace)">
      <summary>
            Gets a value indicating whether the current namespace is the ancestor of another given namespace.
            This method returns <c>false</c> when both namespaces are equal.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamespaceExtensions.IsDescendantOf(Metalama.Framework.Code.INamespace,Metalama.Framework.Code.INamespace)">
      <summary>
            Gets a value indicating whether the current namespace is the descendant of another given namespace.
            This method returns <c>false</c> when both namespaces are equal.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamespaceExtensions.Descendants(Metalama.Framework.Code.INamespace)">
      <summary>
            Gets all child and descendant namespaces of the current namespace, excluding the current namespace. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.NamespaceExtensions.DescendantsAndSelf(Metalama.Framework.Code.INamespace)">
      <summary>
            Gets all child and descendant namespaces of the current namespace, plus the current namespace. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.OperatorKind">
      <summary>
            Kinds of operators.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.None">
      <summary>
            Not an operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.ImplicitConversion">
      <summary>
            Implicit (widening) conversion.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.ExplicitConversion">
      <summary>
            Explicit (narrowing) conversion.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Addition">
      <summary>
            Addition operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.BitwiseAnd">
      <summary>
            BitwiseAnd operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.BitwiseOr">
      <summary>
            BitwiseOr operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Decrement">
      <summary>
            Decrement operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Division">
      <summary>
            Division operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Equality">
      <summary>
            Equality operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.ExclusiveOr">
      <summary>
            ExclusiveOr operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.False">
      <summary>
            False operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.GreaterThan">
      <summary>
            GreaterThan operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.GreaterThanOrEqual">
      <summary>
            GreaterThanOrEqual operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Increment">
      <summary>
            Increment operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Inequality">
      <summary>
            Inequality operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.LeftShift">
      <summary>
            LeftShift operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.LessThan">
      <summary>
            LessThan operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.LessThanOrEqual">
      <summary>
            LessThanOrEqual operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.LogicalNot">
      <summary>
            LogicalNot operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Modulus">
      <summary>
            Modulus operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Multiply">
      <summary>
            Multiply operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.OnesComplement">
      <summary>
            OnesComplement operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.RightShift">
      <summary>
            RightShift operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.Subtraction">
      <summary>
            Subtraction operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.True">
      <summary>
            True operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.UnaryNegation">
      <summary>
            UnaryNegation operator.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.OperatorKind.UnaryPlus">
      <summary>
            UnaryPlus operator.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.RefComparison">
      <summary>
            Defines strategies to compare two instances of the <see cref="T:Metalama.Framework.Code.IRef`1" /> interface.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefComparison.Default">
      <summary>
            Does not support cross-compilation comparisons and ignores nullability when comparing <c>IRef{IType}</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefComparison.IncludeNullability">
      <summary>
            Does not support cross-compilation comparisons and respects nullability when comparing <c>IRef{IType}</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefComparison.Structural">
      <summary>
            Support cross-compilation comparisons and ignores nullability when comparing <c>IRef{IType}</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefComparison.StructuralIncludeNullability">
      <summary>
            Support cross-compilation comparisons and respects nullability when comparing <c>IRef{IType}</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ReferenceKinds">
      <summary>
            Enumerates all kinds of references.
            </summary>
      <seealso href="@validation" />
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.All">
      <summary>
            All reference kinds.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.Default">
      <summary>
            A field or property access that does not fall into another category.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.BaseType">
      <summary>
            Base type or interface.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.TypeArgument">
      <summary>
            Type argument (e.g. generic argument). 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.TypeOf">
      <summary>
        <c>typeof</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.ParameterType">
      <summary>
            Parameter reference.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.TypeConstraint">
      <summary>
            Type constraint of a generic parameter.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.ObjectCreation">
      <summary>
            Object construction, i.e. constructor invocation. The reference generally points to the constructor. In case of collection expression, the reference
            points to the type.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.MemberType">
      <summary>
            Type of a field, property, or event.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.LocalVariableType">
      <summary>
            Type of a local variable.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.AttributeType">
      <summary>
            Type of a custom attribute.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.ReturnType">
      <summary>
            Return type of a method.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.ArrayElementType">
      <summary>
            Element type of an array.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.NullableType">
      <summary>
            Nullable type.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.PointerType">
      <summary>
            Type of element pointed at by an unmanaged pointer.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.RefType">
      <summary>
            Type of a <c>ref</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.TupleElementType">
      <summary>
            Type of a tuple element.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.Invocation">
      <summary>
            Invocation of a method or delegate.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.Assignment">
      <summary>
            Left part of an assignment.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.OverrideMember">
      <summary>
            The member is being overridden using an <c>override</c>. The reference points to the overridden member.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.InterfaceMemberImplementation">
      <summary>
            Implicit or explicit implementation of an interface member. The reference points to the interface member.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.UsingNamespace">
      <summary>
            Inside a <c>using</c> namespace directive.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.NameOf">
      <summary>
        <c>nameof</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.BaseConstructor">
      <summary>
            Base constructor (either <c>this</c> or <c>base</c>). The reference points to the base constructor.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.ArrayCreation">
      <summary>
            Creation of an array. The reference points to the type.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.CastType">
      <summary>
            Type of a cast (both <c>(T) x</c> and <c>x as T</c>).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.ReferenceKinds.IsType">
      <summary>
        <c>is T</c> or <c>is T {}</c> pattern matching.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.ReferenceKindsExtension">
      <summary>
            Extension methods for <see cref="T:Metalama.Framework.Code.ReferenceKinds" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ReferenceKindsExtension.ToDisplayString(Metalama.Framework.Code.ReferenceKinds)">
      <summary>
            Same as <c>ToString</c> excepts that it does not use obsolete names.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ReferenceKindsExtension.IsDefined(Metalama.Framework.Code.ReferenceKinds,Metalama.Framework.Code.ReferenceKinds)">
      <summary>
            Determines if a <see cref="T:Metalama.Framework.Code.ReferenceKinds" /> contains all required flags.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.RefExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Code.IRef`1" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefExtensions.GetTarget``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)">
      <summary>
            Gets the target of the reference for a given compilation, or throws an exception if the reference cannot be resolved. To get the reference for the
            current execution context, use the <see cref="M:Metalama.Framework.Code.RefExtensions.GetTarget``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)" /> extension method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefExtensions.GetTargetOrNull``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)">
      <summary>
            Gets the target of the reference for a given compilation, or returns <c>null</c> if the reference cannot be resolved. To get the reference for the
            current execution context, use the <see cref="M:Metalama.Framework.Code.RefExtensions.GetTargetOrNull``1(Metalama.Framework.Code.IRef{``0},Metalama.Framework.Code.ICompilation,Metalama.Framework.Code.IGenericContext)" /> extension method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefExtensions.GetTarget``1(Metalama.Framework.Code.IRef{``0})">
      <summary>
            Gets the target of the reference for the current execution context, or throws an exception if the reference cannot be resolved.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefExtensions.GetTargetOrNull``1(Metalama.Framework.Code.IRef{``0})">
      <summary>
            Gets the target of the reference for the current execution context, or returns <c>null</c> if the reference cannot be resolved.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.RefKind">
      <summary>
            Kinds of parameters, such as <c>ref</c>, <c>in</c>, <c>out</c>...
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefKind.None">
      <summary>
            A normal parameter passed by value.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefKind.Ref">
      <summary>
        <c>ref</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefKind.In">
      <summary>
        <c>in</c> input parameter.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefKind.RefReadOnly">
      <summary>
        <c>ref readonly</c> property, parameter, or return parameter.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.RefKind.Out">
      <summary>
        <c>out</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.RefKindExtensions">
      <summary>
            Extension methods for <see cref="T:Metalama.Framework.Code.RefKind" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefKindExtensions.IsByRef(Metalama.Framework.Code.RefKind)">
      <summary>
            Determines whether the parameter or return value represents a reference (<c>in</c> and <c>out</c> properties, <c>ref</c> and <c>ref readonly</c> methods and properties).  
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefKindExtensions.IsWritable(Metalama.Framework.Code.RefKind)">
      <summary>
            Determines whether the parameter or return value can be assigned.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.RefKindExtensions.IsReadable(Metalama.Framework.Code.RefKind)">
      <summary>
            Determines whether the parameter or return value can be read before it has been assigned.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ReflectionExtensions.AsExpression(System.Reflection.MemberInfo)">
      <summary>
            Returns the <see cref="T:Metalama.Framework.Code.IExpression" /> representation of the given <see cref="T:System.Reflection.MemberInfo" />, when available, or <see langword="null" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ReflectionExtensions.AsExpression(System.Reflection.ParameterInfo)">
      <summary>
            Returns the <see cref="T:Metalama.Framework.Code.IExpression" /> representation of the given <see cref="T:System.Reflection.ParameterInfo" />, when available, or <see langword="null" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ReflectionExtensions.ToExpression(System.Reflection.MemberInfo)">
      <summary>
            Returns the <see cref="T:Metalama.Framework.Code.IExpression" /> representation of the given <see cref="T:System.Reflection.MemberInfo" />, when available, or throws an exception.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.ReflectionExtensions.ToExpression(System.Reflection.ParameterInfo)">
      <summary>
            Returns the <see cref="T:Metalama.Framework.Code.IExpression" /> representation of the given <see cref="T:System.Reflection.ParameterInfo" />, when available, or throws an exception.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SerializableDeclarationId">
      <summary>
            Encapsulates a string that uniquely identifies a declaration within a compilation (except in the situation where the compilation
            contains several assemblies providing types of the same name) and that is safe to persist in a file.
            </summary>
      <seealso cref="T:Metalama.Framework.Code.SerializableTypeId" />
    </member>
    <member name="T:Metalama.Framework.Code.SerializableTypeId">
      <summary>
            Encapsulates a string that uniquely identifies a type within a compilation (except in the situation where the compilation
            contains several assemblies providing types of the same name) and that is safe to persist in a file.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SourceReference">
      <summary>
            Represents a syntax node in source code. Using <c>Metalama.Framework.Sdk</c> you can use <c>ToSyntaxNodeOrToken</c> to convert it to a Roslyn object.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceReference.NodeOrToken">
      <summary>
            Gets the Roslyn <c>SyntaxNode</c>, <c>SyntaxToken</c>.
            This property can be used by SDK-based plugins. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceReference.Kind">
      <summary>
            Gets the <c>SyntaxKind</c> of the node or token.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceReference.IsImplementationPart">
      <summary>
            Gets a value indicating whether the current syntax node is contains the implementation of the declaration.
            This property evaluates to <c>false</c> only for partial methods without implementation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceReference.Span">
      <summary>
            Gets source file, line and column for the node.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SourceReference.GetText(System.Boolean)">
      <summary>
            Gets the text representation (i.e. the source code) of the current syntax node or token.
            </summary>
      <param name="normalized">
        <c>true</c> if whitespace should be normalized, <c>false</c> if the original formatting should be preserved.</param>
      <returns>The source code of the current syntax node.</returns>
    </member>
    <member name="M:Metalama.Framework.Code.SourceReference.ToString">
      <summary>
            Gets the content of the node or token (without trivia).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SourceSpan">
      <summary>
            Represents a span of source code.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceSpan.FilePath">
      <summary>
            Gets the path of the source file.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceSpan.StartLine">
      <summary>
            Gets the start line (zero-based).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceSpan.EndLine">
      <summary>
            Gets the end line (zero-based).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceSpan.StartColumn">
      <summary>
            Gets the start column (zero-based).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SourceSpan.EndColumn">
      <summary>
            Gets the start end (zero-based).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SourceSpan.GetText">
      <summary>
            Gets the text representation (i.e. the source code) of the current syntax node or token.
            </summary>
      <returns>The source code of the current syntax node.</returns>
    </member>
    <member name="T:Metalama.Framework.Code.SpecialType">
      <summary>
            Special types, such as <see cref="F:Metalama.Framework.Code.SpecialType.Void" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.None">
      <summary>
            Not a special type.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Void">
      <summary>
        <see cref="F:Metalama.Framework.Code.SpecialType.Void" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Object">
      <summary>
        <see cref="T:System.Object" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Byte">
      <summary>
        <see cref="T:System.Byte" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.SByte">
      <summary>
        <see cref="T:System.SByte" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Int16">
      <summary>
        <see cref="T:System.Int16" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.UInt16">
      <summary>
        <see cref="T:System.UInt16" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Int32">
      <summary>
        <see cref="T:System.Int32" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.UInt32">
      <summary>
        <see cref="T:System.UInt32" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Int64">
      <summary>
        <see cref="T:System.Int64" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.UInt64">
      <summary>
        <see cref="T:System.UInt64" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.String">
      <summary>
        <see cref="T:System.String" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Decimal">
      <summary>
        <see cref="T:System.Decimal" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Single">
      <summary>
        <see cref="T:System.Single" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Double">
      <summary>
        <see cref="T:System.Double" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Boolean">
      <summary>
        <see cref="T:System.Boolean" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.IEnumerable">
      <summary>
        <see cref="T:System.Collections.IEnumerable" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.IEnumerator">
      <summary>
        <see cref="T:System.Collections.IEnumerator" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.IEnumerable_T">
      <summary>
        <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.IEnumerator_T">
      <summary>
        <see cref="T:System.Collections.Generic.IEnumerator`1" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.List_T">
      <summary>
        <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.IAsyncEnumerable_T">
      <summary>
        <c>System.Collections.Generic.IAsyncEnumerable&gt;T&lt;</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.IAsyncEnumerator_T">
      <summary>
        <c>System.Collections.Generic.IAsyncEnumerator&gt;T&lt;</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.ValueTask">
      <summary>
        <c>System.Threading.Tasks.ValueTask</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.ValueTask_T">
      <summary>
        <c>System.Threading.Tasks.ValueTask&gt;T&lt;</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Task">
      <summary>
        <see cref="T:System.Threading.Tasks.Task" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Task_T">
      <summary>
        <see cref="T:System.Threading.Tasks.Task`1" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Char">
      <summary>
        <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Type">
      <summary>
        <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.SpecialType.Count">
      <summary>
            Number of items in this enumeration.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder">
      <summary>
            Compile-time object that allows to build a run-time array. Items of the array are run-time expressions.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.#ctor(Metalama.Framework.Code.IType)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder" /> class where the item type is a given <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder" /> class where the item type is a given <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder" /> class where the item type is a <see cref="T:System.Object" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.Add(System.Object)">
      <summary>
            Adds an item to the array.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.Add(Metalama.Framework.Code.IExpression)">
      <summary>
            Adds an item to the array.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.ToExpression">
      <summary>
            Returns a clone of the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder.Clone">
      <summary>
            Returns a clone of the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ArrayBuilder" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder">
      <summary>
            Allows to build a run-time expression by composing a string thanks to an underlying <see cref="T:System.Text.StringBuilder" />.
            Use the <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder.ToExpression" /> method to convert the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" /> into a compile-time representation of the expression,
            or the <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilderExtensions.ToValue(Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder)" /> methods converts it to a dynamic expression that can be used in the C# code
            of the template. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder.ToExpression">
      <summary>
            Creates a compile-time <see cref="T:Metalama.Framework.Code.IExpression" /> from the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder.Clone">
      <summary>
            Returns a clone of the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder.ExpressionType">
      <summary>
            Gets or sets the resulting type of the expression, if known. This value allows to generate simpler code.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder.IsReferenceable">
      <summary>
            Gets or sets a value indicating whether the expression can be used in <c>ref</c> or <c>out</c> situations.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilderExtensions.ToValue(Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder)">
      <summary>
            Gets an object that can be used in a run-time expression of a template to represent the result of the current expression builder.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilderExtensions.ToValue(Metalama.Framework.Code.SyntaxBuilders.INotNullExpressionBuilder)">
      <summary>
            Gets an object that can be used in a run-time expression of a template to represent the result of the current expression builder.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory">
      <summary>
            Provides several ways to create instances of the <see cref="T:Metalama.Framework.Code.IExpression" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Object,System.Boolean)">
      <summary>
            Returns an expression that represents a literal.
            </summary>
      <param name="value">A literal value, or <c>null</c> to represent a null string.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the <paramref name="value" /> parameter contains a <c>long</c> that can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Int32)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Int32" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.UInt32,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.UInt32" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Int16,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Int16" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.UInt16,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.UInt16" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Int64,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Int64" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.UInt64,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.UInt64" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Byte,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Byte" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.SByte,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.SByte" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Double,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Double" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Single,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Single" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.Decimal,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.Decimal" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can also represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Literal(System.String,System.Boolean)">
      <summary>
            Returns an expression that represents a literal of type <see cref="T:System.String" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the <c>null</c> value  should be qualified as <c>(string?) null</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Parse(System.String,Metalama.Framework.Code.IType,System.Nullable{System.Boolean})">
      <summary>
            Parses a string containing a C# expression and returns an <see cref="T:Metalama.Framework.Code.IExpression" />. The <see cref="P:Metalama.Framework.Code.IExpression.Value" /> property
            allows to use this expression in a template. An alternative to this method is the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" /> class.
            </summary>
      <param name="code">A valid C# expression.</param>
      <param name="type">The resulting type of the expression, if known. This value allows to generate simpler code.</param>
      <param name="isReferenceable">Indicates whether the expression can be used in <c>ref</c> or <c>out</c> situations.</param>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Capture(System.Object)">
      <summary>
            Creates a compile-time object that represents a run-time <i>expression</i>, i.e. the syntax or code, and not the result
            itself. The returned <see cref="T:Metalama.Framework.Code.IExpression" /> can then be used in run-time C# code thanks to the <see cref="P:Metalama.Framework.Code.IExpression.Value" /> property.
            This mechanism allows to generate expressions that depend on a compile-time control flow.
            </summary>
      <param name="expression">A run-time expression, possibly containing compile-time sub-expressions. The expression cannot be <c>dynamic</c>. If
            you have a dynamic expression, do not call this method, but cast the dynamic expression to <see cref="T:Metalama.Framework.Code.IExpression" />.</param>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.CastTo(Metalama.Framework.Code.IExpression,Metalama.Framework.Code.IType)">
      <summary>
            Returns an expression obtained by casting another expression to a type given as an <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.CastTo(Metalama.Framework.Code.IExpression,System.Type)">
      <summary>
            Returns an expression obtained by casting another expression to a type given as a <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.CastTo``1(Metalama.Framework.Code.IExpression)">
      <summary>
            Returns an expression obtained by casting another expression to a type given as a generic parameter.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.This(Metalama.Framework.Code.INamedType)">
      <summary>
            Gets a <c>this</c> expression for the given type.
            </summary>
      <param name="type">A type.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.This">
      <summary>
            Gets a <c>this</c> expression for the current type when inside a template.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Null">
      <summary>
            Gets a <c>null</c> expression without specifying a type. The expression will be target-typed.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Null(Metalama.Framework.Code.IType)">
      <summary>
            Gets a <c>null</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Null(Metalama.Framework.Code.SpecialType)">
      <summary>
            Gets a <c>null</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Null(System.Type)">
      <summary>
            Gets a <c>null</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Null``1">
      <summary>
            Gets a <c>null</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default">
      <summary>
            Gets a <c>default</c> expression without specifying a type. The expression will be target-typed.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default(Metalama.Framework.Code.IType)">
      <summary>
            Gets a <c>default</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default(Metalama.Framework.Code.SpecialType)">
      <summary>
            Gets a <c>default</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default(System.Type)">
      <summary>
            Gets a <c>default</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.Default``1">
      <summary>
            Gets a <c>default</c> expression for a given type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.WithType(Metalama.Framework.Code.IExpression,Metalama.Framework.Code.IType)">
      <summary>
            Returns the same expression, but assuming it has a different type <see cref="P:Metalama.Framework.Code.IHasType.Type" />. This method does not generate
            any cast (unlike <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.CastTo(Metalama.Framework.Code.IExpression,Metalama.Framework.Code.IType)" />) and should only
            be used when the of the type given expression is wrongly infered.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.WithNullability(Metalama.Framework.Code.IExpression,System.Boolean)">
      <summary>
            Returns the same expression, but assuming it has a different nullability. This method does not generate
            any cast (unlike <see cref="M:Metalama.Framework.Code.SyntaxBuilders.ExpressionFactory.CastTo(Metalama.Framework.Code.IExpression,Metalama.Framework.Code.IType)" />) and should only
            be used when the of the nullability given expression is wrongly infered.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder">
      <summary>
            Interface to be implemented by any compile-time object that can be serialized into a run-time expression.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder.ToExpression">
      <summary>
            Converts the current object into a run-time expression. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.INotNullExpressionBuilder">
      <summary>
            An <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder" /> that is guaranteed to produce a non-null value.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.InterpolatedStringBuilder">
      <summary>
            Compile-time object that allows to build a run-time interpolated string.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SyntaxBuilders.InterpolatedStringBuilder.ItemCount">
      <summary>
            Gets the number of items that have been added to the current builder.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.InterpolatedStringBuilder.AddText(System.String)">
      <summary>
            Adds a fixed text to the interpolated string.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.InterpolatedStringBuilder.AddExpression(System.Object,System.Nullable{System.Int32},System.String)">
      <summary>
            Adds an expression to the interpolated string.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.InterpolatedStringBuilder.AddExpression(Metalama.Framework.Code.IExpression,System.Nullable{System.Int32},System.String)">
      <summary>
            Adds an expression to the interpolated string.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.InterpolatedStringBuilder.ToExpression">
      <summary>
            Creates a compile-time <see cref="T:Metalama.Framework.Code.IExpression" /> from the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.IStatement">
      <summary>
            Represents a statement, which can be inserted into run-time code using the <see cref="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.SyntaxBuilders.IStatement)" />.
            To create a statement, use <see cref="T:Metalama.Framework.Code.SyntaxBuilders.StatementFactory" />, <see cref="T:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder" />, or <see cref="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder" />.
            method.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.IStatementBuilder">
      <summary>
            A common interface for objects that produce an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.IStatementBuilder.ToStatement">
      <summary>
            Builds an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> representing the current object.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList">
      <summary>
            Represents a list of statements. This list cannot be enumerated because it is evaluated late, when the statement is used in the target syntax tree.
            To create an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />, use <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.List(Metalama.Framework.Code.SyntaxBuilders.IStatement[])" />,
             <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.UnwrapBlock(Metalama.Framework.Code.SyntaxBuilders.IStatement)" />, or <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementExtensions.AsList(Metalama.Framework.Code.SyntaxBuilders.IStatement)" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder">
      <summary>
            Allows to build a run-time statement that can be injected to run-time code using
            <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.ToStatement" /> and <see cref="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.SyntaxBuilders.IStatement)" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.ToStatement">
      <summary>
            Converts the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder" /> into an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> object, which can then
            be inserted into run-time code using the <see cref="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.SyntaxBuilders.IStatement)" />
            method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.AppendLine">
      <summary>
            Appends a line break.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.Clone">
      <summary>
            Returns a clone of the current <see cref="T:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.Indent">
      <summary>
            Increments the indentation level.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.Unindent">
      <summary>
            Decrements the indentation level.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.BeginBlock">
      <summary>
            Begins a block (appends a <c>{</c> and increments the indentation level).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder.EndBlock">
      <summary>
            Ends a block (appends a <c>}</c> and decrements the indentation level).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.StatementExtensions">
      <summary>
            Extensions to the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementExtensions.AsList(Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Wraps a given <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> into a singleton <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementExtensions.AsList(System.Collections.Generic.IEnumerable{Metalama.Framework.Code.SyntaxBuilders.IStatement})">
      <summary>
            Wraps a list of <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> into an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementExtensions.UnwrapBlock(Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Unwraps a block (i.e. remove its braces), if the statement is a block, and returns the resulting <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.StatementFactory">
      <summary>
            Creates instances of the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.Parse(System.String)">
      <summary>
            Parses a string containing a C# statement and returns an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />, which can be inserted into the run-time code
            using <see cref="M:Metalama.Framework.Aspects.meta.InsertStatement(Metalama.Framework.Code.SyntaxBuilders.IStatement)" />. The string must contain a single statement,
            and must be finished by a semicolon or a closing bracket. An alternative to this method is the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder" /> class.
            </summary>
      <seealso href="@templates" />
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromExpression(Metalama.Framework.Code.IExpression)">
      <summary>
            Creates an expression statement (e.g. a method invocation or an assignment).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(Metalama.Framework.Aspects.TemplateInvocation,System.Object)">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> obtained by invoking a template specified by a <see cref="T:Metalama.Framework.Aspects.TemplateInvocation" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(System.String,System.Object)">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> obtained by invoking a template specified by its name and optional arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(System.String,Metalama.Framework.Aspects.ITemplateProvider,System.Object)">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> obtained by invoking a template specified by its name, an <see cref="T:Metalama.Framework.Aspects.ITemplateProvider" />, and optional arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(System.String,Metalama.Framework.Aspects.TemplateProvider,System.Object)">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> obtained by invoking a template specified by its name, a <see cref="T:Metalama.Framework.Aspects.TemplateProvider" />, and optional arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.Block(Metalama.Framework.Code.SyntaxBuilders.IStatement[])">
      <summary>
            Creates a block composed of zero, one or many statements.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.Block(System.Collections.Generic.IEnumerable{Metalama.Framework.Code.SyntaxBuilders.IStatement})">
      <summary>
            Creates a block composed of zero, one or many statements.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.Block(Metalama.Framework.Code.SyntaxBuilders.IStatementList)">
      <summary>
            Creates a block from an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.UnwrapBlock(Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Returns an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" /> from the statements of a given block, or a singleton <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" /> containing the given statement
            itself if the statement is not a block.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.List(Metalama.Framework.Code.SyntaxBuilders.IStatement[])">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" /> from a list of <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.List(System.Collections.Generic.IEnumerable{Metalama.Framework.Code.SyntaxBuilders.IStatement})">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" /> from a list of <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.StatementListBuilder">
      <summary>
            A class that allows to dynamically build an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementListBuilder.Add(Metalama.Framework.Code.SyntaxBuilders.IStatement)">
      <summary>
            Appends an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> to the list.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementListBuilder.Add(Metalama.Framework.Code.SyntaxBuilders.IStatementList)">
      <summary>
            Appends an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" /> to the list.
            </summary>
      <param name="statementList"></param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.StatementListBuilder.ToStatementList">
      <summary>
            Creates an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" /> from the current object.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder">
      <summary>
            Builds a <c>switch</c> statement.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.#ctor(Metalama.Framework.Code.IExpression)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder" /> class.
            </summary>
      <param name="expression">The expression in the <c>switch ( expression )</c> statement.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.AddCase(Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel,Metalama.Framework.Code.SyntaxBuilders.IStatementList,System.Boolean)">
      <summary>
            Add a <c>case</c> switch section. This overload accepts an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
      <param name="label">The label, i.e. the value to match.</param>
      <param name="statements">The statements to execute.</param>
      <param name="appendBreak">Value indicating whether a <c>break;</c> statement should be appended to <paramref name="statements" />. The default value is <c>true</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.AddCase(Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel,Metalama.Framework.Code.SyntaxBuilders.IStatement,System.Boolean)">
      <summary>
            Add a <c>case</c> switch section. This overload accepts an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
      <param name="label">The label, i.e. the value to match.</param>
      <param name="statement">The statement to execute. To call a template, see <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(Metalama.Framework.Aspects.TemplateInvocation,System.Object)" />.</param>
      <param name="appendBreak">Value indicating whether a <c>break;</c> statement should be appended to <paramref name="statement" />. The default value is <c>true</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.AddCase(Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel,Metalama.Framework.Code.IExpression,Metalama.Framework.Code.SyntaxBuilders.IStatementList,System.Boolean)">
      <summary>
            Add a <c>case</c> switch section with a <c>when</c> expression. This overload accepts an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
      <param name="label">The label, i.e. the value to match.</param>
      <param name="when">The <c>when</c> expression.</param>
      <param name="statements">The statements to execute.</param>
      <param name="appendBreak">Value indicating whether a <c>break;</c> statement should be appended to <paramref name="statements" />. The value is <c>true</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.AddCase(Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel,Metalama.Framework.Code.IExpression,Metalama.Framework.Code.SyntaxBuilders.IStatement,System.Boolean)">
      <summary>
            Add a <c>case</c> switch section with a <c>when</c> expression.  This overload accepts an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
      <param name="label">The label, i.e. the value to match.</param>
      <param name="when">The <c>when</c> expression.</param>
      <param name="statement">The statement to execute. To call a template, see <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(Metalama.Framework.Aspects.TemplateInvocation,System.Object)" />.</param>
      <param name="appendBreak">Value indicating whether a <c>break;</c> statement should be appended to <paramref name="statement" />. The value is <c>true</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.AddDefault(Metalama.Framework.Code.SyntaxBuilders.IStatementList,System.Boolean)">
      <summary>
            Add a <c>default</c> switch section.  This overload accepts an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatementList" />.
            </summary>
      <param name="statements">The statements to execute.</param>
      <param name="appendBreak">Value indicating whether a <c>break;</c> statement should be appended to <paramref name="statements" />. The default value is <c>true</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.AddDefault(Metalama.Framework.Code.SyntaxBuilders.IStatement,System.Boolean)">
      <summary>
            Add a <c>default</c> switch section.  This overload accepts an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" />.
            </summary>
      <param name="statement">The statements to execute.  To call a template, see <see cref="M:Metalama.Framework.Code.SyntaxBuilders.StatementFactory.FromTemplate(Metalama.Framework.Aspects.TemplateInvocation,System.Object)" />.</param>
      <param name="appendBreak">Value indicating whether a <c>break;</c> statement should be appended to <paramref name="statement" />. The default value is <c>true</c>.</param>
    </member>
    <member name="P:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.SectionCount">
      <summary>
            Gets the number of sections in the <c>switch</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementBuilder.ToStatement">
      <summary>
            Builds an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IStatement" /> from the current object.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel">
      <summary>
            Represents the label of a <c>switch case</c> (i.e. the literal or tuple literal to which the expression is compared).
            Only single literals or tuple of literals can be represented. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel.Values">
      <summary>
            Gets the list of literals in the tuple.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel.CreateLiteral(System.Object[])">
      <summary>
            Creates a literal <see cref="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel" /> by giving the literals as intrinsic values (<see cref="T:System.String" />, <see cref="T:System.Int32" />, ...).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel.CreateLiteral(Metalama.Framework.Code.TypedConstant[])">
      <summary>
            Creates a literal <see cref="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel" /> by giving the literals as <see cref="T:Metalama.Framework.Code.TypedConstant" /> values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel.CreateLiteral(System.Collections.Generic.IReadOnlyList{Metalama.Framework.Code.TypedConstant})">
      <summary>
            Creates a literal <see cref="T:Metalama.Framework.Code.SyntaxBuilders.SwitchStatementLabel" /> by giving the literals as <see cref="T:Metalama.Framework.Code.TypedConstant" /> values.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder">
      <summary>
            A base class for <see cref="T:Metalama.Framework.Code.SyntaxBuilders.ExpressionBuilder" /> and <see cref="T:Metalama.Framework.Code.SyntaxBuilders.StatementBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendVerbatim(System.String)">
      <summary>
            Appends a string to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />, without performing any modification to the input string.
            </summary>
      <param name="rawCode"></param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Int32)">
      <summary>
            Appends a literal of type <see cref="T:System.Int32" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.UInt32,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.UInt32" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Int16,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.Int16" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.UInt16,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.UInt16" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Int64,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.Int64" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.UInt64,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.UInt64" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Byte,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.Byte" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.SByte,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.SByte" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Double,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.Double" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Single,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.Single" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.Decimal,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.Decimal" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the literal should be qualified to remove any type ambiguity, for instance
            if the literal can only represent an <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendLiteral(System.String,System.Boolean)">
      <summary>
            Appends a literal of type <see cref="T:System.String" /> to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />.
            </summary>
      <param name="value">The literal value.</param>
      <param name="stronglyTyped">A value indicating if the <c>null</c> value  should be qualified as <c>(string?) null</c>.</param>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendTypeName(Metalama.Framework.Code.IType)">
      <summary>
            Appends a fully-qualified type name to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />, where the type is given as an <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendTypeName(System.Type)">
      <summary>
            Appends a fully-qualified type name to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />, where the type is given as a reflection <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendExpression(Metalama.Framework.Code.IExpression)">
      <summary>
            Appends an expression to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />, where the expression is given as an <see cref="T:Metalama.Framework.Code.IExpression" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendExpression(Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder)">
      <summary>
            Appends an expression to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />, where the expression is given as an <see cref="T:Metalama.Framework.Code.SyntaxBuilders.IExpressionBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.AppendExpression(System.Object)">
      <summary>
            Appends an expression to the <see cref="P:Metalama.Framework.Code.SyntaxBuilders.SyntaxBuilder.StringBuilder" />, where the expression is a C# expression.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.TypedConstant">
      <summary>
            Represents a typed value that can be defined, defined to null, or undefined. Used to represent default values,
            for instance <see cref="P:Metalama.Framework.Code.IParameter.DefaultValue" />, or attribute arguments.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.TypedConstant.IsInitialized">
      <summary>
            Gets a value indicating whether the <see cref="P:Metalama.Framework.Code.TypedConstant.Value" /> has been specified (including when it is set to <c>null</c>).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.TypedConstant.Type">
      <summary>
            Gets the type of the value. This is important if the type is an enum, because in this case, if the enum type is not compile-time,
            <see cref="P:Metalama.Framework.Code.TypedConstant.Value" /> is set to the underlying integer value.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.TypedConstant.IsNullOrDefault">
      <summary>
            Gets a value indicating whether the value is <c>null</c> or <c>default</c>. Not to be confused with <see cref="P:Metalama.Framework.Code.TypedConstant.IsInitialized" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.TypedConstant.RawValue">
      <summary>
            Gets the raw value of the <see cref="T:Metalama.Framework.Code.TypedConstant" />. If <see cref="P:Metalama.Framework.Code.TypedConstant.IsArray" /> is <c>true</c>, this
            property returns an <c>ImmutableArray&lt;TypedConstant&gt;</c>.
            </summary>
      <remarks>
        <para>
            For enum values, <see cref="P:Metalama.Framework.Code.TypedConstant.Value" /> represents the underlying integer value and <see cref="P:Metalama.Framework.Code.TypedConstant.Type" /> the type of the enum.
            </para>
      </remarks>
    </member>
    <member name="P:Metalama.Framework.Code.TypedConstant.Value">
      <summary>
            Gets the <see cref="P:Metalama.Framework.Code.TypedConstant.Value" /> for non-array types. For array types, get an array of a primitive type (e.g. <c>int[]</c>)
            instead of an array of <see cref="T:Metalama.Framework.Code.TypedConstant" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.TypeExtensions">
      <summary>
            Provides extension methods for <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.IsConvertibleTo(Metalama.Framework.Code.IType,Metalama.Framework.Code.IType,Metalama.Framework.Code.ConversionKind,Metalama.Framework.Code.Comparers.TypeComparison)">
      <summary>
            Equivalent to the <c>is</c> operator in C#. Gets a value indicating whether the current type is assignable to another given type,
            given as an <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.IsConvertibleTo(Metalama.Framework.Code.IType,System.Type,Metalama.Framework.Code.ConversionKind,Metalama.Framework.Code.Comparers.TypeComparison)">
      <summary>
            Equivalent to the <c>is</c> operator in C#. Gets a value indicating whether the current type is assignable to another given type,
            given as a reflection <see cref="T:System.Type" />.
            </summary>
      <param name="left"></param>
      <param name="right">Another type.</param>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.IsConvertibleTo(Metalama.Framework.Code.IType,Metalama.Framework.Code.SpecialType,Metalama.Framework.Code.ConversionKind)">
      <summary>
            Equivalent to the <c>is</c> operator in C#. Gets a value indicating whether the current type is assignable to another given type,
            given as a reflection <see cref="T:System.Type" />.
            </summary>
      <param name="left"></param>
      <param name="right">Another type.</param>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.DerivesFrom(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.INamedType,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Determines if a type derives from another one, given as an <see cref="T:Metalama.Framework.Code.INamedType" />.
            </summary>
      <param name="left">The child type.</param>
      <param name="right">The base type. It cannot be a generic type instance.</param>
      <param name="options">Determine with inheritance relationships should be considered.</param>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.DerivesFrom(Metalama.Framework.Code.INamedType,System.Type,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Determines if a type derives from another one, given as a <see cref="T:System.Type" />.
            </summary>
      <param name="left">The child type.</param>
      <param name="right">The base type. It cannot be a generic type instance.</param>
      <param name="options">Determine with inheritance relationships should be considered.</param>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.DefaultValue(Metalama.Framework.Code.IType)">
      <summary>
            Generates the <c>default(T)</c> syntax for the type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.GetAsyncInfo(Metalama.Framework.Code.IType)">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Code.AsyncInfo" /> for a type.
            </summary>
      <param name="type">Typically the return type of a method, e.g. <c>Task</c>, <c>ValueTask&lt;T&gt;</c>, <c>void</c>...</param>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.ToSerializableId(Metalama.Framework.Code.IType)">
      <summary>
            Gets a <see cref="T:Metalama.Framework.Code.SerializableTypeId" /> for the type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.TypeExtensions.ToTypeOfExpression(Metalama.Framework.Code.IType)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.IExpression" /> representing 'typeof' expression for the given type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.TypeFactory">
      <summary>
            Exposes methods that return instances of the <see cref="T:Metalama.Framework.Code.IType" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.TypeFactory.GetType(System.Type)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Code.IType" /> given a reflection <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Code.TypeFactory.GetType(System.String)">
      <summary>
            Get type based on its full name, as used in reflection.
            </summary>
      <remarks>
        <para>
            For nested types, this means using <c>+</c>, e.g. to get <see cref="T:System.Environment.SpecialFolder" />, use <c>System.Environment+SpecialFolder</c>.
            </para>
        <para>
            For generic type definitions, this requires using <c>`</c>, e.g. to get <c>List&lt;T&gt;</c>, use <c>System.Collections.Generic.List`1</c>.
            </para>
        <para>
            Constructed generic types (e.g. <c>List&lt;int&gt;</c>) are not supported, for those, use <see cref="M:Metalama.Framework.Code.GenericExtensions.WithTypeArguments(Metalama.Framework.Code.IMethod,Metalama.Framework.Code.IType[])" />.
            </para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Code.TypeFactory.GetType(Metalama.Framework.Code.SpecialType)">
      <summary>
            Gets a <see cref="T:Metalama.Framework.Code.INamedType" /> representing a given <see cref="T:Metalama.Framework.Code.SpecialType" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.TypeKind">
      <summary>
            Kinds of <see cref="T:Metalama.Framework.Code.IType" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Array">
      <summary>
            Array.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Class">
      <summary>
        <c>class</c>.
            </summary>
      <see cref="F:Metalama.Framework.Code.TypeKind.RecordClass" />
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.RecordClass">
      <summary>
        <c>record class</c> (i.e. <c>record</c>).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Delegate">
      <summary>
        <c>delegate</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Dynamic">
      <summary>
        <c>dynamic</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Enum">
      <summary>
        <c>enum</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.TypeParameter">
      <summary>
            Generic parameter.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Interface">
      <summary>
        <c>interface</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Pointer">
      <summary>
            Unmanaged pointer (<c>*</c>).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Struct">
      <summary>
        <c>struct</c>.
            </summary>
      <seealso cref="F:Metalama.Framework.Code.TypeKind.RecordStruct" />
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.RecordStruct">
      <summary>
        <c>record struct</c>.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.FunctionPointer">
      <summary>
            Function pointer (<c>delegate*</c>).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.TypeKind.Error">
      <summary>
            At design time, a type that does not exist.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Types.IArrayType">
      <summary>
            Represents an array, e.g. <c>T[]</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.Types.IArrayType.ElementType">
      <summary>
            Gets the element type, e.g. the <c>T</c> in <c>T[]</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.Types.IArrayType.Rank">
      <summary>
            Gets the array rank (1 for <c>T[]</c>, 2 for <c>T[,]</c>, ...).
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Types.IDynamicType">
      <summary>
            Represent the <c>dynamic</c> type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Types.IFunctionPointerType">
      <summary>
            Represents a function pointer type.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Types.IPointerType">
      <summary>
            Represents an unsafe pointer type.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Code.Types.IPointerType.PointedAtType">
      <summary>
            Gets the type pointed at, that is, <c>T</c> for <c>T*</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.VarianceKind">
      <summary>
            Specifies the kind variance: <see cref="F:Metalama.Framework.Code.VarianceKind.In" />, <see cref="F:Metalama.Framework.Code.VarianceKind.Out" /> or <see cref="F:Metalama.Framework.Code.VarianceKind.None" />.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.VarianceKind.None">
      <summary>
            No variance.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.VarianceKind.In">
      <summary>
            Contravariant.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.VarianceKind.Out">
      <summary>
            Covariant.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Code.Writeability">
      <summary>
            Enumerates the different abilities of a field or property to be written (set).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Writeability.None">
      <summary>
            The field or property cannot be set (e.g. it is a read-only non-automatic property or a const field ).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Writeability.ConstructorOnly">
      <summary>
            The field or property can only be set from the constructor (e.g. it is a <c>readonly</c> field or an automatic property with a sole <c>get</c> accessor).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Writeability.InitOnly">
      <summary>
            The property can be set from constructor or from the initializer (e.g. it is a property with an <c>init</c> accessor).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Code.Writeability.All">
      <summary>
            The field or property can be set at all times (e.g. this is a non-<c>readonly</c> field or a property with a <c>set</c> accessor).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Diagnostics.CodeFixHelper.DiagnosticPropertyName">
      <summary>
            The name of the property representing the titles of code fixes.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Diagnostics.CodeFixHelper.DiagnosticPropertyValueSeparator">
      <summary>
            The character separating values in the code fix properties.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Diagnostics.CodeFixHelper.SuggestionDiagnostic">
      <summary>
            A <see cref="T:Metalama.Framework.Diagnostics.DiagnosticDefinition" /> that can be used to add code fixes. Requires a premium edition.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.DiagnosticDefinition">
      <summary>
            Defines a diagnostic that does not accept any parameters. For a diagnostic that accepts parameters, use <see cref="T:Metalama.Framework.Diagnostics.DiagnosticDefinition`1" />.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="T:Metalama.Framework.Diagnostics.DiagnosticDefinition`1">
      <summary>
            Defines a diagnostic with a strongly-typed set of parameters that are typically specified by using a named tuple for generic parameter
            <typeparamref name="T" />. For diagnostics that accept a single parameter, <typeparamref name="T" /> must be set to the type of this parameter.
            To accept several parameters, use a tuple.
            For a diagnostic that does not accept parameters, use <see cref="T:Metalama.Framework.Diagnostics.DiagnosticDefinition" />. 
            </summary>
      <typeparam name="T">Type of arguments: a single type if there is a single argument, or a named tuple type for several arguments
            Alternatively, you can also use <c>object[]</c>.
            </typeparam>
      <seealso href="@diagnostics" />
    </member>
    <member name="M:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.#ctor(System.String,Metalama.Framework.Diagnostics.Severity,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Diagnostics.DiagnosticDefinition`1" /> class.
            </summary>
      <param name="id">An unique identifier for the diagnostic (e.g. <c>MY001</c>).</param>
      <param name="severity">The severity of the diagnostic.</param>
      <param name="messageFormat">The formatting string of the diagnostic message.</param>
      <param name="title">An optional short title for the diagnostic. If no value is provided for this parameter, <paramref name="messageFormat" /> is used.</param>
      <param name="category">An optional category to which this diagnostic belong. The default value is <c>Metalama.User</c>.</param>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.Severity">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.Id">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.MessageFormat">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.Category">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.Title">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Diagnostics.DiagnosticDefinition`1.WithArguments(`0)">
      <summary>
            Creates an instance of the current diagnostic definition with specific arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.DiagnosticsQueryExtensions.ReportDiagnostic``1(Metalama.Framework.Fabrics.IQuery{``0},System.Func{``0,Metalama.Framework.Diagnostics.IDiagnostic})">
      <summary>
            Reports a diagnostic for each declaration selected by the the current object.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="diagnostic">A function returning an <see cref="T:Metalama.Framework.Diagnostics.IDiagnostic" /> given a declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.DiagnosticsQueryExtensions.SuppressDiagnostic``1(Metalama.Framework.Fabrics.IQuery{``0},System.Func{``0,Metalama.Framework.Diagnostics.SuppressionDefinition})">
      <summary>
            Suppresses a diagnostic for each declaration selected by the current object.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="suppression">A function returning a <see cref="T:Metalama.Framework.Diagnostics.SuppressionDefinition" /> given a declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.DiagnosticsQueryExtensions.ReportDiagnostic``2(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Func{``0,``1,Metalama.Framework.Diagnostics.IDiagnostic})">
      <summary>
            Reports a diagnostic for each declaration selected by the the current object.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="diagnostic">A function returning an <see cref="T:Metalama.Framework.Diagnostics.IDiagnostic" /> given a declaration.</param>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.DiagnosticsQueryExtensions.SuppressDiagnostic``2(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Func{``0,``1,Metalama.Framework.Diagnostics.SuppressionDefinition})">
      <summary>
            Suppresses a diagnostic for each declaration selected by the current object.
            </summary>
      <param name="query">A query selecting the declarations to validate.</param>
      <param name="suppression">A function returning a <see cref="T:Metalama.Framework.Diagnostics.SuppressionDefinition" /> given a declaration.</param>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.IDiagnostic">
      <summary>
            Represents an instance of a diagnostic, including its parameters and its optional code fixes.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnostic.Definition">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Diagnostics.IDiagnosticDefinition" /> from which the current diagnostic has been created.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnostic.Arguments">
      <summary>
            Gets the arguments of the current diagnostic.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.IDiagnosticDefinition">
      <summary>
            A non-generic base interface for <see cref="T:Metalama.Framework.Diagnostics.DiagnosticDefinition`1" />.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnosticDefinition.Severity">
      <summary>
            Gets the severity of the diagnostic.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnosticDefinition.Id">
      <summary>
            Gets an unique identifier for the diagnostic (e.g. <c>MY001</c>).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnosticDefinition.MessageFormat">
      <summary>
            Gets the formatting string of the diagnostic message.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnosticDefinition.Category">
      <summary>
            Gets the category of the diagnostic (e.g. your product name).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.IDiagnosticDefinition.Title">
      <summary>
            Gets a short title describing the diagnostic. This title is typically described in the solution explorer of the IDE
            and does not contain formatting string parameters.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.IDiagnosticLocation">
      <summary>
            A base interface for objects to which a diagnostic can be reported.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="T:Metalama.Framework.Diagnostics.IDiagnosticSink">
      <summary>
            A sink that reports diagnostics reported from user code.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="M:Metalama.Framework.Diagnostics.IDiagnosticSink.Report(Metalama.Framework.Diagnostics.IDiagnostic,Metalama.Framework.Diagnostics.IDiagnosticLocation,Metalama.Framework.Diagnostics.IDiagnosticSource)">
      <summary>
            Reports a parametric diagnostic by specifying its location.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.IDiagnosticSink.Suppress(Metalama.Framework.Diagnostics.ISuppression,Metalama.Framework.Code.IDeclaration,Metalama.Framework.Diagnostics.IDiagnosticSource)">
      <summary>
            Suppresses a diagnostic by specifying the declaration in which the suppression must be effective.
            </summary>
      <param name="suppression">The suppression.</param>
      <param name="scope">The declaration in which the diagnostic must be suppressed.</param>
      <param name="source"></param>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.IScopedDiagnosticSink.Report(Metalama.Framework.Diagnostics.IDiagnostic)">
      <summary>
            Reports a diagnostic to the default location of the current <see cref="T:Metalama.Framework.Diagnostics.ScopedDiagnosticSink" />..
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.IScopedDiagnosticSink.Suppress(Metalama.Framework.Diagnostics.ISuppression)">
      <summary>
            Suppresses a diagnostic from the default declaration of the current <see cref="T:Metalama.Framework.Diagnostics.ScopedDiagnosticSink" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.ISuppressibleDiagnostic">
      <summary>
            Represents a diagnostic that can be suppressed using <see cref="P:Metalama.Framework.Diagnostics.ISuppression.Filter" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ISuppressibleDiagnostic.Id">
      <summary>
            Gets the ID of the diagnostic (e.g. <c>CS0169</c>).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ISuppressibleDiagnostic.InvariantMessage">
      <summary>
            Gets the message of the diagnostic formatted using the invariant (English language) culture.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ISuppressibleDiagnostic.Arguments">
      <summary>
            Gets the arguments of the diagnostic message. These often include members or types related to the diagnostic.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ISuppressibleDiagnostic.Span">
      <summary>
            Gets the source file, line and column of the diagnostic, when available.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.ISuppression">
      <summary>
            Represents an instance of a diagnostic suppression, including an optional filter delegate.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ISuppression.Definition">
      <summary>
            Gets the definition of the suppression, containing the ID of the diagnostic to be suppressed.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ISuppression.Filter">
      <summary>
            Gets the optional filter delegate that will be applied to the diagnostics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.None">
      <summary>
            A type to be used as generic argument of <see cref="T:Metalama.Framework.Diagnostics.DiagnosticDefinition`1" /> when there is no parameter in the message.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.ScopedDiagnosticSink">
      <summary>
            Encapsulates an <see cref="T:Metalama.Framework.Diagnostics.IDiagnosticSink" /> and the default target of diagnostics, suppressions, and code fixes.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ScopedDiagnosticSink.DefaultTargetDeclaration">
      <summary>
            Gets the declaration on which diagnostics or code fixes will be reported or suppressed.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Diagnostics.ScopedDiagnosticSink.DefaultTargetLocation">
      <summary>
            Gets the location on which diagnostics or code fixes will be reported or suppressed.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.ScopedDiagnosticSink.Report(Metalama.Framework.Diagnostics.IDiagnostic)">
      <summary>
            Reports a diagnostic to the default location of the current <see cref="T:Metalama.Framework.Diagnostics.ScopedDiagnosticSink" />..
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.ScopedDiagnosticSink.Report(Metalama.Framework.Diagnostics.IDiagnostic,Metalama.Framework.Diagnostics.IDiagnosticLocation)">
      <summary>
            Reports a parametric diagnostic by specifying its location.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.ScopedDiagnosticSink.Suppress(Metalama.Framework.Diagnostics.ISuppression)">
      <summary>
            Suppresses a diagnostic from the default declaration of the current <see cref="T:Metalama.Framework.Diagnostics.ScopedDiagnosticSink" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.ScopedDiagnosticSink.Suppress(Metalama.Framework.Diagnostics.ISuppression,Metalama.Framework.Code.IDeclaration)">
      <summary>
            Suppresses a diagnostic by specifying the declaration in which the suppression must be effective.
            </summary>
      <param name="suppression">The suppression definition, which must be defined as a static field or property.</param>
      <param name="scope">The declaration in which the diagnostic must be suppressed.</param>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.Severity">
      <summary>
            Severity of diagnostics.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="F:Metalama.Framework.Diagnostics.Severity.Hidden">
      <summary>
            Something that is an issue, but is not surfaced through normal means.
            There may be different mechanisms that act on these issues.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Diagnostics.Severity.Info">
      <summary>
            Information that does not indicate a problem (i.e. not prescriptive).
            </summary>
    </member>
    <member name="F:Metalama.Framework.Diagnostics.Severity.Warning">
      <summary>
            Something suspicious but allowed.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Diagnostics.Severity.Error">
      <summary>
            Something not allowed by the rules of the aspect.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Diagnostics.SuppressionDefinition">
      <summary>
            Defines the suppression of a kind of diagnostics. Suppression definitions must be
            static fields or properties of an aspect classes. Suppressions are instantiated with <see cref="M:Metalama.Framework.Diagnostics.IDiagnosticSink.Suppress(Metalama.Framework.Diagnostics.ISuppression,Metalama.Framework.Code.IDeclaration,Metalama.Framework.Diagnostics.IDiagnosticSource)" />.
            </summary>
      <seealso href="@diagnostics" />
    </member>
    <member name="P:Metalama.Framework.Diagnostics.SuppressionDefinition.SuppressedDiagnosticId">
      <summary>
            Gets the ID of the diagnostic to be suppressed (e.g. <c>CS0169</c>).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.SuppressionDefinition.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Diagnostics.SuppressionDefinition" /> class.
            </summary>
      <param name="suppressedDiagnosticId">The ID of the diagnostic to be suppressed (e.g. <c>CS0169</c>).</param>
    </member>
    <member name="M:Metalama.Framework.Diagnostics.SuppressionDefinition.WithFilter(System.Func{Metalama.Framework.Diagnostics.ISuppressibleDiagnostic,System.Boolean})">
      <summary>
            Returns a new instance of the current suppression with a filter that will be applied to the diagnostics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Eligibility.DescribedObject`1">
      <summary>
            Encapsulates an object and a human-readable description.
            </summary>
      <typeparam name="T"></typeparam>
      <seealso href="@eligibility" />
    </member>
    <member name="P:Metalama.Framework.Eligibility.DescribedObject`1.Object">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Eligibility.DescribedObject`1.Description">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Eligibility.DescribedObjectExtensions">
      <summary>
            Extension methods for <see cref="T:Metalama.Framework.Eligibility.IDescribedObject`1" />.
            </summary>
      <seealso href="@eligibility" />
    </member>
    <member name="T:Metalama.Framework.Eligibility.EligibilityExtensions">
      <summary>
            Extension methods for <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.
            </summary>
      <seealso href="@eligibility" />
    </member>
    <member name="T:Metalama.Framework.Eligibility.EligibilityExtensions.Converter`1">
      <summary>
            A helper type that allows to convert an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1" /> for a type to an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1" /> of another type.  
            </summary>
      <typeparam name="T"></typeparam>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.Converter`1.To``1">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1" /> for another type. Adds an eligibility rule that the validated object must be of the specified type.
            If the validated object is not of the specified type, the parent eligibility rule fails.
            </summary>
      <seealso cref="M:Metalama.Framework.Eligibility.EligibilityExtensions.Converter`1.When``1" />
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.Converter`1.When``1">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for another type, but only adds the rule when the validated object is of the given type.
            If the validated object is not of the specified type, the child eligibility rule is ignored. Uses <see cref="M:Metalama.Framework.Eligibility.EligibilityExtensions.If``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Predicate{``0})" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.DeclaringType``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0})">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the declaring type of the member validated by the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.DeclaringMember(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the declaring method or property of the parameter validated by the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.Convert``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0})">
      <summary>
            Gets an object that allows to convert the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> into an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for a more specific type.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.ReturnType(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMethod})">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the return type of the method validated by the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.Parameter(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IHasParameters},System.Int32)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for a parameter of the method validated by the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />,
            identified by index.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.Parameter(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IHasParameters},System.String)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for a parameter of the method validated by the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />,
            identified by name.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.Type(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IHasType})">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the type of the declaration validated by the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.ForScenarios``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the same declaration as the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />
            but that is applicable only to specified <see cref="T:Metalama.Framework.Eligibility.EligibleScenarios" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.ExceptForScenarios``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the same declaration as the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />
            but that is not applicable to specified <see cref="T:Metalama.Framework.Eligibility.EligibleScenarios" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.ExceptForInheritance``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0})">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> for the same declaration as the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />
            but that is not applicable when the aspect is inheritable and is applied to a declaration that can be inherited or overridden.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustSatisfyAny``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Action{Metalama.Framework.Eligibility.IEligibilityBuilder{``0}}[])">
      <summary>
            Adds a group of conditions to the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />, where at least one condition must be satisfied
            by the declaration in order to be eligible for the aspect.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustSatisfyAll``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Action{Metalama.Framework.Eligibility.IEligibilityBuilder{``0}}[])">
      <summary>
            Adds a group of conditions to the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />, where all conditions must be satisfied
            by the declaration in order to be eligible for the aspect.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.If``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Predicate{``0})">
      <summary>
            Adds a rule to the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />, but only if the validate object satisfies a given predicate.
            Otherwise, the rule is ignored.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustSatisfy``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Predicate{``0},System.Func{Metalama.Framework.Eligibility.IDescribedObject{``0},System.FormattableString})">
      <summary>
            Adds a condition to the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />, where the condition must be
            satisfied by the declaration in order to be eligible for the aspect. The new rule is given as a <see cref="T:System.Predicate`1" />.
            </summary>
      <param name="eligibilityBuilder">The parent <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.</param>
      <param name="predicate">A predicate that returns <c>true</c> if the declaration is eligible for the aspect.</param>
      <param name="getJustification">A delegate called in case <paramref name="predicate" /> returns <c>false</c> and when
            the justification of the non-ineligibility is required. This delegate must return a <see cref="T:System.FormattableString" />, i.e. a C#
            interpolated string (<c>$"like {this}"</c>).</param>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.AddRules``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Action{Metalama.Framework.Eligibility.IEligibilityBuilder{``0}})">
      <summary>
            Adds rules to the given <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" /> by operating directly on the <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotHaveRefOrOutParameter(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMethod})">
      <summary>
            Requires the target method not to have <c>ref</c> or <c>out</c> parameters.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustHaveAccessibility(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMemberOrNamedType},Metalama.Framework.Code.Accessibility,Metalama.Framework.Code.Accessibility[])">
      <summary>
            Requires the target member to have exactly one of the given accessibilities.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBePartial(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMethod})">
      <summary>
            Requires the target method not to be partial.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBePartial(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMemberOrNamedType})">
      <summary>
            Requires the target declaration not to be partial.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeWritable(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer})">
      <summary>
            Requires the target property or indexer to be writable.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeReadable(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer})">
      <summary>
            Requires the target field, property or indexer to be writable.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeWritable(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Requires the target parameter to be writable, i.e. <c>ref</c> or <c>out</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeReadable(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Requires the parameter to be readable, i.e. not <c>out</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeReturnParameter(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Requires the parameter to be the return parameter.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeReturnParameter(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Forbids the parameter from being the return parameter.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeRef(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Requires the parameter to be <c>ref</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeVoid(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IParameter})">
      <summary>
            Requires the parameter not to be <c>void</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeExplicitlyDeclared(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IDeclaration})">
      <summary>
            Requires the declaration to be explicitly declared in source code.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeRef(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IFieldOrPropertyOrIndexer})">
      <summary>
            Forbids the field, property or indexer from being <c>ref</c> or <c>ref readonly</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeRef(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.INamedType})">
      <summary>
            Forbids the type from being <c>ref struct</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeRef(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMethod})">
      <summary>
            Forbids the method from returning a <c>ref</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeInstanceOfType``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Type)">
      <summary>
            Requires the validated object to be of a certain type of metadata object, e.g. an <see cref="T:Metalama.Framework.Code.IField" /> or <see cref="T:Metalama.Framework.Code.IMethod" />.
            To check the type of a field, property or parameter, use code like <c>builder.Type().MustBe(typeof(string));</c> instead.
            </summary>
      <remarks>
        <para>Note that this validates the object itself, not the declaration that it represents.
            For instance, if the object is an <see cref="T:Metalama.Framework.Code.IParameter" /> and the <paramref name="type" /> parameter is set to <c>typeof(string)</c>,
            this method will fail with an exception, because no conversion exists from <see cref="T:Metalama.Framework.Code.IParameter" /> to <c>string</c>.</para>
        <para>On the other hand, code like <c>builder.MustBeOfType(typeof(IProperty));</c> will correctly check that a declaration is a property.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeInstanceOfAnyType``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},System.Type[])">
      <summary>
            Requires the validated object to be of one of the specified types. Note that this validates the object itself, not the declaration
            that it represents. For instance, if the object is an <see cref="T:Metalama.Framework.Code.IParameter" /> and the <paramref name="types" /> parameter
            is set to <c>string</c>, this method will fail with an exception no conversion exists from <see cref="T:Metalama.Framework.Code.IParameter" /> to <c>string</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeRunTimeOnly(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.INamedType})">
      <summary>
            Requires the target type to be run-time, as opposed to compile-time or run-time-or-compile-time.
            </summary>
      <seealso cref="T:Metalama.Framework.Aspects.CompileTimeAttribute" />
      <seealso cref="T:Metalama.Framework.Aspects.RunTimeOrCompileTimeAttribute" />
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeStatic(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMemberOrNamedType})">
      <summary>
            Requires the target member or type to be static.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeStatic(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMemberOrNamedType})">
      <summary>
            Forbids the target member or type from being static.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeExtern(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMethod})">
      <summary>
            Forbids the target method from being extern.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeAbstract(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IMemberOrNamedType})">
      <summary>
            Forbids the target member or type from being abstract.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBePrimaryConstructor(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IConstructor})">
      <summary>
            Forbids the target constructor from being a primary constructor.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBePrimaryConstructorOfNonRecordType(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IConstructor})">
      <summary>
            Forbids the target constructor from being a primary constructor of a class or a struct (C# 12.0).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeRecordCopyConstructor(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IConstructor})">
      <summary>
            Forbids the target constructor from being the copy constructor of a record.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotBeInterface(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.INamedType})">
      <summary>
            Forbids the target type from being an interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeConvertibleTo(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IType},System.Type,Metalama.Framework.Code.ConversionKind)">
      <summary>
            Requires the target type to be convertible to a given type (specified as a reflection <see cref="T:System.Type" />).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeConvertibleTo(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IType},Metalama.Framework.Code.IType,Metalama.Framework.Code.ConversionKind)">
      <summary>
            Requires the target type to be convertible to a given type (specified as an <see cref="T:Metalama.Framework.Code.IType" />).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustBeConvertibleTo``1(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IType},Metalama.Framework.Code.ConversionKind)">
      <summary>
            Requires the target type to be convertible to a given type (specified as a type parameter).
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustHaveAspectOfType(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IDeclaration},System.Type)">
      <summary>
            Requires the target declaration to have an aspect of a given type.
            </summary>
      <param name="eligibilityBuilder">An <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1" /> for the target declaration.</param>
      <param name="aspectType">The exact aspect type. Derived types are not taken into account.</param>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.MustNotHaveAspectOfType(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IDeclaration},System.Type)">
      <summary>
            Forbids the target declaration from having an aspect of a given type.
            </summary>
      <param name="eligibilityBuilder">An <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1" /> for the target declaration.</param>
      <param name="aspectType">The exact aspect type. Derived types are not taken into account.</param>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.IsAspectEligible``1(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Determines whether the given declaration is an eligible target for a specified aspect type given as a type parameter.
            </summary>
      <param name="declaration">The declaration for which eligibility is determined.</param>
      <param name="scenarios">The scenarios for which eligibility is determined. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" />.</param>
      <typeparam name="T">The aspect type.</typeparam>
      <returns>
        <c>true</c> if <paramref name="declaration" /> is eligible for the aspect type <typeparamref name="T" /> for any of the specified <paramref name="scenarios" />.</returns>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.IsAspectEligible(Metalama.Framework.Code.IDeclaration,System.Type,Metalama.Framework.Eligibility.EligibleScenarios)">
      <summary>
            Determines whether the given declaration is an eligible target for a specified aspect type given as a reflection <see cref="M:Metalama.Framework.Eligibility.EligibilityExtensions.Type(Metalama.Framework.Eligibility.IEligibilityBuilder{Metalama.Framework.Code.IHasType})" />.
            </summary>
      <param name="declaration">The declaration for which eligibility is determined.</param>
      <param name="aspectType">The aspect type.</param>
      <param name="scenarios">The scenarios for which eligibility is determined. The default value is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.Default" />.</param>
      <returns>
        <c>true</c> if <paramref name="declaration" /> is eligible for the given <paramref name="aspectType" /> for any of the specified <paramref name="scenarios" />.</returns>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.IsAdviceEligible(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Advising.AdviceKind)">
      <summary>
            Determines whether the given declaration is an eligible target for a specified kind of advice.
            </summary>
      <param name="declaration">The declaration for which eligibility is determined.</param>
      <param name="adviceKind">Tha advice kind, but not <see cref="F:Metalama.Framework.Advising.AdviceKind.AddContract" />.</param>
      <returns>
        <c>true</c> if <paramref name="declaration" /> is eligible for the given <paramref name="adviceKind" />.</returns>
      <seealso cref="M:Metalama.Framework.Eligibility.EligibilityExtensions.IsContractAdviceEligible(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Aspects.ContractDirection)" />
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityExtensions.IsContractAdviceEligible(Metalama.Framework.Code.IDeclaration,Metalama.Framework.Aspects.ContractDirection)">
      <summary>
             Determines whether the given declaration is an eligible target for an <see cref="F:Metalama.Framework.Advising.AdviceKind.AddContract" /> advice for a given <see cref="T:Metalama.Framework.Aspects.ContractDirection" />.
            </summary>
      <param name="declaration">The declaration for which eligibility is determined.</param>
      <param name="contractDirection">The contract direction.</param>
      <returns>
        <c>true</c> if <paramref name="declaration" /> is eligible for an <see cref="F:Metalama.Framework.Advising.AdviceKind.AddContract" /> advice for the given <paramref name="contractDirection" />.</returns>
    </member>
    <member name="T:Metalama.Framework.Eligibility.EligibilityRuleFactory">
      <summary>
            Creates instances of the <see cref="T:Metalama.Framework.Eligibility.IEligibilityRule`1" /> interface, which can then be used by the <see cref="M:Metalama.Framework.Aspects.IAspectBuilder`1.VerifyEligibility(Metalama.Framework.Eligibility.IEligibilityRule{`0})" /> method.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityRuleFactory.GetAdviceEligibilityRule(Metalama.Framework.Advising.AdviceKind)">
      <summary>
            Gets the default eligibility rules that apply to a specific advice.
            The rules returned by this method are those used by classes <see cref="T:Metalama.Framework.Aspects.OverrideMethodAspect" />, <see cref="T:Metalama.Framework.Aspects.OverrideFieldOrPropertyAspect" />
            and so on. If you implement the <see cref="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})" /> method manually, you can use this method to get the base rules, and
            add only rules that are specific to your aspect.
            </summary>
      <param name="adviceKind">The kind of advice.</param>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityRuleFactory.GetContractAdviceEligibilityRule(Metalama.Framework.Aspects.ContractDirection)">
      <summary>
            Gets the default eligibility rules that apply to a contract advice for a specific direction.
            The rules returned by this method are those used by the <see cref="T:Metalama.Framework.Aspects.ContractAspect" /> class.
            If you implement the <see cref="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})" /> method manually, you can use this method to get the base rules, and
            add only rules that are specific to your aspect.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.EligibilityRuleFactory.CreateRule``1(System.Action{Metalama.Framework.Eligibility.IEligibilityBuilder{``0}},System.Action{Metalama.Framework.Eligibility.IEligibilityBuilder{``0}}[])">
      <summary>
            Create an instance of the <see cref="T:Metalama.Framework.Eligibility.IEligibilityRule`1" /> interface, which can then be used by the <see cref="M:Metalama.Framework.Aspects.IAspectBuilder`1.VerifyEligibility(Metalama.Framework.Eligibility.IEligibilityRule{`0})" /> method.
            </summary>
      <remarks>
            Eligibility rules are heavy and expensive objects although their evaluation is fast and efficient. It is recommended to store rules in static fields of the aspect. 
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Eligibility.EligibleScenarios">
      <summary>
            Enumeration of scenarios in which an aspect can be used.
            </summary>
      <seealso href="@eligibility" />
    </member>
    <member name="F:Metalama.Framework.Eligibility.EligibleScenarios.None">
      <summary>
            Means that the aspect or option can neither be applied to the target declaration, nor to declarations derived from the the
            target declaration, nor, for aspects, as a live template.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Eligibility.EligibleScenarios.Inheritance">
      <summary>
            Means that the aspect or option can be applied to declarations that are derived from the target declaration, but not on
            the target declaration itself.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Eligibility.EligibleScenarios.Default">
      <summary>
            Means that the aspect or option can be applied to the target declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Eligibility.EligibleScenarios.LiveTemplate">
      <summary>
            Means that the aspect or option can be used as a live template on the target declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Eligibility.EligibleScenarios.All">
      <summary>
            Means that the aspect or option can be used in any scenario.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Eligibility.IDescribedObject`1">
      <summary>
            Encapsulates an arbitrary object and its optional human-readable description.
            Implemented by <see cref="T:Metalama.Framework.Eligibility.DescribedObject`1" />.
            </summary>
      <typeparam name="T"></typeparam>
      <seealso href="@eligibility" />
    </member>
    <member name="P:Metalama.Framework.Eligibility.IDescribedObject`1.Object">
      <summary>
            Gets the described object.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Eligibility.IDescribedObject`1.Description">
      <summary>
            Gets the optional human-readable description of <see cref="P:Metalama.Framework.Eligibility.IDescribedObject`1.Object" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Eligibility.IEligibilityBuilder">
      <summary>
            The non-generic base interface for <see cref="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1" />.
            </summary>
      <seealso href="@eligibility" />
    </member>
    <member name="P:Metalama.Framework.Eligibility.IEligibilityBuilder.IneligibleScenarios">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Eligibility.EligibleScenarios" /> value that rules must return in case they evaluate negatively, i.e. what
            is the eligibility of the aspect on the target when the rule is <i>not</i> satisfied.  The default
            value of this property is <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.None" />, but it can be changed to anything
            using <see cref="M:Metalama.Framework.Eligibility.EligibilityExtensions.ExceptForScenarios``1(Metalama.Framework.Eligibility.IEligibilityBuilder{``0},Metalama.Framework.Eligibility.EligibleScenarios)" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Eligibility.IEligibilityBuilder.Build">
      <summary>
            Builds an immutable rule from the current builder instance.
            </summary>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Eligibility.IEligibilityBuilder`1">
      <summary>
            The argument of <see cref="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})" />. Allows the implementation to add requirements
            using methods of <see cref="T:Metalama.Framework.Eligibility.EligibilityExtensions" />.
            </summary>
      <typeparam name="T">Type of declaration.</typeparam>
      <seealso href="@eligibility" />
      <seealso cref="T:Metalama.Framework.Eligibility.EligibilityExtensions" />
    </member>
    <member name="M:Metalama.Framework.Eligibility.IEligibilityBuilder`1.AddRule(Metalama.Framework.Eligibility.IEligibilityRule{`0})">
      <summary>
            Adds a rule to the current builder. For convenience, user code should use extension methods
            from <see cref="T:Metalama.Framework.Eligibility.EligibilityExtensions" />. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Eligibility.IEligibilityRule`1">
      <summary>
            Encapsulates a predicate determining the eligibility of an object (typically a declaration or a type).
            </summary>
      <typeparam name="T">The type of object that the extension can be applied to.</typeparam>
      <seealso href="@eligibility" />
    </member>
    <member name="M:Metalama.Framework.Eligibility.IEligibilityRule`1.GetEligibility(`0)">
      <summary>
            Determines the eligibility of a given object for the current object extension.
            </summary>
      <param name="obj"></param>
      <returns></returns>
    </member>
    <member name="M:Metalama.Framework.Eligibility.IEligibilityRule`1.GetIneligibilityJustification(Metalama.Framework.Eligibility.EligibleScenarios,Metalama.Framework.Eligibility.IDescribedObject{`0})">
      <summary>
            Gets the justification for which the <see cref="M:Metalama.Framework.Eligibility.IEligibilityRule`1.GetEligibility(`0)" /> method returned anything else than <see cref="F:Metalama.Framework.Eligibility.EligibleScenarios.All" />. 
            </summary>
      <param name="requestedEligibility">The eligibility that was requested by the user, but denied.</param>
      <param name="describedObject">The object for which the eligibility was denied, plus its description.</param>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Eligibility.IEligible`1">
      <summary>
            An interface that allows aspect to specify to which declarations they are allowed to be applied.
            </summary>
      <typeparam name="T"></typeparam>
      <seealso href="@eligibility" />
    </member>
    <member name="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})">
      <summary>
            Configures the eligibility of the aspect or attribute.
            Implementations are not allowed to reference non-static members.
            Implementations must call the implementation of the base class if it exists.
            </summary>
      <param name="builder">An object that allows the aspect to configure characteristics like
            description, dependencies, or layers.</param>
      <remarks>
            Do not reference instance class members in your implementation of  <see cref="M:Metalama.Framework.Eligibility.IEligible`1.BuildEligibility(Metalama.Framework.Eligibility.IEligibilityBuilder{`0})" />.
            Indeed, this method is called on an instance obtained using <see cref="M:System.Runtime.Serialization.FormatterServices.GetUninitializedObject(System.Type)" />, that is,
            <i>without invoking the class constructor</i>.
            </remarks>
      <seealso href="@eligibility" />
    </member>
    <member name="T:Metalama.Framework.Fabrics.Fabric">
      <summary>
            Allows adding aspects or analyzing a project, namespace, or type just by adding a type inheriting this class.
            You cannot inherit this class directly, inherit from <see cref="T:Metalama.Framework.Fabrics.ProjectFabric" />, <see cref="T:Metalama.Framework.Fabrics.NamespaceFabric" />,
            or <see cref="T:Metalama.Framework.Fabrics.TypeFabric" /> instead.
            </summary>
      <seealso href="@fabrics-adding-aspects" />
    </member>
    <member name="P:Metalama.Framework.Fabrics.IAmender.Project">
      <summary>
            Gets the project being built.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.IAmender`1">
      <summary>
            Base interface for the argument of <see cref="M:Metalama.Framework.Fabrics.ProjectFabric.AmendProject(Metalama.Framework.Fabrics.IProjectAmender)" />, <see cref="M:Metalama.Framework.Fabrics.NamespaceFabric.AmendNamespace(Metalama.Framework.Fabrics.INamespaceAmender)" />
            or <see cref="M:Metalama.Framework.Fabrics.TypeFabric.AmendType(Metalama.Framework.Fabrics.ITypeAmender)" />. Allows to report diagnostics and add aspects to the target declaration of the fabric.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.IAmender`1.Outbound">
      <summary>
            Gets an object that allows to add child advice and to validate code and code references.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.IFabricInstance">
      <summary>
            Represents an instance of a <see cref="T:Metalama.Framework.Fabrics.Fabric" /> type including its <see cref="P:Metalama.Framework.Aspects.IAspectPredecessor.TargetDeclaration" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.IFabricInstance.Fabric">
      <summary>
            Gets the <see cref="T:Metalama.Framework.Fabrics.Fabric" /> instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.INamespaceAmender">
      <summary>
            Argument of <see cref="M:Metalama.Framework.Fabrics.NamespaceFabric.AmendNamespace(Metalama.Framework.Fabrics.INamespaceAmender)" />. Allows reporting diagnostics and adding aspects to the target declaration of the fabric. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.INamespaceAmender.Namespace">
      <summary>
            Gets the full name of the namespace on which the current fabric is applied.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.IProjectAmender">
      <summary>
            Argument of <see cref="M:Metalama.Framework.Fabrics.ProjectFabric.AmendProject(Metalama.Framework.Fabrics.IProjectAmender)" />. Allows reporting diagnostics and adding aspects to the target project. 
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.IQuery">
      <summary>
            The non-generic base interface for <see cref="T:Metalama.Framework.Fabrics.IQuery`1" />. Represents query of declarations to which
            aspects, validators, diagnostics and code fix suggestions can be added. This interface exposes LINQ-like methods that can be combined in complex queries.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.IQuery.Project">
      <summary>
            Gets the current project.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.IQuery.OriginatingNamespace">
      <summary>
            Gets the current namespace, i.e. the one of the originating fabric or aspect instance,
            or <c>null</c> if the current object does not belong to a namespace.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.IQuery.OriginatingDeclaration">
      <summary>
            Gets the declaration of the originating fabric or aspect instance.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.IQuery`1">
      <summary>
            Represents query of declarations to which aspects, validators, diagnostics and code fix suggestions can be added.
            This interface exposes LINQ-like methods that can be combined in complex queries.
            </summary>
      <typeparam name="TDeclaration">The type of declarations in the current set.</typeparam>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.SelectMany``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Projects each declaration of the current set to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> (typically a list of child declarations) and flattens the resulting sequences into one set.
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.IQuery`1.SelectMany``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})" /> is executed concurrently. It is therefore preferable to use the <see cref="M:Metalama.Framework.Fabrics.IQuery`1.Where(System.Func{`0,System.Boolean})" />, <see cref="M:Metalama.Framework.Fabrics.IQuery`1.Select``1(System.Func{`0,``0})" />
            or <see cref="M:Metalama.Framework.Fabrics.IQuery`1.SelectMany``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})" /> methods of the current interface instead of using the equivalent system methods inside the <paramref name="selector" /> query.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.Select``1(System.Func{`0,``0})">
      <summary>
            Projects each declaration of the current set into a new declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.SelectTypes(System.Boolean)">
      <summary>
            Selects all types enclosed in declarations of the current set. 
            </summary>
      <param name="includeNestedTypes">Indicates whether nested types should be recursively included in the output.</param>
      <remarks>
        <para>
            This method projects <see cref="T:Metalama.Framework.Code.ICompilation" /> and <see cref="T:Metalama.Framework.Code.INamespace" /> to all the types in the compilation or namespace.
            It projects <see cref="T:Metalama.Framework.Code.INamedType" /> to itself. It projects members or parameters to their declaring types.
            </para>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.IQuery`1.SelectTypes(System.Boolean)" /> is executed concurrently.</para>. 
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.SelectTypesDerivedFrom(System.Type,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Selects all types, among those enclosed in declarations of the current set, that derive from or implement a given <see cref="T:System.Type" />. 
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.IQuery`1.SelectTypes(System.Boolean)" /> is executed concurrently.</para>. 
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.SelectTypesDerivedFrom(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Selects all types, among those enclosed in declarations of the current set, that derive from or implement a given <see cref="T:Metalama.Framework.Code.INamedType" />. 
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.IQuery`1.SelectTypes(System.Boolean)" /> is executed concurrently.</para>. 
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.Where(System.Func{`0,System.Boolean})">
      <summary>
            Filters the set of declarations based on a predicate.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.OfType``1">
      <summary>
            Selects all declarations of a given type.
            </summary>
      <typeparam name="TOut">The type of selected declarations.</typeparam>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.WithTag``1(System.Func{`0,``0})">
      <summary>
            Projects the declarations in the current set by adding a tag for each declaration, and returns a <see cref="T:Metalama.Framework.Fabrics.ITaggedQuery`2" />.
            Methods of this interface have overloads that accept this tag. 
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.IQuery`1.ToCollection(Metalama.Framework.Code.ICompilation)">
      <summary>
            Evaluates the current query into a collection. This method should only be used for debugging or testing purposes.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectMany``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Projects each declaration of the current set to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> (typically a list of child declarations) and flattens the resulting sequences into one set.
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <c>SelectMany</c> is executed concurrently. It is therefore preferable to use the <c>Where</c>, <c>Select</c>
            or <c>SelectMany</c> methods of the current interface instead of using the equivalent system methods inside the <paramref name="selector" /> query.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectMany``1(System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Projects each declaration of the current set to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> (typically a list of child declarations) and flattens the resulting sequences into one set.
            This overload does supplies the tag to the <paramref name="selector" /> delegate.
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <c>SelectMany</c> is executed concurrently. It is therefore preferable to use the <c>Where</c>, <c>Select</c>
            or <c>SelectMany</c> methods of the current interface instead of using the equivalent system methods inside the <paramref name="selector" /> query.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.Select``1(System.Func{`0,``0})">
      <summary>
            Projects each declaration of the current set into a new declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.Select``1(System.Func{`0,`1,``0})">
      <summary>
            Projects each declaration of the current set into a new declaration.
            This overload does supplies the tag to the <paramref name="selector" /> delegate.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectTypes(System.Boolean)">
      <summary>
            Selects all types enclosed in declarations of the current set. 
            </summary>
      <param name="includeNestedTypes">Indicates whether nested types should be recursively included in the output.</param>
      <remarks>
        <para>
            This method projects <see cref="T:Metalama.Framework.Code.ICompilation" /> and <see cref="T:Metalama.Framework.Code.INamespace" /> to all the types in the compilation or namespace.
            It projects <see cref="T:Metalama.Framework.Code.INamedType" /> to itself. It projects members or parameters to their declaring types.
            </para>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectTypes(System.Boolean)" /> is executed concurrently.</para>. 
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectTypesDerivedFrom(System.Type,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Selects all types, among those enclosed in declarations of the current set, that derive from or implement a given <see cref="T:System.Type" />. 
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectTypes(System.Boolean)" /> is executed concurrently.</para>. 
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectTypesDerivedFrom(Metalama.Framework.Code.INamedType,Metalama.Framework.Code.DerivedTypesOptions)">
      <summary>
            Selects all types, among those enclosed in declarations of the current set, that derive from or implement a given <see cref="T:Metalama.Framework.Code.INamedType" />. 
            </summary>
      <remarks>
        <para>The query on the <i>right</i> part of <see cref="M:Metalama.Framework.Fabrics.ITaggedQuery`2.SelectTypes(System.Boolean)" /> is executed concurrently.</para>. 
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.Where(System.Func{`0,System.Boolean})">
      <summary>
            Filters the set of declarations based on a predicate.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.Where(System.Func{`0,`1,System.Boolean})">
      <summary>
            Filters the set of declarations based on a predicate.
            This overload does supplies the tag to the <paramref name="predicate" /> delegate.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.WithTag``1(System.Func{`0,``0})">
      <summary>
            Projects the declarations in the current set by replacing the tag of each declaration.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.ITaggedQuery`2.WithTag``1(System.Func{`0,`1,``0})">
      <summary>
            Projects the declarations in the current set by replacing the tag of each declaration.
            This overload does supplies the old tag to the <paramref name="getTag" /> delegate.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.ITypeAmender">
      <summary>
            Argument of <see cref="M:Metalama.Framework.Fabrics.TypeFabric.AmendType(Metalama.Framework.Fabrics.ITypeAmender)" />. Allows reporting diagnostics and adding aspects to the target declaration of the fabric. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.ITypeAmender.Type">
      <summary>
            Gets the target type of the current fabric (i.e. the declaring type of the nested type).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Fabrics.ITypeAmender.Advice">
      <summary>
            Gets an object that allows creating advice, e.g. overriding members, introducing members, or implementing new interfaces.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.NamespaceFabric">
      <summary>
            A class that, when inherited by a type in a given namespace, allows that type to analyze and
            add aspects to that namespace.
            </summary>
      <seealso href="@fabrics" />
      <seealso href="@aspect-configuration" />
      <seealso href="@fabrics-adding-aspects" />
    </member>
    <member name="M:Metalama.Framework.Fabrics.NamespaceFabric.AmendNamespace(Metalama.Framework.Fabrics.INamespaceAmender)">
      <summary>
            The user can implement this method to analyze types in the current namespace, add aspects, and report or suppress diagnostics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.ProjectFabric">
      <summary>
            A class that, when inherited by a type in a project (under any name or namespace), allows that type to analyze and
            add aspects to that project.
            </summary>
      <remarks>
            When the project contains several project fabrics, the ones whose source file is the closest to the root directory is executed
            first. The project fabrics are then ordered by type name.
            </remarks>
      <seealso href="@fabrics" />
      <seealso href="@aspect-configuration" />
      <seealso href="@fabrics-adding-aspects" />
    </member>
    <member name="M:Metalama.Framework.Fabrics.ProjectFabric.AmendProject(Metalama.Framework.Fabrics.IProjectAmender)">
      <summary>
            The user can implement this method to analyze types in the current project, add aspects, and report or suppress diagnostics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.QueryExtensions">
      <summary>
            Extends the <see cref="T:Metalama.Framework.Fabrics.IQuery`1" /> interface with some utility methods.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.QueryExtensions.SelectReferencedAssembly(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.ICompilation},System.String)">
      <summary>
            Selects a reference assembly in the current compilation given its assembly name.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.QueryExtensions.SelectDeclarationsWithAttribute``1(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.ICompilation},System.Func{``0,System.Boolean},System.Boolean)">
      <summary>
            Selects all custom attributes of a given type in the current compilation. This generic overloads constructs the attribute
            and accepts an optional predicate to filter the attribute.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.QueryExtensions.SelectDeclarationsWithAttribute(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.ICompilation},System.Type,System.Func{Metalama.Framework.Code.IAttribute,System.Boolean},System.Boolean)">
      <summary>
            Selects all custom attributes of a given type in the current compilation. This overloads
            accepts an optional predicate to filter the attribute.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.QueryExtensions.SelectReflectionType(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.ICompilation},System.Type)">
      <summary>
            Selects an <see cref="T:Metalama.Framework.Code.INamedType" /> in the current compilation or in a reference assembly given its reflection <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.QueryExtensions.SelectReflectionTypes(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.ICompilation},System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Selects several <see cref="T:Metalama.Framework.Code.INamedType" /> in the current compilation or in a reference assembly given their reflection <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Fabrics.QueryExtensions.SelectReflectionTypes(Metalama.Framework.Fabrics.IQuery{Metalama.Framework.Code.ICompilation},System.Type[])">
      <summary>
            Selects several <see cref="T:Metalama.Framework.Code.INamedType" /> in the current compilation or in a reference assembly given their reflection <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Fabrics.TransitiveProjectFabric">
      <summary>
            A class that, when inherited by a type in an assembly (under any name or namespace), allows that type to analyze and
            add aspects to any project that references this assembly. However, the <see cref="M:Metalama.Framework.Fabrics.ProjectFabric.AmendProject(Metalama.Framework.Fabrics.IProjectAmender)" /> method
            is not executed in the current project (you will need another class that does not implement <see cref="T:Metalama.Framework.Fabrics.TransitiveProjectFabric" />
            to amend the current project). 
            </summary>
      <remarks>
            When the project contains several transitive project fabrics, the ones that are the deepest in the dependency graph are
            executed first. Then, transitive fabrics are ordered by assembly name, then by distance to the root directory in the file system,
            then by type name.
            </remarks>
      <seealso href="@fabrics" />
      <seealso href="@exposing-configuration" />
      <seealso href="@fabrics-adding-aspects" />
    </member>
    <member name="T:Metalama.Framework.Fabrics.TypeFabric">
      <summary>
            An class that, when inherited by a nested type in a given type, allows that nested type to analyze and
            add aspects to the parent type.
            </summary>
      <seealso href="@fabrics" />
    </member>
    <member name="M:Metalama.Framework.Fabrics.TypeFabric.AmendType(Metalama.Framework.Fabrics.ITypeAmender)">
      <summary>
            The user can implement this method to analyze types in the declaring type, add aspects, and report or suppress diagnostics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Metrics.IMeasurable">
      <summary>
            Base interface for objects that can be extended with metrics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Metrics.IMetric">
      <summary>
            A weakly-typed base interface for <see cref="T:Metalama.Framework.Metrics.IMetric`1" />. Never implement directly. Always implement <see cref="T:Metalama.Framework.Metrics.IMetric`1" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Metrics.IMetric`1">
      <summary>
            Base interface for all metrics. This interface exists only for strong typing. It does not have any members.
            </summary>
      <remarks>
            When you implement you own metric, you also need to implement the <see cref="T:Metalama.Framework.Metrics.IMetricProvider`1" /> interface,
            and you need to add the service to the service provider (TODO).
            </remarks>
      <typeparam name="T">The type of objects for which the metric applies.</typeparam>
    </member>
    <member name="T:Metalama.Framework.Metrics.IMetricProvider`1">
      <summary>
            Implements the computation or reading of a metric.
            </summary>
      <typeparam name="T">Type of the metric handled by the current provider.</typeparam>
    </member>
    <member name="M:Metalama.Framework.Metrics.IMetricProvider`1.GetMetric(Metalama.Framework.Metrics.IMeasurable)">
      <summary>
            Computes and returns the metric for a given object.
            </summary>
      <param name="measurable">An object on which the metric is defined.</param>
      <returns>The metric value for <paramref name="measurable" />.</returns>
    </member>
    <member name="T:Metalama.Framework.Metrics.Metrics`1">
      <summary>
            Exposes a <see cref="M:Metalama.Framework.Metrics.Metrics`1.Get``1" /> method, which computes and returns a metric for an eligible object.
            </summary>
      <typeparam name="TMeasurable">The type extended with metrics.</typeparam>
    </member>
    <member name="M:Metalama.Framework.Metrics.Metrics`1.Get``1">
      <summary>
            Gets a given metric for the current object.
            </summary>
      <typeparam name="TExtension">The type of metric to be returned.</typeparam>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Metrics.MetricsExtensions">
      <summary>
            Exposes metrics to eligible objects.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Metrics.MetricsExtensions.Metrics``1(``0)">
      <summary>
            Gets an object that allows to get metrics.
            </summary>
      <param name="extensible">The object which metrics are requested.</param>
      <typeparam name="TExtensible">The type of object for which objects are requested.</typeparam>
      <returns></returns>
    </member>
    <member name="T:Metalama.Framework.Options.ApplyChangesAxis">
      <summary>
            Enumerates the axes along which two option layers can be merged by the <see cref="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)" /> method. 
            </summary>
    </member>
    <member name="F:Metalama.Framework.Options.ApplyChangesAxis.SameDeclaration">
      <summary>
            Means that options directly applied to the declaration override other options also directly applied to the declaration.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Options.ApplyChangesAxis.ContainingDeclaration">
      <summary>
            Means that options on the containing declaration (typically the declaring type, but not the namespace, which are specified by the
            <see cref="F:Metalama.Framework.Options.ApplyChangesAxis.BaseDeclaration" /> axis) override the options defined in the base declaration.
            For instance, type-level options on the declaring type of an <c>override</c> method override method-level options on the <c>base</c> method.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Options.ApplyChangesAxis.BaseDeclaration">
      <summary>
            Means that options on the base type or overridden member override the options inherited from the namespace or the default options.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Options.ApplyChangesAxis.TargetDeclaration">
      <summary>
            Means that options directly applied to the declaration override options inherited along the containment or base axis.
            </summary>
    </member>
    <member name="F:Metalama.Framework.Options.ApplyChangesAxis.Aspect">
      <summary>
            Means that options defined by the aspect instance itself override any other option.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.ApplyChangesContext">
      <summary>
            Context of an <see cref="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)" /> operation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.ApplyChangesContext.Axis">
      <summary>
            Gets the axis along which the override operation is performed.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.ApplyChangesContext.Declaration">
      <summary>
            Gets the declaration for which the override operation is performed.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.HierarchicalOptionsAttribute">
      <summary>
            Custom attribute that, when applied to a class implementing the <see cref="T:Metalama.Framework.Options.IHierarchicalOptions" /> interface,
            specifies how the options are inherited.
            </summary>
      <seealso href="@exposing-options" />
    </member>
    <member name="P:Metalama.Framework.Options.HierarchicalOptionsAttribute.InheritedByDerivedTypes">
      <summary>
            Gets or sets a value indicating that the options are inherited from the base type to derived types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.HierarchicalOptionsAttribute.InheritedByOverridingMembers">
      <summary>
            Gets or sets a value indicating that the options are inherited from the base virtual member to the overridden members. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.HierarchicalOptionsAttribute.InheritedByNestedTypes">
      <summary>
            Gets or sets a value indicating that the options are inherited from the enclosing type to the nested types.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.HierarchicalOptionsAttribute.InheritedByMembers">
      <summary>
            Gets or sets a value indicating that the options are inherited from the declaring type to its members.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IHierarchicalOptions">
      <summary>
            Base interface for hierarchical options. Hierarchical options are options exposed and consumed by
            aspects and fabrics. Users can typically set options at different levels of the code level: for the
            whole project, for a namespace, for a type, or for a member, as decided by the aspect author.
            </summary>
      <remarks>
        <para>
             Users typically set options from a fabric using the <see cref="M:Metalama.Framework.Options.OptionQueryExtensions.SetOptions``2(Metalama.Framework.Fabrics.IQuery{``0},System.Func{``0,``1})" />
            method of the <see cref="P:Metalama.Framework.Fabrics.IAmender`1.Outbound" /> object.
            </para>
        <para>
             Implementations of this class must be immutable. An instance of this object represents a <i>layer</i> of options,
             and these layers are merged by the <see cref="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)" /> method. Therefore, all properties should typically be nullable or
             support another representation of being unset.
            </para>
        <para>
            Classes that implement this interface must implement the <see cref="T:Metalama.Framework.Options.IHierarchicalOptions`1" /> generic interface where <c>T</c> is
            the type of declarations for which the user is allowed to set the options. Typically, a single class would implement several instances
            of this instance. For instance, for an option affecting a method-level aspect, a good practice is to implement this interface
            for <see cref="T:Metalama.Framework.Code.ICompilation" />, <see cref="T:Metalama.Framework.Code.INamespace" />, <see cref="T:Metalama.Framework.Code.INamedType" /> and <see cref="T:Metalama.Framework.Code.IMethod" />.
            </para>
        <para>
            Classes that implement this interface can be annotated with the <see cref="T:Metalama.Framework.Options.HierarchicalOptionsAttribute" /> custom attribute,
            which allows authors to customize the inheritance mechanisms of the option.
            </para>
        <para>
            Attribute classes and aspect classes can implement the <see cref="T:Metalama.Framework.Options.IHierarchicalOptionsProvider" /> interface if they want to contribute
            options.
            </para>
        <para>
            Options are exposed by the <c>declaration.</c><see cref="M:Metalama.Framework.Code.DeclarationExtensions.Enhancements``1(``0)" />.<see cref="M:Metalama.Framework.Code.DeclarationEnhancements`1.GetOptions``1" /> method.
            </para>
      </remarks>
      <seealso href="@exposing-options" />
    </member>
    <member name="M:Metalama.Framework.Options.IHierarchicalOptions.GetDefaultOptions(Metalama.Framework.Options.OptionsInitializationContext)">
      <summary>
            Gets the default options from the current project. 
            </summary>
      <returns>The default options for the given project, or <c>null</c> if the default value is the instance initialized by the default constructor.</returns>
      <remarks>
        <para>
             If the aspect supports parameters supplied as MSBuild project properties, the implementation of this
             method should read these properties and assign their values to the returned object. Otherwise, it can return <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Options.IHierarchicalOptions`1">
      <summary>
            An interface, derived from the non-generic <see cref="T:Metalama.Framework.Options.IHierarchicalOptions" />, that means that the options can be set
            on the type of declarations specified by the generic parameter.
            </summary>
      <typeparam name="T">The type of declarations on which the options can be set or read.</typeparam>
      <remarks>
             See the remarks for the non-generic <see cref="T:Metalama.Framework.Options.IHierarchicalOptions" /> interface.
            </remarks>
      <seealso cref="T:Metalama.Framework.Options.IHierarchicalOptions" />
    </member>
    <member name="T:Metalama.Framework.Options.IHierarchicalOptionsManager">
      <summary>
            Provides read-only access to hierarchical options.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IHierarchicalOptionsProvider">
      <summary>
            A base interface for attributes that provide options.
            </summary>
      <seealso href="@exposing-options" />
    </member>
    <member name="M:Metalama.Framework.Options.IHierarchicalOptionsProvider.GetOptions(Metalama.Framework.Options.OptionsProviderContext@)">
      <summary>
            Gets the list of options provided by the current aspect or attribute.
            </summary>
      <param name="context"></param>
      <returns>The list of options.</returns>
      <remarks>
        <para>
                This interface behaves differently when applied to plain custom attributes than when applied to aspects.
            </para>
        <para>
                When applied to plain custom attributes, the <see cref="M:Metalama.Framework.Options.IHierarchicalOptionsProvider.GetOptions(Metalama.Framework.Options.OptionsProviderContext@)" /> method is invoked immediately in the first stage
                of the compilation process, therefore the provided options are immediately available for readers.
            </para>
        <para>
                However, when the interface is implemented by an aspect, i.e. any class implementing the <see cref="T:Metalama.Framework.Aspects.IAspect" /> interface,
                the <see cref="M:Metalama.Framework.Options.IHierarchicalOptionsProvider.GetOptions(Metalama.Framework.Options.OptionsProviderContext@)" /> method is called right before the <see cref="M:Metalama.Framework.Aspects.IAspect`1.BuildAspect(Metalama.Framework.Aspects.IAspectBuilder{`0})" /> method of the aspect
                is invoked. The provided options are therefore only available to the current aspect instance and any code executing after
                this aspect instance.
            </para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Options.IIncrementalKeyedCollectionItem`1">
      <summary>
            An item in a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" />.
            </summary>
      <seealso href="@exposing-options" />
    </member>
    <member name="P:Metalama.Framework.Options.IIncrementalKeyedCollectionItem`1.Key">
      <summary>
            Gets the key that uniquely identifies the item in the collection.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IIncrementalObject">
      <summary>
            A base interface for all classes whose individual instances represent incremental changes that can be combined
            with the <see cref="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)" /> method.
            </summary>
      <seealso href="@exposing-options" />
    </member>
    <member name="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)">
      <summary>
            Returns an object where the properties of the current objects are overwritten or complemented by
            the properties of another given object, except if these properties are not set.
            </summary>
      <param name="changes">The object being applied on the current object, which property values, if they are set, take precedence
            over the ones of the current object.</param>
      <param name="context">Information about the context of the current operation. </param>
      <returns>A new immutable instance of the same class.</returns>
    </member>
    <member name="T:Metalama.Framework.Options.IncrementalHashSet">
      <summary>
            Factory methods for the <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> generic class.
            </summary>
      <seealso href="@exposing-options" />
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Empty``1">
      <summary>
            Creates  new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the absence of any operation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Clear``1">
      <summary>
            Creates  new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation clearing
            the collection of all items.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Add``1(``0)">
      <summary>
            Creates  new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation of adding an item to
            the collection, or to override with a new value if these items already exist.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Add``1(``0[])">
      <summary>
            Creates  new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation of adding items to
            the collection, or to override with a new value if these items already exist.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Add``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates  new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation of adding items to
            the collection, or to override with a new value if these items already exist.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Remove``1(``0)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the option of removing an item
            from the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Remove``1(``0[])">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the option of removing items
            from the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet.Remove``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the option of removing items
            from the collection.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IncrementalHashSet`1">
      <summary>
            An immutable hash set where each class instance does not represent the full set but a modification of another set (possibly empty).
            This class implements the <see cref="T:Metalama.Framework.Options.IIncrementalObject" /> interface and can be easily used in the context of an <see cref="T:Metalama.Framework.Options.IHierarchicalOptions`1" />.
            The class can represent the <see cref="M:Metalama.Framework.Options.IncrementalHashSet`1.Add(`0)" />, <see cref="M:Metalama.Framework.Options.IncrementalHashSet`1.Remove(`0)" /> and <see cref="M:Metalama.Framework.Options.IncrementalHashSet.Clear``1" /> operations.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
    </member>
    <member name="P:Metalama.Framework.Options.IncrementalHashSet`1.Empty">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the absence of any change in the collection.
            </summary>
      <remarks>
            If you are looking for an object resulting in an empty collection even if the previous collection is not empty,
            use <see cref="M:Metalama.Framework.Options.IncrementalHashSet.Clear``1" />.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.Add(`0)">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation of adding an item to the collection,
            additionally to any operation represented by the current collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.Add(`0[])">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation of adding items to
            the collection, additionally to any operation represented by the current collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.Add(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the operation of adding items to
            the collection, additionally to any operation represented by the current collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.Remove(`0)">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the option of removing an item
            from the collection, additionally to any operation represented by the current object.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.Remove(`0[])">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the option of removing a items
            from the collection, additionally to any operation represented by the current object.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.Remove(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new <see cref="T:Metalama.Framework.Options.IncrementalHashSet`1" /> that represents the option of removing a items
            from the , additionally to any operation represented by the current object.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.IncrementalHashSet`1.Count">
      <summary>
            Gets the number of items in the current collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalHashSet`1.ApplyChanges(Metalama.Framework.Options.IncrementalHashSet{`0},Metalama.Framework.Options.ApplyChangesContext@)">
      <summary>
            Overrides the current collection with another collection and returns the result.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IncrementalKeyedCollection">
      <summary>
            Factory for the generic <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> class.
            </summary>
      <seealso href="@exposing-options" />
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.Empty``2">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the absence of any operation.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.Clear``2">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the operation of removing any item both in the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.AddOrApplyChanges``2(``1)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the operation of adding an item to
            the collection, or, if an item with the same key already exists, update this item with the given new values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.AddOrApplyChanges``2(``1[])">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the operation of adding items to
            the collection, or, if any item with the same key already exists, update these item with the given new values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.AddOrApplyChanges``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the operation of adding items to
            the collection, or, if any item with the same key already exists, update these item with the given new values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.Remove``2(``1)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the option of removing an item
            from the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.Remove``2(``1[])">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the option of removing items
            from the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection.Remove``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the option of removing items
            from the collection.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IncrementalKeyedCollection`2">
      <summary>
            An immutable keyed collection where each class instance does not represent the full collection but a modification of another collection (possibly empty).
            This class implements the <see cref="T:Metalama.Framework.Options.IIncrementalObject" /> interface and can be easily used in the context of an <see cref="T:Metalama.Framework.Options.IHierarchicalOptions`1" />.
            The class can represent the <see cref="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.AddOrApplyChanges(`1)" />, <see cref="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.Remove(`0)" /> and <see cref="M:Metalama.Framework.Options.IncrementalKeyedCollection.Clear``2" /> operations.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of items, implementing the <see cref="T:Metalama.Framework.Options.IIncrementalKeyedCollectionItem`1" /> interface.</typeparam>
    </member>
    <member name="P:Metalama.Framework.Options.IncrementalKeyedCollection`2.Empty">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that represents the absence of any change in the collection.
            </summary>
      <remarks>
            If you are looking for an object resulting in an empty collection even if the previous collection is not empty,
            use <see cref="M:Metalama.Framework.Options.IncrementalKeyedCollection.Clear``2" />.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.AddOrApplyChanges(`1)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that contains all operations already contained in the current object,
            plus the operation of adding an item, or, if an item with the same key already exists, update it with the given new values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.AddOrApplyChanges(`1[])">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that contains all operations already contained in the current object,
            plus the operation of adding items, or, if any item with the same key already exists, update it with the given new values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.AddOrApplyChanges(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that contains all operations already contained in the current object,
            plus the operation of adding items, or, if any item with the same key already exists, update it with the given new values.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.Remove(`0)">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that contains all operations already contained in the current object,
            plus the operation of removing an item from the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.Remove(`0[])">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that contains all operations already contained in the current object,
            plus the operation of removing items from the collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.Remove(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a <see cref="T:Metalama.Framework.Options.IncrementalKeyedCollection`2" /> that contains all operations already contained in the current object,
            plus the operation of removing items from the collection.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.IncrementalKeyedCollection`2.Count">
      <summary>
            Gets the number of items in the current collection.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalKeyedCollection`2.ApplyChanges(Metalama.Framework.Options.IncrementalKeyedCollection{`0,`1},Metalama.Framework.Options.ApplyChangesContext@)">
      <summary>
            Overrides the current collection with another collection and returns the result.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.IncrementalObjectExtensions">
      <summary>
            Extensions of the <see cref="T:Metalama.Framework.Options.IIncrementalObject" /> interface.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalObjectExtensions.ApplyChangesSafe``1(``0,``0,Metalama.Framework.Options.ApplyChangesContext@)">
      <summary>
            Invokes <see cref="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)" /> in a type- and nullable-safe way.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.IncrementalObjectExtensions.ApplyChanges``1(``0,``0,Metalama.Framework.Options.ApplyChangesContext@)">
      <summary>
            Invokes <see cref="M:Metalama.Framework.Options.IIncrementalObject.ApplyChanges(System.Object,Metalama.Framework.Options.ApplyChangesContext@)" /> in a type--safe way.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Options.OptionQueryExtensions.SetOptions``2(Metalama.Framework.Fabrics.IQuery{``0},System.Func{``0,``1})">
      <summary>
            Sets options for the declarations in the current set of declarations by supplying a <see cref="T:System.Func`1" />.
            </summary>
      <param name="query">The declarations for which the options must be set.</param>
      <param name="getOptions">A function giving the options for the given declaration.</param>
      <typeparam name="TOptions">The type of options.</typeparam>
      <typeparam name="TDeclaration">The type of declarations selected by the query.</typeparam>
      <remarks>
            This method should only set the option properties that need to be changed. All unchanged properties must be let null.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Options.OptionQueryExtensions.SetOptions``2(Metalama.Framework.Fabrics.IQuery{``0},``1)">
      <summary>
            Sets options for the declarations in the current set of declarations by supplying a <see cref="T:System.Func`1" />.
            </summary>
      <param name="query">The declarations for which the options must be set.</param>
      <param name="options">The options.</param>
      <typeparam name="TOptions">The type of options.</typeparam>
      <typeparam name="TDeclaration">The type of declarations selected by the query.</typeparam>
      <remarks>
            This method should only set the option properties that need to be changed. All unchanged properties must be let null.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Options.OptionQueryExtensions.SetOptions``3(Metalama.Framework.Fabrics.ITaggedQuery{``0,``1},System.Func{``0,``1,``2})">
      <summary>
            Sets options for the declarations in the current set of declarations by supplying a <see cref="T:System.Func`1" />.
            </summary>
      <param name="query">The declarations for which the options must be set.</param>
      <param name="getOptions">A function giving the options for the given declaration.</param>
      <typeparam name="TDeclaration">The type of declarations selected by the query.</typeparam>
      <typeparam name="TOptions">The type of options.</typeparam>
      <typeparam name="TTag">The type of the tag.</typeparam>
      <remarks>
            This method should only set the option properties that need to be changed. All unchanged properties must be let null.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Options.OptionsInitializationContext">
      <summary>
            Context of the <see cref="M:Metalama.Framework.Options.IHierarchicalOptions.GetDefaultOptions(Metalama.Framework.Options.OptionsInitializationContext)" /> method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.OptionsInitializationContext.Project">
      <summary>
            Gets the current project.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Options.OptionsInitializationContext.Diagnostics">
      <summary>
            Gets a service allowing to report diagnostics.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Options.OptionsProviderContext">
      <summary>
            Context for the <see cref="T:Metalama.Framework.Options.IHierarchicalOptionsProvider" />.<see cref="M:Metalama.Framework.Options.IHierarchicalOptionsProvider.GetOptions(Metalama.Framework.Options.OptionsProviderContext@)" /> method.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Project.IExecutionContext">
      <summary>
            Represents the execution context of Metalama. Exposed by the <see cref="P:Metalama.Framework.Project.MetalamaExecutionContext.Current" /> property of <see cref="T:Metalama.Framework.Project.MetalamaExecutionContext" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionContext.ServiceProvider">
      <summary>
            Gets the <see cref="T:System.IServiceProvider" />.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionContext.FormatProvider">
      <summary>
            Gets the <see cref="T:System.IFormatProvider" />, used to format formattable strings. This format provider will properly format elements of the code model
            and other similar objects.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionContext.Compilation">
      <summary>
            Gets the current compilation.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionContext.ExecutionScenario">
      <summary>
            Gets information about why the current code is executed and what are the abilities of the current execution context.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Project.IExecutionContext.WithoutDependencyCollection">
      <summary>
            Disables the mechanism of dependency collection in the current execution context.
            </summary>
      <returns>A cookie that must be restored to restore the execution context to its original state.</returns>
    </member>
    <member name="T:Metalama.Framework.Project.IExecutionScenario">
      <summary>
            Exposes the properties of the scenarios in which an aspect, template, or fabric is being executed. The interface is accessible
            from the <see cref="T:Metalama.Framework.Project.MetalamaExecutionContext" /> class.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionScenario.Name">
      <summary>
            Gets the name of the scenario. Callers should not rely on this scenario. Instead, it should rely on the other properties
            of this interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionScenario.IsDesignTime">
      <summary>
            Gets a value indicating whether Metalama is currently executing at design time. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionScenario.CapturesNonObservableTransformations">
      <summary>
            Gets a value indicating whether the current execution context is interested by non-observable transformations, i.e. transformations
            that affect the implementation of an existing declaration, but does not add, remove or modify characteristics that are observable
            outside of the declaration. It is generally useless to add non-observable transformations in a context that does not support them
            (they will be ignored anyway).
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionScenario.CapturesCodeFixImplementations">
      <summary>
            Gets a value indicating whether the current execution context is interested by the implementation of code fixes. The only
            situation when Metalama is interested by the code fix implementation is when the user actually selects a code fix, either
            for preview or for execution. In other scenarios, the implementation is dropped. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IExecutionScenario.CapturesCodeFixTitles">
      <summary>
            Gets a value indicating whether the current execution context is interested by the titles of code fixes. This does <i>not</i> imply
            <see cref="P:Metalama.Framework.Project.IExecutionScenario.CapturesCodeFixImplementations" />.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Project.IProject">
      <summary>
            Exposes the properties of the current C# project, such as <see cref="P:Metalama.Framework.Project.IProject.Path" />, <see cref="P:Metalama.Framework.Project.IProject.AssemblyReferences" />, <see cref="P:Metalama.Framework.Project.IProject.PreprocessorSymbols" />,
            <see cref="P:Metalama.Framework.Project.IProject.Configuration" /> or <see cref="P:Metalama.Framework.Project.IProject.TargetFramework" />. To access a custom MSBuild property, use <see cref="M:Metalama.Framework.Project.IProject.TryGetProperty(System.String,System.String@)" />. You can extend
            this interface with your own framework-specific by using the <see cref="M:Metalama.Framework.Project.IProject.Extension``1" /> method.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.Name">
      <summary>
            Gets the project name, i.e. the <see cref="P:Metalama.Framework.Project.IProject.Path" /> without the directory and without the extension.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.AssemblyName">
      <summary>
            Gets the name of the assembly produced by the project.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.Path">
      <summary>
            Gets the path to the <c>csproj</c> file.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.AssemblyReferences">
      <summary>
            Gets the list of assembly references of the current project.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.PreprocessorSymbols">
      <summary>
            Gets the list of defined preprocessor symbols like <c>DEBUG</c>, <c>TRACE</c>, <c>NET5_0_OR_GREATER</c> and so on.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.Configuration">
      <summary>
            Gets the name of the build configuration, for instance <c>Debug</c> or <c>Release</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.TargetFramework">
      <summary>
            Gets the identifier of the target framework, for instance <c>netstandard2.0</c>.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Project.IProject.TryGetProperty(System.String,System.String@)">
      <summary>
            Gets the set of properties passed from MSBuild. To expose an MSBuild property to this collection,
            define the <c>CompilerVisibleProperty</c> item. 
            </summary>
      <seealso href="@reading-msbuild-properties" />
    </member>
    <member name="M:Metalama.Framework.Project.IProject.Extension``1">
      <summary>
            Gets a project extension object or creates a new instance if none has been created before. The type must derive from <see cref="T:Metalama.Framework.Project.ProjectExtension" />
            and have a default constructor. New instances will be initialized using <see cref="M:Metalama.Framework.Project.ProjectExtension.Initialize(Metalama.Framework.Project.IProject,System.Boolean)" />.
            </summary>
      <typeparam name="T">The extension type, which must derive from <see cref="T:Metalama.Framework.Project.ProjectExtension" /> and have a default constructor.</typeparam>
    </member>
    <member name="P:Metalama.Framework.Project.IProject.ServiceProvider">
      <summary>
            Gets an <see cref="T:Metalama.Framework.Services.IServiceProvider`1" /> that gives access to the compiler services exposed using the <c>[CompileTimePlugIn]</c> facility.
            Only interfaces that derive from <see cref="T:Metalama.Framework.Services.IProjectService" /> are accessible from this property.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Project.MetalamaExecutionContext">
      <summary>
            Exposes the current execution context of Metalama.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Project.MetalamaExecutionContext.Current">
      <summary>
            Gets the current execution context, or throws an exception if there no execution context.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Project.ProjectExtension">
      <summary>
            An base class that must be implemented by classes that want to extend <see cref="T:Metalama.Framework.Project.IProject" /> with project-local configuration data using
            the <see cref="M:Metalama.Framework.Project.IProject.Extension``1" /> method.
            </summary>
      <remarks>
            The implementation must not allow modifications of the state after the object has been made read only.
            </remarks>
      <seealso href="@aspect-configuration" />
    </member>
    <member name="M:Metalama.Framework.Project.ProjectExtension.Initialize(Metalama.Framework.Project.IProject,System.Boolean)">
      <summary>
            Initializes the object from project properties.
            </summary>
      <param name="project">The project to which the new <see cref="T:Metalama.Framework.Project.ProjectExtension" /> belongs.</param>
      <param name="isReadOnly">A value indicating whether the project data is already read-only. If <c>false</c>, the project data
            can still be modified by project fabrics, after which the <see cref="M:Metalama.Framework.Project.ProjectExtension.MakeReadOnly" /> method will be called.</param>
    </member>
    <member name="M:Metalama.Framework.Project.ProjectExtension.MakeReadOnly">
      <summary>
            Signals that further modifications of the object must be prevented.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Project.ServiceProviderExtensions">
      <summary>
            Provides extensions methods to the <see cref="T:System.IServiceProvider" /> interface.
            </summary>
      <seealso cref="T:Metalama.Framework.Services.IGlobalService" />
    </member>
    <member name="T:Metalama.Framework.RunTime.FieldOrPropertyInfo">
      <summary>
            Represents a reflection <see cref="T:System.Reflection.FieldInfo" /> or a <see cref="T:System.Reflection.PropertyInfo" />. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.RunTime.FieldOrPropertyInfo.AsField">
      <summary>
            Gets the <see cref="T:System.Reflection.FieldInfo" /> if this represents a field, otherwise returns null.
            </summary>
    </member>
    <member name="P:Metalama.Framework.RunTime.FieldOrPropertyInfo.AsPropertyOrIndexer">
      <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo" /> if this represents a property, otherwise returns null.
            </summary>
    </member>
    <member name="M:Metalama.Framework.RunTime.FieldOrPropertyInfo.#ctor(System.Reflection.FieldInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.RunTime.FieldOrPropertyInfo" /> class that represents a field.
            </summary>
      <param name="fieldInfo">The field.</param>
    </member>
    <member name="M:Metalama.Framework.RunTime.FieldOrPropertyInfo.#ctor(System.Reflection.PropertyInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.RunTime.FieldOrPropertyInfo" /> class that represents a property.
            </summary>
      <param name="fieldInfo">The field.</param>
      <param name="propertyInfo">The property.</param>
    </member>
    <member name="T:Metalama.Framework.RunTime.RunTimeAspectHelper">
      <summary>
            Defines helper methods used by code transformed by aspects.
            </summary>
    </member>
    <member name="M:Metalama.Framework.RunTime.RunTimeAspectHelper.Buffer``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Evaluates an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and stores the result into a <see cref="T:System.Collections.Generic.List`1" />. If the enumerable is already
            a list, returns the input list. The intended side effect of this method is to completely evaluate the input enumerable.
            </summary>
      <param name="enumerable">An enumerable.</param>
      <typeparam name="T"></typeparam>
      <returns>A <see cref="T:System.Collections.Generic.List`1" /> made from the items of <paramref name="enumerable" />, or the <paramref name="enumerable" /> object itself
            it is already a <see cref="T:System.Collections.Generic.List`1" />.</returns>
    </member>
    <member name="M:Metalama.Framework.RunTime.RunTimeAspectHelper.Buffer(System.Collections.IEnumerable)">
      <summary>
            Evaluates an <see cref="T:System.Collections.IEnumerable" /> and stores the result into a <c>List&lt;object&gt;</c>. If the enumerable is already
            a list, returns the input list.  The intended side effect of this method is to completely evaluate the input enumerable.
            </summary>
      <param name="enumerable">An enumerable.</param>
      <returns>A <c>List&lt;object&gt;</c> made from the items of <paramref name="enumerable" />, or the <paramref name="enumerable" /> object itself
            it is already a <c>List&lt;object&gt;</c>.</returns>
    </member>
    <member name="M:Metalama.Framework.RunTime.RunTimeAspectHelper.Buffer``1(System.Collections.Generic.IEnumerator{``0})">
      <summary>
            Evaluates an <see cref="T:System.Collections.Generic.IEnumerator`1" />, stores the result into a <see cref="T:System.Collections.Generic.List`1" /> and returns an enumerator for this list.
            If the enumerator is already a list enumerator, returns the input  enumerator.
             The intended side effect of this method is to completely evaluate the input enumerator.
            </summary>
      <param name="enumerator">An enumerator.</param>
      <typeparam name="T"></typeparam>
      <returns>An enumerator on a <see cref="T:System.Collections.Generic.List`1" /> made from the items of <paramref name="enumerator" />, or the <paramref name="enumerator" /> object itself
            it is already a <see cref="T:System.Collections.Generic.List`1" /> enumerator.</returns>
    </member>
    <member name="M:Metalama.Framework.RunTime.RunTimeAspectHelper.Buffer(System.Collections.IEnumerator)">
      <summary>
            Evaluates an <see cref="T:System.Collections.IEnumerator" />, stores the result into a <c>List&lt;object&gt;</c> and returns an enumerator for this list.
            If the enumerator is already a list enumerator, returns the input  enumerator.
             The intended side effect of this method is to completely evaluate the input enumerator.
            </summary>
      <param name="enumerator">An enumerator.</param>
      <returns>An enumerator on a <c>List&lt;object&gt;</c> made from the items of <paramref name="enumerator" />, or the <paramref name="enumerator" /> object itself
            it is already a <c>List&lt;object&gt;</c> enumerator.</returns>
    </member>
    <member name="T:Metalama.Framework.Serialization.IArgumentsReader">
      <summary>
            Provides read access to the collection of deserialized arguments.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.IArgumentsReader.TryGetValue``1(System.String,``0@,System.String)">
      <summary>
            Attempts to read a value from the collection, and does not throw an exception if the value does not exist or is <c>null</c>.
            </summary>
      <typeparam name="T">Value type.</typeparam>
      <param name="name">Argument name.</param>
      <param name="value">At output, set to the value of the argument named <paramref name="name" /> in the given optional <paramref name="scope" />.</param>
      <param name="scope">An optional prefix of <paramref name="name" />, similar to a namespace.</param>
      <returns>
        <c>true</c> if the value is defined, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Metalama.Framework.Serialization.IArgumentsReader.GetValue``1(System.String,System.String)">
      <summary>
            Reads a value from the collection, and returns <c>null</c> if the value does not exist.
            </summary>
      <typeparam name="T">Value type.</typeparam>
      <param name="name">Argument name.</param>
      <param name="scope">An optional prefix of <paramref name="name" />, similar to a namespace.</param>
      <returns>The value of the argument named <paramref name="name" /> in the given optional <paramref name="scope" />.</returns>
    </member>
    <member name="T:Metalama.Framework.Serialization.IArgumentsWriter">
      <summary>
            Provides write access to a collection of arguments that need to be serialized.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.IArgumentsWriter.SetValue(System.String,System.Object,System.String)">
      <summary>
            Sets the value of an argument.
            </summary>
      <param name="name">Argument name.</param>
      <param name="value">Argument value. The value can be <c>null</c> or must be serializable.</param>
      <param name="scope">An optional prefix of <paramref name="name" />, similar to a namespace.</param>
    </member>
    <member name="T:Metalama.Framework.Serialization.ICompileTimeSerializable">
      <summary>
            Marks the implementing type as being serializable. Aspects and fabrics are typically serialized when they affect a different project than the current one (by inheritance
            or reference validation). Serialized objects may be deserialized on a different machine than the one on which they have been serialized, and
            a long time after.
            </summary>
      <remarks>
        <para>When a type is marked as compile-time-serializable, all fields and automatic properties should be of a serializable type, except those
            annotated with the <see cref="T:Metalama.Framework.Serialization.NonCompileTimeSerializedAttribute" /> custom attribute. </para>
        <para>The following system types are serializable: intrinsic types, arrays of serializable types, <see cref="T:System.DateTime" />, <see cref="T:System.TimeSpan" />, <see cref="T:System.Globalization.CultureInfo" />, <see cref="T:System.Guid" />, <see cref="T:System.Collections.Generic.Dictionary`2" />,
            <see cref="T:System.Collections.Generic.List`1" />, <see cref="T:System.Collections.Immutable.ImmutableArray`1" />, <see cref="T:System.Collections.Immutable.ImmutableDictionary`2" />.
            </para>
        <para>To serialize another system type, implement a <see cref="T:Metalama.Framework.Serialization.ReferenceTypeSerializer" /> or <see cref="T:Metalama.Framework.Serialization.ValueTypeSerializer`1" /> and register it by
            adding a <see cref="T:Metalama.Framework.Serialization.ImportSerializerAttribute" /> custom attribute to the types that uses it.</para>
        <para>To serialize an <see cref="T:Metalama.Framework.Code.IDeclaration" />, use the <see cref="M:Metalama.Framework.Code.IDeclaration.ToRef" /> method and store the <see cref="T:Metalama.Framework.Code.IRef`1" />.</para>
      </remarks>
    </member>
    <member name="T:Metalama.Framework.Serialization.ICompileTimeSerializationCallback">
      <summary>
            Interface that can be implemented by serializable classes.
            It defines methods <see cref="M:Metalama.Framework.Serialization.ICompileTimeSerializationCallback.OnDeserialized" /> and <see cref="M:Metalama.Framework.Serialization.ICompileTimeSerializationCallback.OnSerializing" /> called during serialization.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.ICompileTimeSerializationCallback.OnDeserialized">
      <summary>
            Method called after the object has been deserialized.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.ICompileTimeSerializationCallback.OnSerializing">
      <summary>
            Method called before the object is being serialized.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Serialization.ImportSerializerAttribute">
      <summary>
            Custom attribute that, when applied to a serializable type, specifies that the serializer of this type has
            a dependency on another serializer. The custom attribute can be applied at assembly level; it then
            applies to all serializable types in this assembly.
            </summary>
      <remarks>
        <para>This custom attribute is useful to add serializers to types of third-party assemblies.
            For types whose source code you can modify, it is preferable to use <see cref="T:Metalama.Framework.Serialization.ICompileTimeSerializable" />.
            </para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Serialization.ImportSerializerAttribute.#ctor(System.Type,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Metalama.Framework.Serialization.ImportSerializerAttribute" /> class.
            </summary>
      <param name="objectType">Type of the object to be made serializable.</param>
      <param name="serializerType">Serializer type. This type must implement <see cref="T:Metalama.Framework.Serialization.ISerializer" /> or <see cref="T:Metalama.Framework.Serialization.ISerializerFactory" />,
            and must have a public default constructor. If <paramref name="serializerType" /> is a generic type, if must have the same number
            of generic type parameters as <paramref name="objectType" />, and have a compatible set of constraints.</param>
    </member>
    <member name="P:Metalama.Framework.Serialization.ImportSerializerAttribute.ObjectType">
      <summary>
            Gets the type of the object to be made serializable.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Serialization.ImportSerializerAttribute.SerializerType">
      <summary>
            Gets the serializer type.
            </summary>
      <remarks>
            This type must implement <see cref="T:Metalama.Framework.Serialization.ISerializer" /> or <see cref="T:Metalama.Framework.Serialization.ISerializerFactory" />,
            and must have a public default constructor. If <see cref="P:Metalama.Framework.Serialization.ImportSerializerAttribute.SerializerType" /> is a generic type, if must have the same number
            of generic type parameters as <see cref="P:Metalama.Framework.Serialization.ImportSerializerAttribute.ObjectType" />, and have a compatible set of constraints.
            </remarks>
    </member>
    <member name="T:Metalama.Framework.Serialization.ISerializer">
      <summary>
            Defines the semantics of an object serializer.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.ISerializer.Convert(System.Object,System.Type)">
      <summary>
            Converts a value into a given target type.
            </summary>
      <param name="value">Value to be converted.</param>
      <param name="targetType">target type.</param>
      <returns>The <paramref name="value" /> converted to <paramref name="targetType" />.</returns>
      <remarks>
        <para>This method allows for additional flexibility if the serialization-time type is
                        not equal to the deserialization-time. The current method is invoked
            at deserialization time to perform the conversion.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Serialization.ISerializer.CreateInstance(System.Type,Metalama.Framework.Serialization.IArgumentsReader)">
      <summary>
            Creates an instance of the given type.
            </summary>
      <param name="type">Type of the instance to be created.</param>
      <param name="constructorArguments">Gives access to arguments required to create the instance.</param>
      <returns>An instance of type <paramref name="type" /> initialized using <paramref name="constructorArguments" />.</returns>
      <remarks>
        <para>This method is invoked during deserialization. If <see cref="P:Metalama.Framework.Serialization.ISerializer.IsTwoPhase" /> is <c>true</c>, the <see cref="M:Metalama.Framework.Serialization.ISerializer.DeserializeFields(System.Object@,Metalama.Framework.Serialization.IArgumentsReader)" />
                method is called later to complete deserialization.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Serialization.ISerializer.DeserializeFields(System.Object@,Metalama.Framework.Serialization.IArgumentsReader)">
      <summary>
            Completes the second phase of deserialization by setting fields and other properties.
            </summary>
      <param name="obj">The object being deserialized.</param>
      <param name="initializationArguments">Gives access to field values.</param>
      <remarks>
        <para>This method is only invoked if <see cref="P:Metalama.Framework.Serialization.ISerializer.IsTwoPhase" /> is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:Metalama.Framework.Serialization.ISerializer.SerializeObject(System.Object,Metalama.Framework.Serialization.IArgumentsWriter,Metalama.Framework.Serialization.IArgumentsWriter)">
      <summary>
            Serializes an object.
            </summary>
      <param name="obj"></param>
      <param name="constructorArguments">Gives access to arguments that will be passed to the <see cref="M:Metalama.Framework.Serialization.ISerializer.CreateInstance(System.Type,Metalama.Framework.Serialization.IArgumentsReader)" /> method during deserialization.</param>
      <param name="initializationArguments">Gives access to arguments that will be passed to the <see cref="M:Metalama.Framework.Serialization.ISerializer.DeserializeFields(System.Object@,Metalama.Framework.Serialization.IArgumentsReader)" /> method during deserialization.</param>
    </member>
    <member name="P:Metalama.Framework.Serialization.ISerializer.IsTwoPhase">
      <summary>
            Gets a value indicating whether <see cref="M:Metalama.Framework.Serialization.ISerializer.DeserializeFields(System.Object@,Metalama.Framework.Serialization.IArgumentsReader)" /> should be invoked during deserialization.
            The value is <c>false</c> if <see cref="M:Metalama.Framework.Serialization.ISerializer.CreateInstance(System.Type,Metalama.Framework.Serialization.IArgumentsReader)" /> return fully created object, <c>true</c> otherwise.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Serialization.ISerializerFactory">
      <summary>
            Defines a method <see cref="M:Metalama.Framework.Serialization.ISerializerFactory.CreateSerializer(System.Type)" />, which creates instances of the <see cref="T:Metalama.Framework.Serialization.ISerializer" /> interface for
            given object types.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.ISerializerFactory.CreateSerializer(System.Type)">
      <summary>
            Creates an instance of the <see cref="T:Metalama.Framework.Serialization.ISerializer" /> interface for a given object type.
            </summary>
      <param name="objectType">Type of object being serialized or deserialized.</param>
      <returns>A new instance implementing the <see cref="T:Metalama.Framework.Serialization.ISerializer" /> interface.</returns>
    </member>
    <member name="T:Metalama.Framework.Serialization.NonCompileTimeSerializedAttribute">
      <summary>
            An attribute that marks a field of a type that implements <see cref="T:Metalama.Framework.Serialization.ICompileTimeSerializable" /> as non-serialized.
            </summary>
    </member>
    <member name="M:Metalama.Framework.Serialization.ReferenceTypeSerializer.CreateInstance(System.Type,Metalama.Framework.Serialization.IArgumentsReader)">
      <summary>
            Creates an instance of the given type.
            </summary>
      <param name="type">Type of the instance to be created.</param>
      <param name="constructorArguments">Gives access to arguments required to create the instance.</param>
      <returns>An instance of type <paramref name="type" /> initialized using <paramref name="constructorArguments" />.</returns>
    </member>
    <member name="M:Metalama.Framework.Serialization.ReferenceTypeSerializer.SerializeObject(System.Object,Metalama.Framework.Serialization.IArgumentsWriter,Metalama.Framework.Serialization.IArgumentsWriter)">
      <summary>
            Serializes an object.
            </summary>
      <param name="obj"></param>
      <param name="constructorArguments">Gives access to arguments that will be passed to the <see cref="M:Metalama.Framework.Serialization.ReferenceTypeSerializer.CreateInstance(System.Type,Metalama.Framework.Serialization.IArgumentsReader)" /> method during deserialization.</param>
      <param name="initializationArguments">Gives access to arguments that will be passed to the <see cref="M:Metalama.Framework.Serialization.ReferenceTypeSerializer.DeserializeFields(System.Object,Metalama.Framework.Serialization.IArgumentsReader)" /> method during deserialization.</param>
    </member>
    <member name="M:Metalama.Framework.Serialization.ReferenceTypeSerializer.DeserializeFields(System.Object,Metalama.Framework.Serialization.IArgumentsReader)">
      <summary>
            Completes the second phase of deserialization by setting fields and other properties.
            </summary>
      <param name="obj">The object being deserialized.</param>
      <param name="initializationArguments">Gives access to field values.</param>
    </member>
    <member name="M:Metalama.Framework.Serialization.ReferenceTypeSerializer.Convert(System.Object,System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Serialization.ValueTypeSerializer`1.SerializeObject(`0,Metalama.Framework.Serialization.IArgumentsWriter)">
      <summary>
            Serializes an object.
            </summary>
      <param name="obj"></param>
      <param name="constructorArguments">Gives access to arguments that will be passed to the <see cref="M:Metalama.Framework.Serialization.ValueTypeSerializer`1.DeserializeObject(Metalama.Framework.Serialization.IArgumentsReader)" /> method during deserialization.</param>
    </member>
    <member name="M:Metalama.Framework.Serialization.ValueTypeSerializer`1.DeserializeObject(Metalama.Framework.Serialization.IArgumentsReader)">
      <summary>
            Creates an instance of the given type.
            </summary>
      <param name="constructorArguments">Gives access to arguments required to create the instance.</param>
      <returns>An instance of type <typeparamref name="T" /> initialized using <paramref name="constructorArguments" />.</returns>
    </member>
    <member name="M:Metalama.Framework.Serialization.ValueTypeSerializer`1.Convert(System.Object,System.Type)">
      <inheritdoc />
    </member>
    <member name="T:Metalama.Framework.Services.IGlobalService">
      <summary>
            Base interface to be inherited by all classes and interfaces that implement globally-scoped services.
            </summary>
      <seealso cref="T:Metalama.Framework.Services.IProjectService" />
    </member>
    <member name="T:Metalama.Framework.Services.IProjectService">
      <summary>
            Base interface to be inherited by all classes and interfaces that implement project-scoped services.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Services.IServiceProvider`1">
      <summary>
            A strongly-typed variant of <see cref="T:System.IServiceProvider" /> that returns services for a given scope.
            </summary>
      <typeparam name="TBase">The base interface for the services in the scope.</typeparam>
      <remarks>
            The generic interface is intentionally not variant.
            </remarks>
    </member>
    <member name="M:Metalama.Framework.Services.ISourceGeneratorDetectionService.IsWellKnownGeneratedDeclaration(Metalama.Framework.Code.IMember)">
      <summary>
            Returns whether the given declaration is a member marked for generation by a source generator and should not be overridden by Metalama.
            </summary>
      <remarks>This checks that the declaration is a partial member with one of a list of known source generator attributes applied.</remarks>
    </member>
    <member name="T:Metalama.Framework.Utilities.HiddenAttribute">
      <summary>
            Specifies how the interface must be hidden by tools like our LinqPad adapter.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Utilities.InternalImplementAttribute">
      <summary>
            A custom attribute that means that the interface cannot be implemented by another assembly than
            the one that declared it, except if the referencing assembly sees the internals of the declaring assembly.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Utilities.IPromise">
      <summary>
            Encapsulates value that must be defined later. Promises can used to pass introduced declarations to templates as arguments
            when these declarations have not been introduced yet, resolving a chicken-or-egg situation. When objects of type <see cref="T:Metalama.Framework.Utilities.IPromise" /> are passed to a template,
            the template will automatically receive its resolved <see cref="P:Metalama.Framework.Utilities.IPromise.Value" /> instead of the <see cref="T:Metalama.Framework.Utilities.IPromise" /> object. The <see cref="T:Metalama.Framework.Utilities.Promise`1" /> class
            implements this interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.IPromise.IsResolved">
      <summary>
            Gets a value indicating whether the <see cref="P:Metalama.Framework.Utilities.IPromise.Value" /> setter has been successfully invoked. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.IPromise.IsFaulted">
      <summary>
            Gets a value indicating whether the promise is faulted. In this case, the <see cref="P:Metalama.Framework.Utilities.IPromise.Exception" /> property is set.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.IPromise.Value">
      <summary>
            Gets the value. Throws <see cref="T:System.InvalidOperationException" /> if <see cref="P:Metalama.Framework.Utilities.IPromise.IsResolved" /> is <c>false</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.IPromise.Exception">
      <summary>
            Gets the <see cref="T:System.Exception" /> that the promise resulted in, if <see cref="P:Metalama.Framework.Utilities.IPromise.IsFaulted" /> is <c>true</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Utilities.IPromise`1">
      <summary>
            Encapsulates value that must be defined later. Promises can used to pass introduced declarations to templates as arguments
            when these declarations have not been introduced yet, resolving a chicken-or-egg situation. When objects of type <see cref="T:Metalama.Framework.Utilities.IPromise" /> are passed to a template,
            the template will automatically receive its resolved <see cref="P:Metalama.Framework.Utilities.IPromise`1.Value" /> instead of the <see cref="T:Metalama.Framework.Utilities.IPromise" /> object. The <see cref="T:Metalama.Framework.Utilities.Promise`1" /> class
            implements this interface.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.IPromise`1.Value">
      <summary>
            Gets the value. Throws <see cref="T:System.InvalidOperationException" /> if <see cref="P:Metalama.Framework.Utilities.IPromise.IsResolved" /> is <c>false</c>.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Utilities.Promise`1">
      <summary>
            Encapsulates value that must be defined later. Promises can used to to pass introduced declarations to templates as arguments
            when these declarations have not been introduced yet, resolving a chicken-or-egg situation. When objects of type <see cref="T:Metalama.Framework.Utilities.IPromise" /> are passed to a template,
            the template will automatically receive its resolved <see cref="P:Metalama.Framework.Utilities.Promise`1.Value" /> instead of the <see cref="T:Metalama.Framework.Utilities.IPromise" /> object. 
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.Promise`1.Exception">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Utilities.Promise`1.IsResolved">
      <inheritdoc />
    </member>
    <member name="P:Metalama.Framework.Utilities.Promise`1.IsFaulted">
      <inheritdoc />
    </member>
    <member name="M:Metalama.Framework.Utilities.Promise`1.SetException(System.Exception)">
      <summary>
            Sets the <see cref="T:System.Exception" /> in which the promise resulted and sets the <see cref="P:Metalama.Framework.Utilities.Promise`1.IsFaulted" /> property to <c>true</c>.
            </summary>
    </member>
    <member name="P:Metalama.Framework.Utilities.Promise`1.Value">
      <summary>
            Gets or sets the deferred value. Getting the property throws an <see cref="T:System.InvalidOperationException" /> if it has not been set before.
            </summary>
    </member>
    <member name="T:Metalama.Framework.Utilities.PromiseExtensions">
      <summary>
            Extension methods for the <see cref="T:Metalama.Framework.Utilities.IPromise`1" /> interface.
            </summary>
    </member>
  </members>
</doc>